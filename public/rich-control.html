<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>大富翁遊戲控制器</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
        }

        body {
            background-color: #f5f5f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 2rem;
        }

        .controller-container {
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            padding: 2rem;
            width: 100%;
            max-width: 600px;
            margin-bottom: 2rem;
        }

        h1 {
            text-align: center;
            color: #5b9df0;
            margin-bottom: 1.5rem;
            font-size: 1.8rem;
        }

        .control-section {
            margin-bottom: 1.5rem;
            padding: 1rem;
            border: 1px solid #eaeaea;
            border-radius: 8px;
        }

        .control-section h2 {
            margin-bottom: 1rem;
            color: #333;
            font-size: 1.2rem;
        }

        .player-select {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-bottom: 1rem;
        }

        .player-btn {
            width: 4rem;
            height: 4rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 1.25rem;
            border: none;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .player-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .player1 {
            background-color: #8ab5f3;
        }

        .player1.selected {
            background-color: #5b9df0;
            box-shadow: 0 0 0 4px rgba(91, 157, 240, 0.3);
        }

        .player2 {
            background-color: #b79de2;
        }

        .player2.selected {
            background-color: #9270ca;
            box-shadow: 0 0 0 4px rgba(146, 112, 202, 0.3);
        }

        .player3 {
            background-color: #ff8a85;
        }

        .player3.selected {
            background-color: #ff544d;
            box-shadow: 0 0 0 4px rgba(255, 84, 77, 0.3);
        }

        .direction-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .direction-btn {
            padding: 1.2rem 2.5rem;  /* 增加內邊距 */
    font-size: 1.3rem;      /* 增大字體 */
    font-weight: bold;
    color: white;
    border: none;
    border-radius: 30px;    /* 更圓的邊角 */
    cursor: pointer;
    transition: all 0.2s;
        }

        .direction-btn:hover {
            transform: scale(1.05);
        }

        .forward {
            background-color: #0cd8b6;
        }

        .forward:hover {
            background-color: #09b699;
        }

        .backward {
            background-color: #ff544d;
        }

        .backward:hover {
            background-color: #e64840;
        }

        .steps-input {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .steps-input label {
            font-weight: bold;
            color: #333;
        }

        .steps-input input {
            width: 4rem;
            padding: 0.5rem;
            border: 1px solid #ccc;
            border-radius: 4px;
            text-align: center;
            font-size: 1rem;
        }

        .connection-status {
            text-align: center;
            margin-bottom: 1rem;
            padding: 0.5rem;
            border-radius: 4px;
            font-weight: bold;
        }

        .connected {
            background-color: #d4edda;
            color: #155724;
        }

        .disconnected {
            background-color: #f8d7da;
            color: #721c24;
        }

        .connecting {
            background-color: #fff3cd;
            color: #856404;
        }

        .game-info {
            margin-top: 1rem;
            padding: 1rem;
            background-color: #f9f9f9;
            border-radius: 8px;
            border: 1px solid #eaeaea;
        }

        .game-info-title {
            font-weight: bold;
            margin-bottom: 0.5rem;
            color: #333;
        }

        .game-info-content {
            color: #555;
        }

        .position-jump {
            margin-top: 1rem;
        }

        .position-jump select {
            padding: 0.5rem;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-right: 0.5rem;
        }

        .position-jump button {
            padding: 0.5rem 1rem;
            background-color: #5b9df0;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .position-jump button:hover {
            background-color: #4a8cdf;
        }

        .action-btn {
            padding: 0.8rem 1.5rem;
            font-size: 1rem;
            background-color: #9270ca;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-top: 1rem;
            width: 100%;
        }

        .action-btn:hover {
            background-color: #7d5fb3;
        }

        .connection-status { /* Ensure styles for connected/disconnected/connecting exist */
            text-align: center; margin-bottom: 1rem; padding: 0.5rem;
            border-radius: 4px; font-weight: bold; transition: background-color 0.3s, color 0.3s;
        }
        .connected { background-color: #d4edda; color: #155724; }
        .disconnected { background-color: #f8d7da; color: #721c24; }
        .connecting { background-color: #fff3cd; color: #856404; }
        button:disabled { opacity: 0.6; cursor: not-allowed; transform: none !important; }





 /* 移動控制按鈕容器 (使用 Flexbox) */
 .direction-buttons-large {
            display: flex;
            gap: 1rem; /* 按鈕間距 */
            justify-content: center; /* 水平居中 (如果需要) */
            margin-top: 1rem; /* 與標題的間距 */
        }

        /* 更大的方塊按鈕樣式 */
        .direction-btn-large {
            flex: 1; /* 讓兩個按鈕平分寬度 */
            padding: 1.5rem 1rem; /* 增加內邊距，讓按鈕變大 */
            font-size: 1.2rem; /* 放大字體 */
            font-weight: bold;
            color: white;
            border: none;
            border-radius: 8px; /* 方塊圓角 */
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }
        .direction-btn-large:hover {
            transform: scale(1.03); /* 稍微縮小 hover 效果 */
            filter: brightness(90%); /* 懸停時稍微變暗 */
        }
        .forward-large { background-color: #0cd8b6; } /* 保持顏色 */
        .backward-large { background-color: #ff544d; } /* 保持顏色 */

        /* 格子資訊按鈕容器 (使用 Flexbox) */
        .info-buttons-small {
            display: flex;
            gap: 0.8rem; /* 按鈕間距 */
            justify-content: center; /* 居中顯示 */
            margin-top: 1rem; /* 與標題的間距 */
        }

        /* 較小的並排按鈕樣式 */
        .info-btn-small {
            padding: 0.5rem 1rem; /* 減小內邊距 */
            font-size: 0.9rem; /* 減小字體 */
            /* background-color: #9270ca; */ /* 保持原紫色或自訂 */
            /* color: white; */
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
            width: auto; /* 讓寬度由內容決定 */
            margin-top: 0; /* 移除原 action-btn 的 margin-top */
        }
        .show-info-small { background-color: #9270ca; color: white; } /* 顯示按鈕顏色 */
        .hide-info-small { background-color: #6c757d; color: white; } /* 關閉按鈕顏色 */

        .info-btn-small:hover {
            filter: brightness(90%);
        }

        /* 移除舊 .action-btn 的特定樣式 (如果不再需要) */
        /* 例如 width: 100%; margin-top: 1rem; */
        /* 如果其他地方還用 .action-btn，保留，只覆蓋需要的 */

         /* 移除 .direction-buttons 和 .direction-btn 的舊樣式 (如果不再用) */
         /* 或者保留，以防萬一，新樣式會覆蓋 */






    </style>
</head>
<body>
    <div class="controller-container">
        <h1>大富翁遊戲控制器</h1>

        <div id="connection-status" class="connection-status disconnected">
            未連接遊戲
        </div>

        <!-- ... (keep player select, move control, jump, actions sections) ... -->
         <div class="control-section">
            <h2>玩家選擇</h2>
            <div class="player-select">
                <button id="player1-btn" class="player-btn player1 selected">P1</button>
                <button id="player2-btn" class="player-btn player2">P2</button>
                <button id="player3-btn" class="player-btn player3">P3</button>
            </div>
        </div>
        <div class="control-section">
            <h2>移動控制</h2>
            
            <div class="direction-buttons">
                <button id="forward-btn" class="direction-btn forward">前進</button>
                <button id="backward-btn" class="direction-btn backward">後退</button>
            </div>




        </div>

         <!-- ★★★ 新增：格子資訊控制區塊 ★★★ -->
         <div class="control-section">
             
            <button id="show-player-info-btn" class="action-btn">顯示</button>
            <button id="hide-player-info-btn" class="action-btn" style="margin-top: 0.5rem; background-color: #6c757d;">關閉</button> <!-- 可以加點間距和不同顏色 -->
        </div>
        <!-- ★★★ 新增結束 ★★★ -->


 



    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const player1Btn = document.getElementById('player1-btn');
            const player2Btn = document.getElementById('player2-btn');
            const player3Btn = document.getElementById('player3-btn');
            const forwardBtn = document.getElementById('forward-btn');
            const backwardBtn = document.getElementById('backward-btn');
         
            const connectionStatusDiv = document.getElementById('connection-status');

              // ★ 新增按鈕引用 ★
    const showPlayerInfoBtn = document.getElementById('show-player-info-btn');
    const hidePlayerInfoBtn = document.getElementById('hide-player-info-btn');
    // ↓↓↓ 確保這裡包含了新按鈕的 class 或 ID ↓↓↓
    const allControlButtons = document.querySelectorAll('.controller-container button, .controller-container input, .controller-container select');

            // --- State ---
            let selectedPlayer = 1; // Local controller state
            let gameIsConnected = false;

            // --- WebSocket Variables ---
            let ws = null;
            const wsUrl = `wss://${window.location.host}?clientType=controller`; // Use wss://

            // --- Remove BroadcastChannel ---
            // const channel = new BroadcastChannel('rich_game_channel');

             // --- Disable/Enable Controls ---
            function setControlsEnabled(enabled) {
                allControlButtons.forEach(el => el.disabled = !enabled);
                gameIsConnected = enabled; // Update connection state
                updateConnectionStatusUI(); // Update UI based on actual connection status
            }

            // --- Update Connection Status UI ---
            function updateConnectionStatusUI() {
                 if (ws && ws.readyState === WebSocket.OPEN && gameIsConnected) {
                    connectionStatusDiv.className = 'connection-status connected';
                    connectionStatusDiv.textContent = '已連接遊戲';
                 } else if (ws && ws.readyState === WebSocket.CONNECTING) {
                     connectionStatusDiv.className = 'connection-status connecting';
                     connectionStatusDiv.textContent = '連接中...';
                 } else {
                    connectionStatusDiv.className = 'connection-status disconnected';
                    connectionStatusDiv.textContent = '未連接遊戲';
                 }
             }


            // --- WebSocket Connection Logic ---
            function connectWebSocket() {
                 console.log(`Attempting to connect WebSocket to ${wsUrl}`);
                 setControlsEnabled(false); // Disable controls while connecting
                 connectionStatusDiv.className = 'connection-status connecting';
                 connectionStatusDiv.textContent = '連接中...';
                 ws = new WebSocket(wsUrl);

                 ws.onopen = () => {
                    console.log('WebSocket connection established (Controller)');
                    // Don't enable controls yet, wait for game status confirmation
                    // Request initial game state
                    sendCommand('getGameState');
                 };

                 ws.onmessage = (event) => {
                    console.log('WebSocket message received (Controller):', event.data);
                     try {
                         const message = JSON.parse(event.data);
                         handleServerMessage(message);
                     } catch (error) {
                         console.error('Failed to parse WebSocket message:', error);
                     }
                 };

                 ws.onerror = (error) => {
                     console.error('WebSocket error (Controller):', error);
                     setControlsEnabled(false);
                     updateConnectionStatusUI();
                 };

                 ws.onclose = (event) => {
                     console.log(`WebSocket connection closed (Controller): Code=${event.code}, Reason=${event.reason}`);
                     ws = null;
                     setControlsEnabled(false);
                     updateConnectionStatusUI();
                     gameInfoContentDiv.textContent = '與伺服器斷線，5秒後嘗試重連...';
                     setTimeout(connectWebSocket, 5000); // Reconnect
                 };
             }


             // --- Handle Messages from Server ---
            function handleServerMessage(message) {
                switch (message.type) {
                    case 'gameStateUpdate':
                        console.log("Received game state update:", message.data);
                        updateGameInfo(message.data);
                        // If we just connected and received state, enable controls
                        if (!gameIsConnected) {
                            setControlsEnabled(true);
                        }
                        break;
                     case 'gameStatus':
                         console.log("Received game status:", message.status);
                         gameIsConnected = (message.status === 'connected');
                         setControlsEnabled(gameIsConnected); // Enable/disable based on game connection
                         updateConnectionStatusUI();
                         if (gameIsConnected) {
                             gameInfoContentDiv.textContent = '遊戲已連接，等待狀態更新...';
                              // Request state again if needed
                             sendCommand('getGameState');
                         } else {
                             gameInfoContentDiv.textContent = '遊戲已斷線。';
                         }
                         break;
                    case 'error':
                        console.error('Received error from server:', message.message);
                        gameInfoContentDiv.textContent = `錯誤: ${message.message}`;
                        // Decide if controls should be disabled based on error
                        break;
                     // Add other message types if the server sends confirmations, etc.
                     default:
                         console.log("Received unhandled message type:", message.type);
                 }
             }

             // --- Update Controller UI based on Game State ---
            function updateGameInfo(gameState) {
                 if (!gameState) {
                     gameInfoContentDiv.textContent = '無法獲取遊戲狀態。';
                     return;
                 }
                 // Update selected player button visually based on game state
                 selectPlayerUI(gameState.selectedPlayer || 1);
         const controlsShouldBeDisabled = gameState.isMoving || !gameIsConnected;
         forwardBtn.disabled = controlsShouldBeDisabled;
         backwardBtn.disabled = controlsShouldBeDisabled;
         // ★ 控制新按鈕的禁用狀態 ★
         showPlayerInfoBtn.disabled = controlsShouldBeDisabled;
         hidePlayerInfoBtn.disabled = controlsShouldBeDisabled;
             }

              // Update position select dropdown
             let positionSelectPopulated = false;
             function updatePositionSelect(cellCount) {
                 if (positionSelectPopulated && positionSelect.options.length === cellCount) return; // Avoid unnecessary updates
                 positionSelect.innerHTML = ''; // Clear existing
                 for (let i = 0; i < cellCount; i++) {
                     const opt = document.createElement('option');
                     opt.value = i;
                     opt.textContent = `位置 ${i}`;
                     positionSelect.appendChild(opt);
                 }
                 positionSelectPopulated = true;
             }




  // --- ★ 新增事件監聽器 ★ ---
  showPlayerInfoBtn.addEventListener('click', () => {
        console.log(`Sending showPlayerInfo command for player ${selectedPlayer}`);
        // ★ 發送新指令，帶上當前控制器選中的玩家 ★
        sendCommand('showPlayerInfo', { player: selectedPlayer });
    });

    hidePlayerInfoBtn.addEventListener('click', () => {
        console.log(`Sending hidePlayerInfo command`);
        // ★ 發送隱藏指令，不需要玩家參數 ★
        sendCommand('hidePlayerInfo', {});
    });
    // --- 事件監聽器添加結束 ---



            // --- Send Command via WebSocket ---
            function sendCommand(command, params = {}) {
                if (!ws || ws.readyState !== WebSocket.OPEN) {
                    console.error('WebSocket not connected, cannot send command.');
                    gameInfoContentDiv.textContent = '錯誤：未連接到伺服器。';
                    setControlsEnabled(false); // Ensure controls are disabled if WS disconnects
                    updateConnectionStatusUI();
                    return;
                }
                const message = {
                    type: 'controlCommand', // Send as a command type
                    command,
                    params
                };
                console.log('Sending command via WebSocket:', message);
                ws.send(JSON.stringify(message));
            }

            // --- UI Actions ---
            function selectPlayerUI(playerNum) {
                 selectedPlayer = playerNum; // Update local state for sending commands
                 player1Btn.classList.toggle('selected', playerNum === 1);
                 player2Btn.classList.toggle('selected', playerNum === 2);
                 player3Btn.classList.toggle('selected', playerNum === 3);
                 // Note: We don't send a 'selectPlayer' command here anymore,
                 // because the *game's* state dictates the selected player display.
                 // We just update the local `selectedPlayer` variable for *sending* commands.
                 console.log(`Controller UI updated for Player ${playerNum}`);
                 sendCommand('selectPlayer', { player: playerNum });

             }

            function movePlayer(direction) {
                console.log(`Sending move command: P${selectedPlayer}, ${direction}, 1 step`); // <-- 日誌也改成 1 step
                sendCommand('movePlayer', {
                    player: selectedPlayer, // Use the locally selected player for the command
                    direction,
                    steps: 1
                });
            }

            function jumpToPosition() {
                const position = parseInt(positionSelect.value);
                 if (!isNaN(position)) {
                    console.log(`Sending jump command: P${selectedPlayer} to position ${position}`);
                     sendCommand('jumpToPosition', {
                         player: selectedPlayer,
                         position
                     });
                 } else {
                     console.error("Invalid position selected for jump:", positionSelect.value);
                 }
            }

            // --- Event Listeners ---
            player1Btn.addEventListener('click', () => selectPlayerUI(1)); // Only update local UI selection
            player2Btn.addEventListener('click', () => selectPlayerUI(2));
            player3Btn.addEventListener('click', () => selectPlayerUI(3));
            forwardBtn.addEventListener('click', () => movePlayer('forward'));
            backwardBtn.addEventListener('click', () => movePlayer('backward'));
    
            

            

            // Initial Setup
             setControlsEnabled(false); // Start disabled
            connectWebSocket(); // Start connection attempt

        }); // End DOMContentLoaded
    </script>

</body>
</html>