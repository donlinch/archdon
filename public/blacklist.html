<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>出貨黑名單偵測與管理</title>
    <style>
        /* General Styles */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* 使用更常見的無襯線字體 */
            line-height: 1.6;
            margin: 0;
            background-color: #eef2f7; /* 淺藍灰色背景 */
            color: #333; /* 主要文字顏色 */
        }

        .app-container {
            max-width: 900px; /* 增加最大寬度 */
            margin: 20px auto; /* 置中並增加上下邊距 */
            background: #fff;
            border-radius: 12px; /* 更圓潤的邊角 */
            overflow: hidden; /* 確保內部內容不會超出圓角 */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1); /* 更明顯的陰影 */
        }

        h1, h2, h3 {
            color: #2c3e50; /* 深藍色標題 */
            margin-top: 0;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #ecf0f1; /* 淺灰色分隔線 */
        }

        h1 {
            font-size: 2em;
            padding-top: 10px;
            border-bottom: none; /* 主標題不需要底部線 */
        }

         h2 {
             font-size: 1.6em;
         }

         h3 {
             font-size: 1.3em;
             border-bottom: 1px dashed #bdc3c7; /* 表單區塊使用虛線分隔 */
             margin-bottom: 15px;
             padding-bottom: 8px;
         }


        /* Tab Styles */
        .tabs {
            display: flex;
            background-color: #34495e; /* 深藍色背景 */
            color: #ecf0f1; /* 淺灰色文字 */
        }
        .tab-button {
            flex-grow: 1; /* 讓按鈕平分空間 */
            padding: 15px 20px;
            cursor: pointer;
            border: none;
            background-color: transparent;
            color: #ecf0f1;
            outline: none;
            font-size: 1.1rem;
            font-weight: bold;
            transition: background-color 0.3s ease, color 0.3s ease;
            text-align: center;
        }
        .tab-button:hover {
            background-color: #415a72; /* 懸停時顏色變深 */
        }
        .tab-button.active {
            background-color: #ecf0ff; /* 活躍背景色 (淺藍) */
            color: #2c3e50; /* 活躍文字顏色 (深藍) */
            border-bottom: 3px solid #3498db; /* 藍色底部線 */
        }

        .tab-content {
            display: none;
            padding: 25px; /* 增加內邊距 */
        }
        .tab-content.active {
            display: block;
        }

        /* Form & Input Styles */
        .form-group {
            margin-bottom: 20px; /* 增加表單組間距 */
        }
        .form-group label {
            display: block;
            margin-bottom: 8px; /* 增加標籤與輸入框間距 */
            font-weight: bold;
            color: #555; /* 標籤顏色 */
        }
        .form-group input[type="text"],
        textarea {
            width: 100%;
            padding: 12px; /* 增加內邊距 */
            border: 1px solid #bdc3c7; /* 淺灰色邊框 */
            border-radius: 6px; /* 圓潤邊角 */
            box-sizing: border-box;
            font-size: 1rem;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }

        .form-group input[type="text"]:focus,
        textarea:focus {
            border-color: #3498db; /* 聚焦時變藍色 */
            box-shadow: 0 0 5px rgba(52, 152, 219, 0.5); /* 聚焦時發光效果 */
            outline: none; /* 移除默認聚焦邊框 */
        }

         textarea {
             resize: vertical; /* 允許垂直調整大小 */
             min-height: 150px; /* 最小高度 */
         }


        /* Button Styles */
        button {
            display: inline-block;
            background: #3498db; /* 藍色主要按鈕 */
            color: white;
            padding: 12px 25px; /* 增加內邊距 */
            border: none;
            border-radius: 6px; /* 圓潤邊角 */
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            margin-right: 10px;
            transition: background-color 0.3s ease, opacity 0.3s ease;
        }
        button:hover {
            background: #2980b9; /* 懸停時顏色變深 */
        }
         button:active {
             opacity: 0.9; /* 點擊時稍微變透明 */
         }

         button.delete {
             background: #e74c3c; /* 紅色刪除按鈕 */
         }
         button.delete:hover {
             background: #c0392b;
         }
         button.edit {
             background: #f39c12; /* 橘色編輯按鈕 */
         }
         button.edit:hover {
             background: #e67e22;
         }
         button.cancel {
             background: #95a5a6; /* 灰色取消按鈕 */
         }
         button.cancel:hover {
             background: #7f8c8d;
         }

        /* Results & Messages */
        #detection-results {
            margin-top: 25px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #ecf0f1; /* 淺灰色背景 */
            white-space: pre-wrap;
            word-wrap: break-word;
            min-height: 100px; /* 最小高度避免內容過少時收縮太小 */
        }
        .match {
            color: #e74c3c; /* 紅色 for matches */
            font-weight: bold;
            font-size: 1.2em;
        }
        .no-match {
            color: #2ecc71; /* 綠色 for no matches */
            font-weight: bold;
            font-size: 1.2em;
        }
        .blacklist-match-item {
            margin-top: 20px; /* 增加項目間距 */
            padding-top: 15px;
            border-top: 1px dashed #bdc3c7; /* 虛線分隔不同匹配項 */
        }
        .criteria-list {
            margin-left: 25px; /* 增加縮進 */
            font-size: 0.95rem;
            color: #555;
            list-style: disc inside; /* 圓點列表 */
            padding-left: 0; /* 移除默認列表左邊距 */
        }
         .criteria-list li {
             margin-bottom: 5px; /* 列表項間距 */
         }


        /* Table Styles */
        #blacklist-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            border-radius: 8px; /* 表格整體圓角 */
            overflow: hidden; /* 配合整體圓角 */
        }
        #blacklist-table th, #blacklist-table td {
            border: 1px solid #dde4e9; /* 淺邊框 */
            padding: 12px; /* 增加內邊距 */
            text-align: left;
            word-break: break-word;
        }
        #blacklist-table th {
            background-color: #34495e; /* 表頭背景色 */
            color: #ecf0f1; /* 表頭文字顏色 */
            font-weight: bold;
            text-transform: uppercase; /* 文字大寫 (可選) */
            font-size: 0.9em;
        }
        #blacklist-table tbody tr:nth-child(even) {
            background-color: #f8f9fa; /* 斑馬條紋 */
        }
        #blacklist-table tbody tr:hover {
            background-color: #e9ecef; /* 懸停效果 */
        }
        #blacklist-table td button {
             padding: 6px 12px; /* 調整表格內按鈕大小 */
             font-size: 0.85rem;
             margin-right: 5px;
             border-radius: 4px; /* 調整按鈕圓角 */
        }
         #blacklist-table td button:last-child {
             margin-right: 0;
         }
         .no-data {
             text-align: center;
             color: #7f8c8d; /* 灰色文字 */
             font-style: italic;
             padding: 20px;
         }

        /* Responsive adjustments (basic) */
        @media (max-width: 768px) {
            .app-container {
                margin: 10px; /* 小螢幕減少邊距 */
            }
            .tabs {
                 flex-direction: column; /* 小螢幕按鈕堆疊 */
            }
            .tab-button {
                 border-bottom: 1px solid rgba(255, 255, 255, 0.1); /* 分隔堆疊的按鈕 */
            }
            .tab-button.active {
                 border-bottom: 3px solid #3498db;
            }
            #blacklist-table th, #blacklist-table td {
                padding: 8px; /* 小螢幕減少表格內邊距 */
            }
        }


    </style>
</head>
<body>

    <div class="app-container"> <!-- Wrapper for better styling -->

        <div class="tabs">
            <button class="tab-button active" onclick="openTab(event, 'tab1Content')">黑名單偵測</button>
            <button class="tab-button" onclick="openTab(event, 'tab2Content')">黑名單管理</button>
        </div>

        <div id="tab1Content" class="tab-content active">
            <h1>出貨黑名單偵測器</h1>
            <p>請將出貨單文字貼入下方區域，然後點擊「偵測黑名單」。</p>

            <textarea id="orderText" rows="10" placeholder="請貼上出貨單內容，範例如下：
姓名: 林建文
電話: 0912-345-678
Email: donlinch3@gmail.com
地點: 台北市中山區南京東路
備註: 請盡快出貨"></textarea>

            <button id="checkButton">偵測黑名單</button>

            <h2>偵測結果</h2>
            <div id="detection-results">請貼上出貨單文字並點擊按鈕進行偵測。</div>
        </div>

        <div id="tab2Content" class="tab-content">
            <h1>黑名單管理</h1>

            <div id="blacklist-form">
                <h3>新增/編輯黑名單</h3>
                 <input type="hidden" id="blacklist-id"> <!-- Hidden field for edit mode -->
                <div class="form-group">
                    <label for="name-input">姓名:</label>
                    <input type="text" id="name-input" placeholder="請輸入姓名">
                </div>
                <div class="form-group">
                    <label for="phone-input">電話:</label>
                    <input type="text" id="phone-input" placeholder="請輸入電話">
                </div>
                 <div class="form-group">
                    <label for="email-input">Email:</label>
                    <input type="text" id="email-input" placeholder="請輸入Email">
                </div>
                 <div class="form-group">
                    <label for="location-input">地點/地址:</label>
                    <input type="text" id="location-input" placeholder="請輸入地點或地址">
                </div>
                <button id="add-edit-button">新增黑名單</button>
                 <button id="cancel-edit-button" class="cancel" style="display:none;">取消編輯</button>
            </div>

            <h3>現有黑名單列表</h3>
            <table id="blacklist-table">
                <thead>
                    <tr>
                        <th>姓名</th>
                        <th>電話</th>
                        <th>Email</th>
                        <th>地點/地址</th>
                        <th>操作</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Blacklist items will be rendered here -->
                </tbody>
            </table>
        </div>
    </div> <!-- End of app-container -->


    <script>
        // --- 資料儲存與載入 ---
        let blacklist = []; // Initialize blacklist array

        /**
         * Load blacklist data from API.
         */
        async function loadBlacklist() {
            try {
                const response = await fetch('/api/blacklist');
                if (!response.ok) throw new Error(`HTTP錯誤 ${response.status}`);
                blacklist = await response.json();
                console.log("Blacklist loaded from API:", blacklist);
            } catch (err) {
                console.error("Error loading blacklist:", err);
                blacklist = [];
            }
        }

        /**
         * Save current blacklist data to API.
         */
        async function saveBlacklist() {
            // 由於現在是直接操作API，這個函數可能不需要了
            // 或者可以改為只處理當前頁面的數據同步
            console.log("Blacklist changes are now saved directly via API calls");
        }

        // --- 設定偵測閾值 ---
        const nameSimilarityThreshold = 75; // 姓名相似度百分比 (0-100)。用於高相似度匹配
        const nameMaxDistance = 2;          // 姓名允許的最大 Levenshtein 距離
        const nameMinLengthForDistanceCheck = 3; // 名字需要達到此長度才啟用距離檢查 (e.g., 3-character names like "楊心潤")

        const emailUserSimilarityThreshold = 80; // Email用戶名相似度百分比 (0-100)。建議 80-90
        const locationInclusionThreshold = 0.7; // 地點文字包含的比例閾值 (0-1)。

        // --- 標準化與正規化函數 ---
        function normalizeName(name) {
            if (!name) return "";
            return String(name).replace(/\s+/g, '').toLowerCase();
        }

        function normalizeEmail(email) {
            if (!email) return "";
            let normalized = String(email).toLowerCase();
            const parts = normalized.split('@');
            if (parts.length === 2) {
                const username = parts[0];
                const domain = parts[1];
                if (domain === 'gmail.com' || domain.endsWith('.gmail.com') || domain === 'googlemail.com') {
                    let cleanedUsername = username.replace(/\./g, '');
                    const plusIndex = cleanedUsername.indexOf('+');
                    if (plusIndex !== -1) {
                        cleanedUsername = cleanedUsername.substring(0, plusIndex);
                    }
                    return cleanedUsername + '@' + domain;
                }
            }
            return normalized;
        }

         function normalizePhone(phone) {
            if (!phone) return "";
            return String(phone).replace(/\D/g, '');
        }

        function normalizeLocation(location) {
             if (!location) return "";
             return String(location).replace(/\s+/g, '').toLowerCase();
        }

        // --- 相似度演算法：Levenshtein Distance ---
        function levenshteinDistance(s1, s2) {
             if (s1.length === 0) return s2.length;
             if (s2.length === 0) return s1.length;

            // Use a matrix for DP
            const matrix = [];
            for (let i = 0; i <= s1.length; i++) {
                matrix[i] = [i];
            }
            for (let j = 0; j <= s2.length; j++) {
                matrix[0][j] = j;
            }

            for (let i = 1; i <= s1.length; i++) {
                for (let j = 1; j <= s2.length; j++) {
                    const cost = (s1[i - 1] === s2[j - 1]) ? 0 : 1;
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j] + 1,      // Deletion
                        matrix[i][j - 1] + 1,      // Insertion
                        matrix[i - 1][j - 1] + cost // Substitution
                    );
                }
            }
            return matrix[s1.length][s2.length];
        }

        function calculateSimilarity(s1, s2) {
            if (!s1 || !s2) return 0;
            // Similarity is calculated on the normalized strings
            const normalizedS1 = normalizeName(s1); // Or adjust if different normalization is needed for similarity percentage
            const normalizedS2 = normalizeName(s2);

            if (!normalizedS1 || !normalizedS2) return 0;

            const distance = levenshteinDistance(normalizedS1, normalizedS2);
            const maxLength = Math.max(normalizedS1.length, normalizedS2.length);
            if (maxLength === 0) return 100;
            return (1 - distance / maxLength) * 100;
        }


        // --- 文本解析 (簡化版) ---
        function parseOrderText(text) {
            const order = {
                name: null,
                phone: null,
                email: null,
                location: null
            };
            const lines = text.split('\n');

            lines.forEach(line => {
                // Case-insensitive check for labels
                const lowerLine = line.toLowerCase();
                if (lowerLine.includes("姓名:")) {
                    order.name = line.split(/姓名:/i)[1]?.trim() || null;
                } else if (lowerLine.includes("電話:")) {
                     order.phone = line.split(/電話:/i)[1]?.trim() || null;
                } else if (lowerLine.includes("email:") || lowerLine.includes("信箱:")) {
                    order.email = line.split(/email:|信箱:/i)[1]?.trim() || null;
                 } else if (lowerLine.includes("地點:") || lowerLine.includes("地址:")) {
                    order.location = line.split(/地點:|地址:/i)[1]?.trim() || null;
                }
            });

            // Fallback regex matches if label extraction fails
            // Use original text for regex to preserve potential format cues
            if (!order.email) {
                const emailMatch = text.match(/\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b/);
                if (emailMatch) order.email = emailMatch[0];
            }

             if (!order.phone) {
                 // More robust phone regex (handles spaces, dashes, parentheses)
                 // Looks for 09 followed by 8 digits, or 09XX-XXX-XXX etc.
                 const phoneMatch = text.match(/(09\d{2}[ -.]?\d{3}[ -.]?\d{3}|09\d{8}|\(?0\d{1,4}\)?[- ]?\d{3,4}[- ]?\d{3,4})/);
                 if (phoneMatch && phoneMatch[0]) order.phone = phoneMatch[0].trim(); // Use trimmed full match if found
             }

             // Name and location fallback from free text is very hard and prone to errors.
             // Sticking to label-based or pattern-based extraction is safer for this simple approach.

            return {
                name: order.name, // Keep original for display in results, normalize later for comparison
                phone: order.phone,
                email: order.email,
                location: order.location
            };
        }


        // --- 核心偵測邏輯 ---
        function checkOrder() {
            const orderText = document.getElementById('orderText').value;
            const resultsDiv = document.getElementById('detection-results');
            resultsDiv.innerHTML = ''; // Clear previous results

            if (!orderText.trim()) {
                resultsDiv.innerHTML = '<p>請貼上出貨單文字。</p>';
                return;
            }

            const orderDetails = parseOrderText(orderText);
            const potentialMatches = [];

            // Normalize order details for comparison
            const normalizedOrder = {
                name: normalizeName(orderDetails.name),
                phone: normalizePhone(orderDetails.phone),
                email: normalizeEmail(orderDetails.email),
                location: normalizeLocation(orderDetails.location)
            };

             console.log("解析後的訂單資訊:", orderDetails); // Debugging line
             console.log("標準化後的訂單資訊:", normalizedOrder); // Debugging line

            if (blacklist.length === 0) {
                resultsDiv.innerHTML = '<p class="no-match">黑名單列表為空，無法進行偵測。</p>';
                return;
            }


            blacklist.forEach(item => {
                // Normalize blacklist item for comparison
                const normalizedBlacklist = {
                    id: item.id, // Keep the original ID for reference
                    name: normalizeName(item.name),
                    phone: normalizePhone(item.phone),
                    email: normalizeEmail(item.email),
                    location: normalizeLocation(item.location)
                };

                const matchedCriteria = [];
                let isMatch = false; // Flag for this specific blacklist item

                console.log(`- 對比黑名單 ID ${item.id}:`, normalizedBlacklist); // Debugging line

                // 1. 姓名比對 (相似度 或 距離)
                // Ensure both names exist before comparing
                if (normalizedOrder.name && normalizedBlacklist.name) {
                    const similarity = calculateSimilarity(normalizedOrder.name, normalizedBlacklist.name); // Use calculateSimilarity for percentage (may use different normalization)
                    const distance = levenshteinDistance(normalizedOrder.name, normalizedBlacklist.name); // Use levenshteinDistance on normalized strings

                    console.log(`  姓名 "${normalizedOrder.name}" vs 黑名單 "${normalizedBlacklist.name}" 相似度: ${similarity.toFixed(2)}%, 距離: ${distance}`); // Debugging

                    let nameMatchReason = null;

                    if (normalizedOrder.name === normalizedBlacklist.name) {
                        nameMatchReason = `姓名完全匹配: "${orderDetails.name || '無'}"`;
                    }
                     // Check similarity threshold (if set and > 0)
                    else if (nameSimilarityThreshold > 0 && similarity >= nameSimilarityThreshold) {
                         nameMatchReason = `姓名相似 (${similarity.toFixed(0)}%): "${orderDetails.name || '無'}" vs 黑名單 "${item.name || '無'}"`;
                    }
                    // Check distance threshold (if set and >= 0)
                    // AND name length is sufficient for both strings
                    else if (nameMaxDistance >= 0 && distance <= nameMaxDistance &&
                              normalizedOrder.name.length >= nameMinLengthForDistanceCheck &&
                              normalizedBlacklist.name.length >= nameMinLengthForDistanceCheck) {
                        nameMatchReason = `姓名距離 (${distance}) <= ${nameMaxDistance}, 長度(${normalizedOrder.name.length}, ${normalizedBlacklist.name.length})符合要求: "${orderDetails.name || '無'}" vs 黑名單 "${item.name || '無'}"`;
                    }

                    if (nameMatchReason) {
                        matchedCriteria.push(nameMatchReason);
                        isMatch = true;
                    }
                }

                // 2. 手機號碼比對 (完全匹配，正規化後)
                if (normalizedOrder.phone && normalizedBlacklist.phone) {
                    console.log(`  電話 "${normalizedOrder.phone}" vs 黑名單 "${normalizedBlacklist.phone}"`); // Debugging
                     if (normalizedOrder.phone === normalizedBlacklist.phone) {
                         matchedCriteria.push(`手機號碼完全匹配 (正規化後): "${orderDetails.phone || '無'}"`);
                         isMatch = true;
                     }
                }

                // 3. Email 比對 (用戶名相似度 或 基本名+數字模式)
                if (normalizedOrder.email && normalizedBlacklist.email) {
                    const orderEmailParts = normalizedOrder.email.split('@');
                    const blacklistEmailParts = normalizedBlacklist.email.split('@');

                    console.log(`  Email "${normalizedOrder.email}" vs 黑名單 "${normalizedBlacklist.email}"`); // Debugging

                    if (orderEmailParts.length === 2 && blacklistEmailParts.length === 2) {
                        const orderUser = orderEmailParts[0];
                        const orderDomain = orderEmailParts[1];
                        const blacklistUser = blacklistEmailParts[0];
                        const blacklistDomain = blacklistEmailParts[1];

                        // Domain must be the same (after normalization)
                        if (orderDomain === blacklistDomain) {
                            // Username similarity (if threshold > 0)
                            const userSimilarity = calculateSimilarity(orderUser, blacklistUser); // Using calculateSimilarity on user parts
                             console.log(`    Email用戶名 "${orderUser}" vs 黑名單 "${blacklistUser}" 相似度: ${userSimilarity.toFixed(2)}% (網域相同: ${orderDomain})`); // Debugging
                            if (emailUserSimilarityThreshold > 0 && userSimilarity >= emailUserSimilarityThreshold) {
                                // Add criteria only if not already matched by exact email match
                                if(normalizedOrder.email !== normalizedBlacklist.email) {
                                     matchedCriteria.push(`Email用戶名相似 (${userSimilarity.toFixed(0)}%) on ${orderDomain}: "${orderDetails.email || '無'}" vs 黑名單 "${item.email || '無'}"`); // Show original emails
                                     isMatch = true;
                                } else {
                                    // If exact match, add a specific message
                                    matchedCriteria.push(`Email完全匹配: "${orderDetails.email || '無'}"`);
                                    isMatch = true;
                                }
                            }
                             // Exact Email match case (redundant if similarity is 100 but clearer)
                             if (normalizedOrder.email === normalizedBlacklist.email && !matchedCriteria.some(c => c.startsWith('Email'))) {
                                 matchedCriteria.push(`Email完全匹配: "${orderDetails.email || '無'}"`);
                                 isMatch = true;
                             }


                            // Basic name + digits pattern detection (e.g., user123 -> user456@gmail.com)
                            // Find the base part (non-digits at the end)
                            // Regex explained: ^(.+?)(\d*)$
                            // ^      - start of string
                            // (.+?)  - capture group 1: one or more characters, non-greedily
                            // (\d*)  - capture group 2: zero or more digits
                            // $      - end of string
                             const blacklistUserBaseMatch = blacklistUser.match(/^(.+?)(\d*)$/);
                             const orderUserBaseMatch = orderUser.match(/^(.+?)(\d*)$/);

                             // Check if both usernames can be split into a base + optional digits
                             // AND the base names are identical AND the order username follows the base+digits pattern
                             if (blacklistUserBaseMatch && blacklistUserBaseMatch[1] && orderUserBaseMatch && orderUserBaseMatch[1]) {
                                 const blacklistUserBase = blacklistUserBaseMatch[1]; // The base string (e.g., "donlinch" from "donlinch3")
                                 const orderUserBase = orderUserBaseMatch[1];       // The base string (e.g., "donlinch" from "donlinch4")

                                // If the base names are identical AND the order username starts with this base
                                // AND the part *after* the base in the order username consists only of digits,
                                // then it's considered a pattern match.
                                 if (orderUserBase === blacklistUserBase &&
                                     orderUser.startsWith(blacklistUserBase) &&
                                     /^\d*$/.test(orderUser.substring(blacklistUserBase.length))) {

                                     console.log(`    Email 模式匹配: 黑名單基礎名 "${blacklistUserBase}", 訂單基礎名 "${orderUserBase}"`); // Debugging

                                     // Add this criteria only if it wasn't already matched by high similarity or exact match
                                     const alreadyMatchedByEmail = matchedCriteria.some(c => c.startsWith('Email'));
                                      if (!alreadyMatchedByEmail) {
                                           matchedCriteria.push(`Email模式匹配 (基本名+數字) on ${orderDomain}: "${orderDetails.email || '無'}" 疑似 "${item.email || '無'}" 相關`); // Show original emails
                                           isMatch = true;
                                      } else {
                                           console.log("    Email pattern matched, but already covered by high username similarity or exact match."); // Debugging
                                      }
                                 }
                             }
                        }
                    }
                }

                // 4. 地點比對 (包含性 或 相似度)
                 if (normalizedOrder.location && normalizedBlacklist.location) {
                     console.log(`  地點 "${normalizedOrder.location}" vs 黑名單 "${normalizedBlacklist.location}"`); // Debugging

                     let locationMatchReason = null;

                     // Simple inclusion check (either string contains the other)
                     // Check inclusion threshold (if set and >= 0)
                      if (locationInclusionThreshold >= 0 && (normalizedOrder.location.includes(normalizedBlacklist.location) || normalizedBlacklist.location.includes(normalizedOrder.location))) {
                          const longerLen = Math.max(normalizedOrder.location.length, normalizedBlacklist.location.length);
                          const shorterLen = Math.min(normalizedOrder.location.length, normalizedBlacklist.location.length);
                           // Ensure the shorter one is a significant portion of the longer one
                           if (longerLen > 0 && shorterLen / longerLen >= locationInclusionThreshold) {
                              locationMatchReason = `地點包含 (${(shorterLen/longerLen*100).toFixed(0)}% coverage): "${orderDetails.location || '無'}" 或 "${item.location || '無'}" 互相包含`; // Show original locations
                           }
                      }
                      // Location similarity (as supplement), using the same threshold as name similarity for simplicity
                       const locSimilarity = calculateSimilarity(normalizedOrder.location, normalizedBlacklist.location); // Using calculateSimilarity on location parts
                       console.log(`    地點相似度: ${locSimilarity.toFixed(2)}%`); // Debugging
                       // Add similarity criteria if it's high (if threshold > 0) and not already covered by inclusion or high similarity
                       if (nameSimilarityThreshold > 0 && locSimilarity >= nameSimilarityThreshold && !locationMatchReason) {
                            locationMatchReason = `地點相似 (${locSimilarity.toFixed(0)}%): "${orderDetails.location || '無'}" vs 黑名單 "${item.location || '無'}"`; // Show original locations
                       }
                       // Exact Location match case
                        if (normalizedOrder.location === normalizedBlacklist.location && !locationMatchReason) {
                             locationMatchReason = `地點完全匹配: "${orderDetails.location || '無'}"`;
                        }


                      if (locationMatchReason) {
                           matchedCriteria.push(locationMatchReason);
                           isMatch = true;
                      }
                 }

                // If any criterion matched for this blacklist item, add it to potential matches
                if (isMatch) {
                    potentialMatches.push({
                        blacklistId: item.id,
                        blacklistDetails: item, // Original item details
                        matchedCriteria: matchedCriteria
                    });
                }
            });

            // Display results
            if (potentialMatches.length > 0) {
                resultsDiv.innerHTML = '<p class="match"><strong>偵測到潛在黑名單項目：</strong></p>';
                potentialMatches.forEach(match => {
                    const item = match.blacklistDetails;
                    resultsDiv.innerHTML += `
                        <div class="blacklist-match-item">
                            <p><strong>黑名單 ID ${item.id}:</strong></p>
                            <p>原始資料: 姓名: ${item.name || '無'}, 電話: ${item.phone || '無'}, Email: ${item.email || '無'}, 地點: ${item.location || '無'}</p>
                            <p>觸發條件:</p>
                            <ul class="criteria-list">
                                ${match.matchedCriteria.map(c => `<li>${c}</li>`).join('')}
                            </ul>
                        </div>
                    `;
                });
            } else {
                resultsDiv.innerHTML = '<p class="no-match">未偵測到潛在黑名單項目。</p>';
            }
        }


        // --- 黑名單管理功能 ---

        const blacklistTableBody = document.querySelector('#blacklist-table tbody');
        const nameInput = document.getElementById('name-input');
        const phoneInput = document.getElementById('phone-input');
        const emailInput = document.getElementById('email-input');
        const locationInput = document.getElementById('location-input');
        const addEditButton = document.getElementById('add-edit-button');
        const cancelEditButton = document.getElementById('cancel-edit-button');
        const blacklistIdInput = document.getElementById('blacklist-id'); // Hidden ID field


        /**
         * Render the blacklist table from the current blacklist array.
         */
        function renderBlacklistTable() {
            blacklistTableBody.innerHTML = ''; // Clear current table body

            if (blacklist.length === 0) {
                 blacklistTableBody.innerHTML = '<tr><td colspan="5" class="no-data">目前沒有黑名單項目。</td></tr>';
                 return;
            }

            // Sort by name for easier viewing (optional) - compare original names for sorting display
            const sortedBlacklist = [...blacklist].sort((a, b) => {
                const nameA = (a.name || '').toLowerCase();
                const nameB = (b.name || '').toLowerCase();
                if (nameA < nameB) return -1;
                if (nameA > nameB) return 1;
                return 0;
            });


            sortedBlacklist.forEach(item => {
                const row = blacklistTableBody.insertRow();
                // Use item.id directly from the stored data
                row.innerHTML = `
                    <td>${item.name || ''}</td>
                    <td>${item.phone || ''}</td>
                    <td>${item.email || ''}</td>
                    <td>${item.location || ''}</td>
                    <td>
                        <button class="edit" data-id="${item.id}">編輯</button>
                        <button class="delete" data-id="${item.id}">刪除</button>
                    </td>
                `;

                // Add event listeners to the buttons in this row
                row.querySelector('.edit').addEventListener('click', handleEditClick);
                row.querySelector('.delete').addEventListener('click', handleDeleteClick);
            });
        }

        /**
         * Handle click on Add/Edit button.
         */
        function handleAddEditClick() {
            const name = nameInput.value.trim();
            const phone = phoneInput.value.trim();
            const email = emailInput.value.trim();
            const location = locationInput.value.trim();
            const itemId = blacklistIdInput.value; // Get ID from hidden field

            if (!name && !phone && !email && !location) {
                alert("請至少輸入姓名、電話、Email 或地點其中一項。");
                return;
            }

            // Normalize inputs for potential duplicate check
             const normalizedNewItem = {
                  name: normalizeName(name),
                  phone: normalizePhone(phone),
                  email: normalizeEmail(email),
                  location: normalizeLocation(location)
             };

            if (itemId) { // Edit mode
                // Find the item by its unique ID
                const itemIndex = blacklist.findIndex(item => String(item.id) === itemId);
                if (itemIndex !== -1) {
                     // Optional: Check if the updated item is a duplicate of another item (excluding itself)
                     const exists = blacklist.some((item, index) =>
                         index !== itemIndex && // Don't compare with itself
                          normalizeName(item.name) === normalizedNewItem.name &&
                          normalizePhone(item.phone) === normalizedNewItem.phone &&
                          normalizeEmail(item.email) === normalizedNewItem.email &&
                          normalizeLocation(item.location) === normalizedNewItem.location
                     );
                     if (exists) {
                         alert("更新後的黑名單項目似乎已經與列表中其他項目重複。");
                         return; // Prevent saving duplicate
                     }


                    blacklist[itemIndex] = {
                        id: blacklist[itemIndex].id, // Keep the original unique ID
                        name: name,
                        phone: phone,
                        email: email,
                        location: location
                    };
                    alert("黑名單項目已更新。");
                } else {
                    alert("錯誤：找不到要編輯的黑名單項目。");
                }
                 // Reset form to Add mode
                 resetForm();
            } else { // Add mode
                 // Simple check for exact duplicates before adding (normalized)
                 const exists = blacklist.some(item =>
                      normalizeName(item.name) === normalizedNewItem.name &&
                      normalizePhone(item.phone) === normalizedNewItem.phone &&
                      normalizeEmail(item.email) === normalizedNewItem.email &&
                      normalizeLocation(item.location) === normalizedNewItem.location
                 );
                 if (exists) {
                     alert("這個黑名單項目似乎已經存在。");
                     // Optionally populate the form with the existing item for easier editing
                     const existingItem = blacklist.find(item =>
                         normalizeName(item.name) === normalizedNewItem.name &&
                         normalizePhone(item.phone) === normalizedNewItem.phone &&
                         normalizeEmail(item.email) === normalizedNewItem.email &&
                         normalizeLocation(item.location) === normalizedNewItem.location
                     );
                     if (existingItem) {
                         handleEditClick({ target: { dataset: { id: existingItem.id } } }); // Simulate clicking edit button
                     }
                     return;
                 }

                const newItem = {
                    id: Date.now() + Math.random(), // Generate a unique ID using timestamp + random for safety
                    name: name,
                    phone: phone,
                    email: email,
                    location: location
                };
                blacklist.push(newItem);
                alert("新的黑名單項目已加入。");
                 resetForm(); // Clear form fields
            }

            saveBlacklist();
            renderBlacklistTable();
        }

        /**
         * Handle click on Edit button in the table.
         * @param {Event} event
         */
        function handleEditClick(event) {
            const itemIdToEdit = event.target.dataset.id;
            // Find the item by its unique ID (compare as strings or numbers consistently)
            const itemToEdit = blacklist.find(item => String(item.id) === itemIdToEdit);

            if (itemToEdit) {
                // Populate form fields with item data
                nameInput.value = itemToEdit.name || '';
                phoneInput.value = itemToEdit.phone || '';
                emailInput.value = itemToEdit.email || '';
                locationInput.value = itemToEdit.location || '';
                blacklistIdInput.value = itemToEdit.id; // Store the unique ID

                // Change button text and show cancel button
                addEditButton.textContent = '儲存變更';
                addEditButton.classList.add('edit'); // Optional: change button color
                cancelEditButton.style.display = 'inline-block';

                 // Scroll to the form
                 document.getElementById('blacklist-form').scrollIntoView({ behavior: 'smooth' });

            } else {
                alert("找不到要編輯的黑名單項目。");
            }
        }

        /**
         * Handle click on Delete button in the table.
         * @param {Event} event
         */
        async function handleDeleteClick(event) {
            const itemIdToDelete = event.target.dataset.id;
            const itemToDelete = blacklist.find(item => String(item.id) === itemIdToDelete);
            const confirmMessage = itemToDelete
                ? `確定要刪除此黑名單項目嗎？\n姓名: ${itemToDelete.name || '無'}, 電話: ${itemToDelete.phone || '無'}, Email: ${itemToDelete.email || '無'}, 地點: ${itemToDelete.location || '無'}`
                : `確定要刪除此黑名單項目 (ID: ${itemIdToDelete}) 嗎？`;

            if (confirm(confirmMessage)) {
                try {
                    const response = await fetch(`/api/blacklist/${itemIdToDelete}`, {
                        method: 'DELETE'
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || '刪除失敗');
                    }

                    // 從本地blacklist陣列中移除
                    blacklist = blacklist.filter(item => String(item.id) !== itemIdToDelete);
                    
                    // 如果正在編輯的被刪除的項目，重置表單
                    if (blacklistIdInput.value === itemIdToDelete) {
                        resetForm();
                    }
                    
                    renderBlacklistTable();
                    alert("黑名單項目已刪除");
                } catch (err) {
                    console.error("Error deleting blacklist item:", err);
                    alert(`刪除失敗: ${err.message}`);
                }
            }
        }

        /**
         * Reset the Add/Edit form to its initial state (Add mode).
         */
        function resetForm() {
            nameInput.value = '';
            phoneInput.value = '';
            emailInput.value = '';
            locationInput.value = '';
            blacklistIdInput.value = ''; // Clear hidden ID

            addEditButton.textContent = '新增黑名單';
            addEditButton.classList.remove('edit');
            cancelEditButton.style.display = 'none';
        }

        /**
         * Handle click on Cancel Edit button.
         */
        function handleCancelEditClick() {
            resetForm();
        }


        // --- Tab Switching Logic ---
        function openTab(event, tabContentId) {
            // Get all tab content elements and hide them
            const tabContents = document.getElementsByClassName('tab-content');
            for (let i = 0; i < tabContents.length; i++) {
                tabContents[i].classList.remove('active');
            }

            // Get all tab buttons and remove the active class
            const tabButtons = document.getElementsByClassName('tab-button');
            for (let i = 0; i < tabButtons.length; i++) {
                tabButtons[i].classList.remove('active');
            }

            // Show the current tab, and add an "active" class to the button that opened the tab
            document.getElementById(tabContentId).classList.add('active');
            event.currentTarget.classList.add('active');

             // If switching to tab 2, render the blacklist table
             if (tabContentId === 'tab2Content') {
                 renderBlacklistTable();
             }
        }


        // --- 初始化：載入黑名單並渲染表格 ---
        document.addEventListener('DOMContentLoaded', () => {
            loadBlacklist(); // Load data first
            // Initially render tab1 content by default (already set active in HTML)
            // If you want tab2 to show first on load, change initial HTML active class
            // renderBlacklistTable(); // Render table on tab 2 initially (even if hidden) - called when tab2 is opened

            // Add event listeners for Tab 1 (Detection)
            document.getElementById('checkButton').addEventListener('click', checkOrder);

            // Add event listeners for Tab 2 (Management)
            addEditButton.addEventListener('click', handleAddEditClick);
            cancelEditButton.addEventListener('click', handleCancelEditClick);

            // Note: Edit and Delete button listeners are added dynamically in renderBlacklistTable()

            // Handle initial tab state on page load
            const initialTabButton = document.querySelector('.tab-button.active');
            const initialTabContentId = initialTabButton.getAttribute('onclick').match(/'(.+?)'/)[1];
            openTab({ currentTarget: initialTabButton }, initialTabContentId); // Manually trigger openTab for initial load

        });

    </script>
</body>
</html>