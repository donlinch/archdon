<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Food Killer - åŸå‹</title>
    <!-- å¼•å…¥ Vue.js 2 -->
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
    <style>
        body {
            font-family: 'Microsoft JhengHei', Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f7f7f7;
            touch-action: none; /* é˜²æ­¢é¡µé¢æ»‘åŠ¨ */
            overflow: hidden; /* é˜²æ­¢æ»šåŠ¨ */
            position: fixed;
            width: 100%;
            height: 100%;
            background-image: linear-gradient(to bottom, #f9f9f9, #e9e9e9); /* æ·»åŠ æ¼¸è®ŠèƒŒæ™¯ */
        }

        /* æ¸¸æˆå®¹å™¨ - ä½¿ç”¨ç§»åŠ¨ä¼˜å…ˆçš„å‚ç›´å¸ƒå±€ */
        #game-container {
            position: relative; /* æ”¹ç‚ºç›¸å°å®šä½ï¼Œè®“å­å…ƒç´ å¯ä»¥çµ•å°å®šä½ */
            height: 100vh;
            width: 100vw;
            box-sizing: border-box;
            background-color: transparent; /* ç¢ºä¿å®¹å™¨èƒŒæ™¯é€æ˜ */
            overflow: hidden; /* é˜²æ­¢å…§å®¹æº¢å‡º */
            display: flex; /* ä½¿ç”¨flexå¸ƒå±€ */
        }

        /* æ¸¸æˆä¸»è¦åŒºåŸŸ - ä½”æ“šå·¦å´ */
        .game-area {
            position: relative;
            flex: 1; /* ä½”æ“šå‰©é¤˜ç©ºé–“ */
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            background-color: transparent; /* æ”¹ç‚ºé€æ˜èƒŒæ™¯ */
        }

        /* é–‹ç™¼å€ - å³å´ä¿¡æ¯é¢æ¿ */
        .dev-panel {
            width: 250px; /* å›ºå®šå¯¬åº¦ */
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            border-left: 1px solid rgba(0, 0, 0, 0.1);
            padding: 15px;
            box-sizing: border-box;
            overflow-y: auto;
            font-size: 14px;
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.05);
        }

        .dev-panel h3 {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 16px;
            color: #333;
            border-bottom: 1px solid #ddd;
            padding-bottom: 8px;
        }

        .dev-info-box {
            background-color: rgba(240, 240, 240, 0.7);
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 15px;
        }

        .dev-info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .dev-info-label {
            font-weight: bold;
            color: #555;
        }

        .dev-info-value {
            color: #0066cc;
            font-family: monospace;
        }

        .console-output {
            background-color: #333;
            color: #00ff00;
            font-family: monospace;
            padding: 10px;
            border-radius: 4px;
            height: 150px;
            overflow-y: auto;
            margin-top: 15px;
        }

        /* å¯èª¿æ•´å¯¬åº¦çš„åˆ†éš”æ¢ */
        .resizer {
            width: 8px;
            height: 100%;
            background-color: rgba(200, 200, 200, 0.3);
            cursor: col-resize;
            transition: background-color 0.2s;
            z-index: 100;
        }

        .resizer:hover, .resizer.active {
            background-color: rgba(0, 120, 215, 0.5);
        }

        /* ç½‘æ ¼å®¹å™¨ */
        .grid-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            border: none; /* ç§»é™¤é‚Šæ¡† */
            background-color: transparent; /* ç¢ºä¿èƒŒæ™¯é€æ˜ */
            padding-bottom: 50px; /* ç‚ºåº•éƒ¨æ§åˆ¶å€ç•™å‡ºç©ºé–“ */
        }

        /* æ¸¸æˆåŒºåŸŸå®¹å™¨ - åŒ…å«ç½‘æ ¼å’Œç©å®¶ */
        .game-world-container {
            position: relative;
            width: fit-content;
            height: fit-content;
            transform: scale(0.95); /* ç¨å¾®ç¸®å°ç¶²æ ¼ï¼Œè®“æ•´é«”æ›´å”èª¿ */
        }
        
        /* ç¶²æ ¼èƒŒæ™¯ - æ·»åŠ ä¸€å€‹æŸ”å’Œçš„èƒŒæ™¯ */
        .grid-background {
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
            z-index: -1;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.05);
        }
        
        /* ç©å®¶å¯ç§»å‹•å€åŸŸé‚Šç•Œ */
        .player-boundary {
            position: absolute;
            border: 2px solid rgba(0, 255, 0, 0.6);
            box-sizing: border-box;
            border-radius: 4px;
            pointer-events: none;
            z-index: 5;
            box-shadow: 0 0 5px rgba(0, 255, 0, 0.3);
        }

        /* ç½‘æ ¼æ ·å¼ */
        .grid {
            display: grid;
            grid-gap: 1px; /* èˆ‡map-editor.htmlä¸€è‡´ */
            background-color: rgba(240, 240, 240, 0.8); /* åŠé€æ˜èƒŒæ™¯ */
            position: relative;
            transform-origin: center;
            margin: auto;
            border: 1px solid rgba(204, 204, 204, 0.5); /* åŠé€æ˜é‚Šæ¡† */
            border-radius: 8px; /* æ·»åŠ åœ“è§’ */
            overflow: hidden;
            box-sizing: border-box;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05); /* æ·»åŠ å¾®å¦™é™°å½± */
        }

        /* ç½‘æ ¼å•å…ƒæ ¼ */
        .grid-cell {
            background-color: rgba(255, 255, 255, 0.6); /* æ›´æ˜äº®çš„å–®å…ƒæ ¼ */
            border: 1px solid rgba(150, 150, 150, 0.2);
            box-sizing: border-box;
            position: relative;
            transition: background-color 0.2s ease; /* æ·»åŠ éæ¸¡æ•ˆæœ */
        }
        
        .grid-cell:hover {
            background-color: rgba(255, 255, 255, 0.8); /* æ‡¸åœæ•ˆæœ */
        }

        /* ç©å®¶è§’è‰² */
        .player {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            transform: translate(-50%, -50%);
            z-index: 10;
            transition: all 0.2s ease;
        }

        /* å¯¹è¯æ°”æ³¡ */
        .speech-bubble {
            position: absolute;
            background-color: white;
            border-radius: 15px;
            padding: 5px 10px;
            font-size: 16px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        
        .speech-bubble::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border-width: 8px;
            border-style: solid;
            border-color: white transparent transparent transparent;
        }

        /* æ§åˆ¶å™¨åŒºåŸŸ - çµ•å°å®šä½åœ¨åº•éƒ¨ */
        .controls-area {
            position: absolute;
            bottom: 30px; /* èª¿æ•´è·é›¢åº•éƒ¨çš„è·é›¢ */
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 30px;
            background-color: transparent; /* é€æ˜èƒŒæ™¯ */
            z-index: 10; /* ç¢ºä¿æ§åˆ¶å€åœ¨ä¸Šå±¤ */
        }

        /* æ§åˆ¶å€åŸŸèƒŒæ™¯ - å¯é¸çš„æŸ”å’ŒèƒŒæ™¯ */
        .controls-background {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 160px;
            background: linear-gradient(to top, rgba(0,0,0,0.05), transparent);
            z-index: 5;
            pointer-events: none; /* ç¢ºä¿ä¸æœƒå¹²æ“¾é»æ“Šäº‹ä»¶ */
        }

        /* è™šæ‹Ÿæ‘‡æ† */
        .joystick-container {
            position: relative;
            width: 120px;
            height: 120px;
            background-color: rgba(200, 200, 200, 0.15); /* é™ä½ä¸é€æ˜åº¦ */
            border-radius: 50%;
            touch-action: none;
            border: 1px dashed rgba(255, 255, 255, 0.4); /* æ·»åŠ è™›ç·šé‚Šæ¡† */
        }

        .joystick-knob {
            position: absolute;
            width: 50px;
            height: 50px;
            background-color: transparent; /* æ”¹ç‚ºé€æ˜èƒŒæ™¯ */
            border: 3px solid rgba(255, 255, 255, 0.8); /* æ·»åŠ ç™½è‰²é‚Šæ¡† */
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
            transition: transform 0.05s ease-out; /* å¹³æ»‘éæ¸¡æ•ˆæœ */
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5); /* æ·»åŠ ç™¼å…‰æ•ˆæœ */
        }
        
        /* æ·»åŠ ä¸­å¿ƒé» */
        .joystick-knob::after {
            content: '';
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        /* æ·»åŠ åå­—ç·š */
        .joystick-container::before {
            content: '';
            position: absolute;
            width: 80%;
            height: 1px;
            background-color: rgba(255, 255, 255, 0.3);
            top: 50%;
            left: 10%;
        }
        
        .joystick-container::after {
            content: '';
            position: absolute;
            width: 1px;
            height: 80%;
            background-color: rgba(255, 255, 255, 0.3);
            top: 10%;
            left: 50%;
        }

        /* æ·»åŠ ä¸€å€‹é¡å¤–çš„æŒ‡ç¤ºå™¨ï¼Œé¡¯ç¤ºæ‰‹æŒ‡æ‹–å‹•æ–¹å‘ */
        .joystick-indicator {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            z-index: 3;
            transition: opacity 0.2s ease;
        }

        /* æ“ä½œæŒ‰é’® */
        .action-button {
            width: 80px;
            height: 80px;
            background-color: rgba(255, 71, 87, 0.7); /* é™ä½ä¸é€æ˜åº¦ */
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            margin-right: 20px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.15); /* èª¿æ•´é™°å½± */
            user-select: none;
            backdrop-filter: blur(2px); /* æ·»åŠ æ¨¡ç³Šæ•ˆæœ */
            -webkit-backdrop-filter: blur(2px); /* Safari æ”¯æŒ */
        }

        .action-button:active {
            transform: scale(0.95);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            background-color: rgba(255, 71, 87, 0.9); /* æŒ‰ä¸‹æ™‚é¡è‰²æ›´æ·± */
        }
        
        /* æ·»åŠ ä¸€å€‹å¾®å¦™çš„ç»ç’ƒæ•ˆæœ */
        .glass-effect {
            background-color: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.18);
        }

        /* é›²ç«¯åŒæ­¥ç›¸é—œæ¨£å¼ */
        .cloud-sync {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px dashed #ccc;
        }
        .cloud-sync h4 {
            margin-top: 0;
            text-align: center;
            font-size: 16px;
        }
        .template-list {
            max-height: 150px;
            overflow-y: auto;
            margin: 10px 0;
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 5px;
            background-color: rgba(0,0,0,0.02);
        }
        .template-list-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .template-list-item:hover {
            background-color: #f5f5f5;
        }
        .template-list-item:last-child {
            border-bottom: none;
        }
        .template-list-item .template-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .template-list-item button {
            padding: 2px 5px;
            font-size: 12px;
            margin-left: 5px;
            cursor: pointer;
        }
        .loading-spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top-color: #09f;
            animation: spin 1s ease-in-out infinite;
            margin-right: 5px;
            vertical-align: middle;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .data-display-section {
            margin-top: 15px;
        }
        .data-display-section h4 {
             margin-bottom: 10px;
        }
        .data-list {
            max-height: 120px;
            overflow-y: auto;
            padding: 8px;
            background: rgba(0,0,0,0.03);
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
        }
        .data-list-item {
            padding: 4px;
            border-bottom: 1px solid #eee;
        }

        /* Slide-in notification styles from map-editor */
        .slide-in-notification {
            position: fixed;
            top: 20px;
            right: -350px; /* Start off-screen */
            min-width: 250px;
            padding: 15px 20px;
            background-color: #4CAF50;
            color: white;
            border-radius: 8px 0 0 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            font-size: 14px;
            z-index: 2000;
            transition: right 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        .slide-in-notification.show {
            right: 0;
        }
        .slide-in-notification.error {
            background-color: #f44336;
        }

        /* Component Library styles from map-editor */
        .component-loader, .component-library, .template-manager {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #fff;
        }
        .component-loader textarea {
            width: 100%;
            min-height: 100px;
            box-sizing: border-box;
        }
        .library-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(64px, 1fr));
            gap: 10px;
            margin-top: 10px;
            max-height: 250px;
            overflow-y: auto;
        }
        .library-item {
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 64px;
            position: relative;
            overflow: hidden;
            background: #f9f9f9;
        }
        .library-item img, .library-item canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        .library-item-name {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(0,0,0,0.5);
            color: white;
            font-size: 10px;
            padding: 2px 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            align-items: center;
            text-align: center;
        }
        .library-item-name > span {
            flex: 1;
            padding: 0 20px 0 5px;
        }
        .copy-component-button {
            background: transparent;
            border: none;
            color: white;
            cursor: pointer;
            padding: 0 5px;
            font-size: 12px;
            line-height: 1;
            position: absolute;
            right: 2px;
            top: 50%;
            transform: translateY(-50%);
        }
        .empty-state {
            font-size: 13px;
            color: #888;
            padding: 20px 5px;
            text-align: center;
            font-style: italic;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        /* --- User Status Indicator --- */
        .user-status {
            position: absolute; /* ç›¸å°æ–¼ game-area å®šä½ */
            top: 15px;
            left: 15px;
            z-index: 1001;
            display: flex;
            align-items: center;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 5px 10px;
            border-radius: 20px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .user-status:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .user-status img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #FF9800;
            object-fit: cover;
        }

        .user-status .username {
            margin-left: 8px;
            font-weight: 600;
            color: #2c3e50;
            max-width: 120px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* ç·¨è¼¯æ¨¡å¼ç›¸é—œæ¨£å¼ */
        .edit-mode-section {
            margin-bottom: 15px;
        }

        .mode-toggle-btn, .area-mode-btn {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            cursor: pointer;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #fff;
            transition: all 0.3s ease;
        }

        .mode-toggle-btn.active {
            background: #4CAF50;
            color: white;
            border-color: #388E3C;
        }

        .area-mode-btn.active {
            background: #2196F3;
            color: white;
            border-color: #1976D2;
        }

        .area-edit-panel {
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
        }

        .area-form {
            margin-top: 10px;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 4px;
        }

        .form-group {
            margin-bottom: 10px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #666;
        }

        .form-group input {
            width: 100%;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }

        .save-area-btn {
            width: 100%;
            padding: 8px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .save-area-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .area-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .area-item {
            display: flex;
            align-items: center;
            padding: 5px;
            border-bottom: 1px solid #eee;
        }

        .area-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            margin-right: 8px;
        }

        .area-name {
            flex: 1;
            font-size: 14px;
        }

        .area-actions {
            display: flex;
            gap: 5px;
        }

        .area-actions button {
            padding: 3px 8px;
            font-size: 12px;
            cursor: pointer;
        }

        /* ç¶²æ ¼å–®å…ƒæ ¼é¸æ“‡æ¨£å¼ */
        .grid-cell.selectable {
            cursor: pointer;
        }

        .grid-cell.selected {
            border: 2px solid #2196F3;
        }

        .grid-cell.area-cell {
            position: relative;
        }

        .grid-cell.area-cell::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: currentColor;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .grid-cell.area-cell.visible::before {
            opacity: 0.3;
        }

        .grid-cell.area-cell:hover::after {
            content: attr(data-areas);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
        }

        .area-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            transition: background-color 0.3s;
        }

        /* å€åŸŸæ§åˆ¶æŒ‰éˆ• */
        .area-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .visibility-toggle-btn {
            flex: 1;
            padding: 8px;
            background: #607D8B;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .visibility-toggle-btn:hover {
            background: #455A64;
        }

        /* å€åŸŸå¡ç‰‡ç¶²æ ¼å¸ƒå±€ */
        .area-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
        }

        .area-card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 10px;
            transition: transform 0.2s;
        }

        .area-card:hover {
            transform: translateY(-2px);
        }

        .area-card-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .area-color {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .area-name {
            flex: 1;
            font-size: 14px;
            font-weight: 500;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .visibility-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .visibility-btn:hover {
            opacity: 1;
        }

        .visibility-btn.visible {
            opacity: 1;
        }

        .area-card-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        .area-card-actions button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }

        .area-card-actions button:hover {
            background: rgba(0,0,0,0.05);
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Vue åº”ç”¨å°†åœ¨æ­¤æŒ‚è½½ -->
    </div>

    <script>
        new Vue({
            el: '#game-container',
            template: `
                <div id="game-container">
                    <!-- æ§åˆ¶å€åŸŸèƒŒæ™¯ - æŸ”å’Œæ¼¸è®Š -->
                    <div class="controls-background"></div>
                    
                    <div class="game-area">
                        <!-- User Status Indicator -->
                        <div id="userStatus" class="user-status">
                            <img id="userStatusAvatar" src="/images/a01girlmove.gif" alt="User">
                            <span id="userStatusName" class="username">æœªç™»å…¥</span>
                        </div>
                        <div class="grid-container">
                            <div class="game-world-container">
                                <!-- ç¶²æ ¼èƒŒæ™¯ -->
                                <div class="grid-background"></div>
                                
                                <!-- ç©å®¶å¯ç§»å‹•å€åŸŸé‚Šç•Œ -->
                                <div class="player-boundary" :style="playerBoundaryStyle"></div>
                                
                                <div class="grid" :style="gridContainerStyle" @mousemove="handleGridMouseMove">
                                    <div
                                        v-for="(cell, index) in gridCells"
                                        :key="index"
                                        class="grid-cell"
                                        :class="getCellClasses(index)"
                                        :style="{ width: cellSize + 'px', height: cellSize + 'px' }"
                                        :data-areas="getCellAreasText(index)"
                                        @click="handleCellClick(index)"
                                        @mousedown="startCellSelection(index)"
                                        @mouseover="handleCellHover(index)"
                                    >
                                        <template v-if="getCellAreas(index).length > 0">
                                            <div
                                                v-for="(area, areaIndex) in getCellAreas(index).filter(a => a.visible)"
                                                :key="'area-' + area.id + '-' + index"
                                                class="area-overlay"
                                                :style="{ 
                                                    backgroundColor: addOpacity(area.color, getCellAreas(index).filter(a => a.visible).length > 1 ? 0.3 : 0.5),
                                                    zIndex: 2 + areaIndex
                                                }"
                                            ></div>
                                        </template>
                                    </div>
                                </div>
                                <div class="player" :style="playerStyle">
                                    {{ playerEmoji }}
                                    <div class="speech-bubble" :style="bubbleStyle">{{ bubbleText }}</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- æ§åˆ¶å€åŸŸ - çµ•å°å®šä½åœ¨åº•éƒ¨ -->
                        <div class="controls-area" ref="controlsArea">
                            <!-- è™šæ‹Ÿæ‘‡æ† -->
                            <div 
                                class="joystick-container glass-effect" 
                                ref="joystickContainer"
                                @touchstart="startJoystick"
                                @mousedown="startJoystick"
                            >
                                <div class="joystick-knob" ref="joystickKnob"></div>
                                <div class="joystick-indicator" ref="joystickIndicator"></div>
                            </div>
                            
                            <!-- æ“ä½œæŒ‰é’® -->
                            <div 
                                class="action-button glass-effect"
                                @touchstart="activateActionButton"
                                @mousedown="activateActionButton"
                            >
                                ğŸ”ª
                            </div>
                        </div>
                    </div>
                    
                    <!-- å¯èª¿æ•´å¯¬åº¦çš„åˆ†éš”æ¢ -->
                    <div class="resizer" ref="resizer" @mousedown="startResize"></div>
                    
                    <!-- é–‹ç™¼å€é¢æ¿ -->
                    <div class="dev-panel" ref="devPanel">
                        <h3>é–‹ç™¼å€</h3>
                        
                        <!-- ç·¨è¼¯æ¨¡å¼é–‹é—œ -->
                        <div class="edit-mode-section">
                            <button 
                                class="mode-toggle-btn"
                                :class="{ active: isEditMode }"
                                @click="toggleEditMode"
                            >
                                {{ isEditMode ? 'é—œé–‰ç·¨è¼¯' : 'é–‹å•Ÿç·¨è¼¯' }}
                            </button>
                        </div>

                        <!-- å€åŸŸç·¨è¼¯é¢æ¿ (åƒ…åœ¨ç·¨è¼¯æ¨¡å¼ä¸‹é¡¯ç¤º) -->
                        <div v-if="isEditMode" class="area-edit-panel">
                            <h4>å€åŸŸç·¨è¼¯</h4>
                            <div class="area-controls">
                                <button 
                                    class="area-mode-btn"
                                    :class="{ active: isAreaSelectMode }"
                                    @click="toggleAreaSelectMode"
                                    :disabled="!isEditMode"
                                >
                                    {{ isAreaSelectMode ? 'å–æ¶ˆé¸æ“‡' : 'æ–°å¢å€åŸŸ' }}
                                </button>
                                <button 
                                    class="visibility-toggle-btn"
                                    @click="toggleAllAreasVisibility"
                                >
                                    {{ allAreasVisible ? 'å…¨éƒ¨éš±è—' : 'å…¨éƒ¨é¡¯ç¤º' }}
                                </button>
                            </div>

                            <!-- å€åŸŸè¡¨å–® (åƒ…åœ¨æœ‰é¸æ“‡çš„å–®å…ƒæ ¼æ™‚é¡¯ç¤º) -->
                            <div v-if="selectedCells.length > 0" class="area-form">
                                <div class="form-group">
                                    <label>å€åŸŸåç¨±</label>
                                    <input type="text" v-model="newArea.name" placeholder="è¼¸å…¥å€åŸŸåç¨±">
                                </div>
                                <div class="form-group">
                                    <label>å€åŸŸé¡è‰²</label>
                                    <input type="color" v-model="newArea.color">
                                </div>
                                <button 
                                    class="save-area-btn"
                                    @click="saveArea"
                                    :disabled="!newArea.name"
                                >
                                    å„²å­˜å€åŸŸ
                                </button>
                            </div>

                            <!-- å·²å„²å­˜å€åŸŸåˆ—è¡¨ -->
                            <div class="saved-areas">
                                <h4>å·²å„²å­˜å€åŸŸ</h4>
                                <div class="area-grid">
                                    <div v-for="area in areas" :key="area.id" class="area-card">
                                        <div class="area-card-header">
                                            <div class="area-color" :style="{ backgroundColor: area.color }"></div>
                                            <div class="area-name">{{ area.name }}</div>
                                            <button 
                                                class="visibility-btn"
                                                :class="{ 'visible': area.visible }"
                                                @click="toggleAreaVisibility(area)"
                                            >
                                                <span v-if="area.visible">ğŸ‘ï¸</span>
                                                <span v-else>ğŸ‘ï¸â€ğŸ—¨ï¸</span>
                                            </button>
                                        </div>
                                        <div class="area-card-actions">
                                            <button @click="editArea(area)" title="ç·¨è¼¯å€åŸŸ">âœï¸</button>
                                            <button @click="deleteArea(area)" title="åˆªé™¤å€åŸŸ">ğŸ—‘ï¸</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- åŸæœ‰çš„ç©å®¶åº§æ¨™ä¿¡æ¯ç­‰å…§å®¹ -->
                        <div class="dev-info-box">
                            <h4>ç©å®¶åº§æ¨™</h4>
                            <div class="dev-info-row">
                                <span class="dev-info-label">X:</span>
                                <span class="dev-info-value">{{ playerPosition.x.toFixed(2) }}</span>
                            </div>
                            <div class="dev-info-row">
                                <span class="dev-info-label">Y:</span>
                                <span class="dev-info-value">{{ playerPosition.y.toFixed(2) }}</span>
                            </div>
                            <div class="dev-info-row">
                                <span class="dev-info-label">åƒç´  X:</span>
                                <span class="dev-info-value">{{ playerPixelPosition.x }}</span>
                            </div>
                            <div class="dev-info-row">
                                <span class="dev-info-label">åƒç´  Y:</span>
                                <span class="dev-info-value">{{ playerPixelPosition.y }}</span>
                            </div>
                        </div>
                        
                        <!-- ç¶²æ ¼ä½ç½®ä¿¡æ¯ -->
                        <div class="dev-info-box">
                            <h4>ç¶²æ ¼ä½ç½®</h4>
                            <div class="dev-info-row">
                                <span class="dev-info-label">åˆ—:</span>
                                <span class="dev-info-value">{{ hoverCell.col }}</span>
                            </div>
                            <div class="dev-info-row">
                                <span class="dev-info-label">è¡Œ:</span>
                                <span class="dev-info-value">{{ hoverCell.row }}</span>
                            </div>
                            <div class="dev-info-row">
                                <span class="dev-info-label">ç´¢å¼•:</span>
                                <span class="dev-info-value">{{ hoverCell.index }}</span>
                            </div>
                        </div>
                        
                        <!-- æ§åˆ¶å°è¼¸å‡º -->
                        <h4>Console:</h4>
                        <div class="console-output" ref="consoleOutput">
                            <div v-for="(log, index) in consoleLogs" :key="index">{{ log }}</div>
                        </div>

                        <!-- é›²ç«¯è³‡æ–™åŒæ­¥ -->
                        <div class="cloud-sync">
                            <h4>åœ°åœ–è³‡æ–™è¼‰å…¥</h4>
                            <button @click="loadTemplatesFromDatabase" style="width:100%; padding: 8px; cursor: pointer;">
                                <span v-if="isLoading.load" class="loading-spinner"></span>
                                å¾è³‡æ–™åº«é‡è¼‰åˆ—è¡¨
                            </button>
                            
                            <div v-if="dbTemplates.length > 0" class="template-list">
                                <div v-for="template in dbTemplates" :key="template.id" class="template-list-item">
                                    <div class="template-name" :title="template.name">{{ template.name }}</div>
                                    <button @click="loadTemplateFromDatabase(template.id)">è¼‰å…¥</button>
                                </div>
                            </div>
                             <div v-else-if="dbTemplatesLoaded" style="text-align: center; padding: 10px; font-size: 12px; color: #888;">
                                è³‡æ–™åº«ä¸­å°šç„¡æ¨¡æ¿ã€‚
                            </div>
                        </div>

                        <!-- å·²è¼‰å…¥è³‡æ–™é¡¯ç¤º -->
                        <div v-if="loadedMapData.name" class="data-display-section">
                            <h4>å·²è¼‰å…¥: {{ loadedMapData.name }}</h4>
                            
                            <!-- é¡¯ç¤ºå€åŸŸè³‡æ–™ -->
                            <div class="data-display-section">
                                <h5>å€åŸŸ ({{ loadedMapData.areas.length }})</h5>
                                <div class="data-list">
                                    <div v-for="area in loadedMapData.areas" :key="area.id" class="data-list-item">
                                        {{ area.name }} ({{ area.cells.length }}æ ¼)
                                    </div>
                                    <div v-if="loadedMapData.areas.length === 0" style="color: #888;">ç„¡å€åŸŸè³‡æ–™</div>
                                </div>
                            </div>

                            <!-- é¡¯ç¤ºå…ƒä»¶è³‡æ–™ -->
                             <div class="data-display-section">
                                <h5>å…ƒä»¶ ({{ loadedMapData.components.length }})</h5>
                                <div class="data-list">
                                    <div v-for="comp in loadedMapData.components" :key="comp.id" class="data-list-item">
                                        ID: {{ comp.component_id }} @ ({{ comp.grid_x }}, {{ comp.grid_y }})
                                    </div>
                                     <div v-if="loadedMapData.components.length === 0" style="color: #888;">ç„¡å…ƒä»¶è³‡æ–™</div>
                                </div>
                            </div>
                        </div>

                        <!-- Template Manager -->
                        <div class="template-manager">
                            <h4>æ¨¡æ¿ç®¡ç† (é›²ç«¯)</h4>
                            <div class="form-group">
                                <label>æ¨¡æ¿åç¨±</label>
                                <input type="text" v-model="currentTemplateName" placeholder="æ–°æ¨¡æ¿åç¨±æˆ–é¸æ“‡ä¸‹æ–¹æ¨¡æ¿" style="width: 100%; padding: 5px; box-sizing: border-box;">
                            </div>
                            <div style="display: flex; gap: 5px; margin-top: 10px;">
                                <button @click="saveTemplateToDatabase" :disabled="!currentTemplateName" style="flex:1; cursor:pointer;">ä¿å­˜/æ›´æ–°</button>
                                <button @click="deleteTemplateFromDatabase" :disabled="!selectedTemplateId" style="flex:1; cursor:pointer;">åˆªé™¤é¸å–</button>
                                <button @click="createNewScene" style="flex:1; cursor:pointer;">æ–°å ´æ™¯</button>
                            </div>
                        </div>

                        <!-- Cloud Sync (Load Area) -->
                        <div class="cloud-sync">
                             <button @click="loadTemplatesFromDatabase" style="width:100%; padding: 8px; cursor: pointer;">
                                <span v-if="isLoading.load" class="loading-spinner"></span>
                                å¾è³‡æ–™åº«é‡è¼‰åˆ—è¡¨
                            </button>
                            <div v-if="dbTemplates.length > 0" class="template-list">
                                <div v-for="template in dbTemplates" :key="template.id" class="template-list-item" @click="selectTemplateForEditing(template)">
                                    <div class="template-name" :title="template.name" :style="{ fontWeight: template.id === selectedTemplateId ? 'bold' : 'normal' }">{{ template.name }}</div>
                                </div>
                            </div>
                             <div v-else-if="dbTemplatesLoaded" class="empty-state">è³‡æ–™åº«ä¸­å°šç„¡æ¨¡æ¿ã€‚</div>
                        </div>

                        <!-- Component Loader -->
                        <div class="component-loader">
                            <h4>å…ƒä»¶è¼‰å…¥å™¨</h4>
                            <textarea v-model="componentJsonInput" rows="5" placeholder="åœ¨æ­¤è²¼ä¸Šå…ƒä»¶ JSON" style="width: 100%; box-sizing: border-box;"></textarea>
                            <button @click="loadComponentFromJson" style="width: 100%; margin-top: 5px; cursor: pointer;">åŠ å…¥å…ƒä»¶</button>
                        </div>
                        
                        <!-- Component Library -->
                        <div class="component-library">
                            <h4>å…ƒä»¶åº« ({{ loadedComponents.length }})</h4>
                            <div class="library-grid" v-if="loadedComponents.length > 0">
                                <div v-for="component in loadedComponents" :key="component.id" class="library-item">
                                    <img v-if="component.type === 'static' && component.fileType === 'gif'" :src="getSmartImageUrl(component.spritesheetUrl)" :alt="component.name">
                                    <img v-else-if="component.type === 'static' && component.imageData" :src="component.imageData" :alt="component.name">
                                    <canvas v-if="component.type === 'animation'" :ref="'anim-canvas-' + component.id" :width="component.width" :height="component.height"></canvas>
                                    <div class="library-item-name">
                                        <span>{{ component.name }}</span>
                                        <button class="copy-component-button" @click.stop="copyComponentInfo(component)" title="è¤‡è£½å…ƒä»¶è³‡è¨Š">ğŸ“‹</button>
                                    </div>
                                </div>
                            </div>
                             <div v-else class="empty-state">ç„¡å…ƒä»¶è³‡æ–™ã€‚</div>
                        </div>
                    </div>

                    <!-- Notification -->
                    <div class="slide-in-notification" :class="{ show: notification.show, error: !notification.success }">
                        {{ notification.message }}
                    </div>
                </div>
            `,
            data() {
                return {
                    // ç½‘æ ¼é…ç½®
                    gridCols: 10,
                    gridRows: 20,  // å¾24è¡Œæ”¹ç‚º20è¡Œ
                    cellSize: 32,  // èˆ‡map-editor.htmlä¿æŒä¸€è‡´
                    
                    // ç©å®¶ç›¸å…³
                    playerPosition: {
                        x: 5, // ç½‘æ ¼åæ ‡x
                        y: 7  // ç½‘æ ¼åæ ‡y
                    },
                    playerEmoji: 'ğŸ§‘â€ğŸ³',
                    
                    // å¯¹è¯æ°”æ³¡
                    bubbleText: '',
                    showBubble: false,
                    bubbleTimer: null,
                    
                    // æ‘‡æ†çŠ¶æ€
                    joystickActive: false,
                    joystickData: {
                        centerX: 0,
                        centerY: 0,
                        knobX: 0,
                        knobY: 0,
                        containerRadius: 0,
                        knobRadius: 0,
                        touchStartX: 0, // è¨˜éŒ„è§¸æ‘¸é–‹å§‹çš„ä½ç½®
                        touchStartY: 0
                    },
                    moveDirection: {
                        x: 0,
                        y: 0
                    },
                    // æ¸¸æˆå¾ªç¯
                    gameLoopId: null,
                    lastTimestamp: 0,
                    moveSpeed: 5, // æ¯ç§’ç§»åŠ¨çš„æ ¼å­æ•°
                    
                    // é–‹ç™¼å€æ•¸æ“š
                    hoverCell: {
                        row: 0,
                        col: 0,
                        index: 0
                    },
                    consoleLogs: ['éŠæˆ²åˆå§‹åŒ–...', 'ç©å®¶å·²ç”Ÿæˆåœ¨ä½ç½® (5, 7)'],
                    
                    // åˆ†éš”æ¢ç›¸é—œæ•¸æ“š
                    resizing: false,
                    initialX: 0,
                    initialDevPanelWidth: 250,

                    // åœ°åœ–è³‡æ–™è¼‰å…¥
                    dbTemplates: [],
                    dbTemplatesLoaded: false,
                    isLoading: {
                        load: false
                    },
                    loadedMapData: {
                        name: '',
                        areas: [],
                        components: []
                    },

                    // --- Integrated from map-editor ---
                    // Template Management
                    currentTemplateName: '',
                    selectedTemplateId: null,

                    // Area and Component Data
                    areas: [], // å€åŸŸæ•¸çµ„ï¼Œæ¯å€‹å€åŸŸéƒ½æœ‰ visible å±¬æ€§
                    loadedComponents: [], // This will hold component data

                    // Component Library
                    componentJsonInput: '',
                    animationStates: {},
                    spritesheetCache: {},

                    // Notification
                    notification: { show: false, message: '', success: true, timer: null },

                    // ç·¨è¼¯æ¨¡å¼ç›¸é—œæ•¸æ“š
                    isEditMode: false,
                    isAreaSelectMode: false,
                    selectedCells: [], // ç”¨æ–¼å„²å­˜é¸æ“‡çš„å–®å…ƒæ ¼ç´¢å¼•
                    selectionStart: null, // ç”¨æ–¼è¨˜éŒ„é¸æ“‡é–‹å§‹çš„å–®å…ƒæ ¼ç´¢å¼•
                    isSelecting: false, // æ˜¯å¦æ­£åœ¨é€²è¡Œé¸æ“‡
                    newArea: {
                        name: '',
                        color: '#FF0000' // é è¨­é¡è‰²
                    },
                    editingAreaId: null, // æ­£åœ¨ç·¨è¼¯çš„å€åŸŸ ID
                };
            },
            computed: {
                gridCells() {
                    return Array(this.gridCols * this.gridRows).fill(null);
                },
                gridContainerStyle() {
                    const gap = 1;  // èˆ‡map-editor.htmlä¸€è‡´çš„é–“éš™
                    const cellSize = this.cellSize; // å–®å…ƒæ ¼å¤§å°
                    const width = this.gridCols * cellSize + (this.gridCols - 1) * gap;
                    const height = this.gridRows * cellSize + (this.gridRows - 1) * gap;
                    return {
                        gridTemplateColumns: `repeat(${this.gridCols}, ${cellSize}px)`,
                        gridTemplateRows: `repeat(${this.gridRows}, ${cellSize}px)`,
                        width: `${width}px`,
                        height: `${height}px`,
                        gridGap: `${gap}px`
                    };
                },
                gridCellStyle() {
                    return {
                        width: `${this.cellSize}px`,
                        height: `${this.cellSize}px`
                    };
                },
                playerStyle() {
                    // è¨ˆç®—ç©å®¶åœ¨å±å¹•ä¸Šçš„åƒç´ ä½ç½®
                    // ä½¿ç”¨èˆ‡map-editor.htmlä¸€è‡´çš„è¨ˆç®—æ–¹å¼
                    const cellSize = this.cellSize;
                    const gap = 1;
                    
                    // è€ƒæ…®é‚Šç•Œè¨ˆç®—ï¼šæœ€å·¦é‚Šç¶²æ ¼çš„å·¦é‚Šæ˜¯é‚Šç•Œï¼Œå³é‚Šç¶²æ ¼çš„å³é‚Šæ˜¯é‚Šç•Œ
                    // è¨ˆç®—ä¸­å¿ƒé»ä½ç½®
                    const x = (this.playerPosition.x * (cellSize + gap)) + (cellSize / 2);
                    const y = (this.playerPosition.y * (cellSize + gap)) + (cellSize / 2);
                    
                    return {
                        left: `${x}px`,
                        top: `${y}px`
                    };
                },
                playerBoundaryStyle() {
                    // è¨ˆç®—ç©å®¶å¯ç§»å‹•å€åŸŸçš„é‚Šç•Œ
                    const gap = 1;  // ç¶²æ ¼é–“éš™
                    const cellSize = this.cellSize; // å–®å…ƒæ ¼å¤§å°
                    
                    // è¨ˆç®—é‚Šç•Œçš„å·¦ä¸Šè§’ä½ç½®ï¼ˆç¬¬ä¸€å€‹å–®å…ƒæ ¼çš„å·¦ä¸Šè§’ï¼‰
                    const left = 0;
                    const top = 0;
                    
                    // è¨ˆç®—é‚Šç•Œçš„å¯¬åº¦å’Œé«˜åº¦ï¼ˆæ•´å€‹ç¶²æ ¼çš„å¤§å°ï¼‰
                    const width = this.gridCols * cellSize + (this.gridCols - 1) * gap;
                    const height = this.gridRows * cellSize + (this.gridRows - 1) * gap;
                    
                    return {
                        left: `${left}px`,
                        top: `${top}px`,
                        width: `${width}px`,
                        height: `${height}px`
                    };
                },
                bubbleStyle() {
                    return {
                        opacity: this.showBubble ? 1 : 0
                    };
                },
                playerPixelPosition() {
                    // è¨ˆç®—ç©å®¶åœ¨å±å¹•ä¸Šçš„åƒç´ ä½ç½®
                    const cellSize = this.cellSize;
                    const gap = 1;
                    
                    const x = Math.round((this.playerPosition.x * (cellSize + gap)) + (cellSize / 2));
                    const y = Math.round((this.playerPosition.y * (cellSize + gap)) + (cellSize / 2));
                    
                    return { x, y };
                },
                // ç²å–å–®å…ƒæ ¼çš„æ¨£å¼
                getCellStyle() {
                    return (index) => {
                        const style = {
                            width: `${this.cellSize}px`,
                            height: `${this.cellSize}px`
                        };
                        return style;
                    };
                },
                allAreasVisible() {
                    return this.areas.length > 0 && this.areas.every(area => area.visible);
                }
            },
            mounted() {
                // åˆå§‹åŒ–è™šæ‹Ÿæ‘‡æ†ä¸­å¿ƒä½ç½®
                this.initJoystick();
                
                // å¯åŠ¨æ¸¸æˆå¾ªç¯
                this.startGameLoop();
                
                // é˜²æ­¢é¡µé¢ä¸Šæ‹‰ä¸‹æ‹‰åˆ·æ–°
                document.body.addEventListener('touchmove', function(e) {
                    e.preventDefault();
                }, { passive: false });
                
                // åˆå§‹åŒ–æ™‚ç¢ºä¿ç©å®¶åœ¨ç¶²æ ¼ç¯„åœå…§
                this.constrainPlayerToGrid();
                
                // æ·»åŠ çª—å£å¤§å°è®ŠåŒ–ç›£è½
                window.addEventListener('resize', this.handleResize);
                
                // æ·»åŠ å…¨å±€è§¸æ§äº‹ä»¶è™•ç†
                document.addEventListener('touchmove', this.handleGlobalTouchMove, { passive: false });
                document.addEventListener('touchend', this.handleGlobalTouchEnd);
                document.addEventListener('touchcancel', this.handleGlobalTouchEnd);
                
                // æ·»åŠ å…¨å±€é¼ æ¨™äº‹ä»¶è™•ç† (ç”¨æ–¼åˆ†éš”æ¢èª¿æ•´)
                document.addEventListener('mousemove', this.handleMouseMove);
                document.addEventListener('mouseup', this.handleMouseUp);

                // è¼‰å…¥è³‡æ–™åº«æ¨¡æ¿åˆ—è¡¨
                this.loadTemplatesFromDatabase();
                
                // Start animation loop for component library
                this.mainAnimationLoop();
            },
            beforeDestroy() {
                // æ¸…é™¤æ¸¸æˆå¾ªç¯
                if (this.gameLoopId) {
                    cancelAnimationFrame(this.gameLoopId);
                }
                
                // æ¸…é™¤å¯¹è¯æ°”æ³¡å®šæ—¶å™¨
                if (this.bubbleTimer) {
                    clearTimeout(this.bubbleTimer);
                }
                
                // ç§»é™¤çª—å£å¤§å°è®ŠåŒ–ç›£è½
                window.removeEventListener('resize', this.handleResize);
                
                // ç§»é™¤å…¨å±€è§¸æ§äº‹ä»¶è™•ç†
                document.removeEventListener('touchmove', this.handleGlobalTouchMove);
                document.removeEventListener('touchend', this.handleGlobalTouchEnd);
                document.removeEventListener('touchcancel', this.handleGlobalTouchEnd);
                
                // ç§»é™¤å…¨å±€é¼ æ¨™äº‹ä»¶è™•ç† (ç”¨æ–¼åˆ†éš”æ¢èª¿æ•´)
                document.removeEventListener('mousemove', this.handleMouseMove);
                document.removeEventListener('mouseup', this.handleMouseUp);

                if (this.animationLoopId) cancelAnimationFrame(this.animationLoopId);
            },
            methods: {
                // è™•ç†å…¨å±€è§¸æ§ç§»å‹•
                handleGlobalTouchMove(event) {
                    if (this.joystickActive) {
                        this.moveJoystick(event);
                    }
                },
                
                // è™•ç†å…¨å±€è§¸æ§çµæŸ
                handleGlobalTouchEnd(event) {
                    if (this.joystickActive) {
                        this.endJoystick(event);
                    }
                },
                // è™•ç†çª—å£å¤§å°è®ŠåŒ–
                handleResize() {
                    // é‡æ–°åˆå§‹åŒ–æ–æ¡¿
                    this.initJoystick();
                    
                    // ç¢ºä¿ç©å®¶åœ¨ç¶²æ ¼ç¯„åœå…§
                    this.constrainPlayerToGrid();
                },
                // åˆå§‹åŒ–æ‘‡æ†
                initJoystick() {
                    const container = this.$refs.joystickContainer;
                    if (!container) return;
                    
                    const rect = container.getBoundingClientRect();
                    const knobElem = this.$refs.joystickKnob;
                    if (!knobElem) return;
                    
                    const knobRect = knobElem.getBoundingClientRect();
                    
                    this.joystickData.centerX = rect.width / 2;
                    this.joystickData.centerY = rect.height / 2;
                    this.joystickData.containerRadius = rect.width / 2;
                    this.joystickData.knobRadius = knobRect.width / 2;
                    
                    this.resetJoystick();
                },
                
                // é‡ç½®æ‘‡æ†ä½ç½®
                resetJoystick() {
                    this.joystickData.knobX = this.joystickData.centerX;
                    this.joystickData.knobY = this.joystickData.centerY;
                    if (this.$refs.joystickKnob) {
                        this.$refs.joystickKnob.style.left = `${this.joystickData.centerX}px`;
                        this.$refs.joystickKnob.style.top = `${this.joystickData.centerY}px`;
                    }
                    // é‡ç½®ç§»åŠ¨æ–¹å‘
                    this.moveDirection = { x: 0, y: 0 };
                },
                
                // å¼€å§‹æ“ä½œæ‘‡æ†
                startJoystick(event) {
                    event.preventDefault();
                    this.joystickActive = true;
                    
                    // ç²å–æ–æ¡¿å®¹å™¨ä½ç½®
                    const container = this.$refs.joystickContainer;
                    const rect = container.getBoundingClientRect();
                    
                    // è¨˜éŒ„è§¸æ‘¸é–‹å§‹çš„ä½ç½®
                    if (event.type === 'touchstart') {
                        const touch = event.touches[0];
                        this.joystickData.touchStartX = touch.clientX;
                        this.joystickData.touchStartY = touch.clientY;
                        
                        // ç«‹å³ç§»å‹•æ–æ¡¿åˆ°è§¸æ‘¸ä½ç½®
                        this.moveJoystick(event);
                    } else {
                        // é¼ æ ‡äº‹ä»¶
                        this.joystickData.touchStartX = event.clientX;
                        this.joystickData.touchStartY = event.clientY;
                        
                        // ç«‹å³ç§»å‹•æ–æ¡¿åˆ°é¼ æ¨™ä½ç½®
                        this.moveJoystick(event);
                        
                        // æ·»åŠ å…¨å±€é¼ æ¨™äº‹ä»¶ç›£è½
                        window.addEventListener('mousemove', this.moveJoystick);
                        window.addEventListener('mouseup', this.endJoystick);
                    }
                },
                
                // ç§»åŠ¨æ‘‡æ†
                moveJoystick(event) {
                    if (!this.joystickActive) return;
                    
                    event.preventDefault();
                    const container = this.$refs.joystickContainer;
                    const rect = container.getBoundingClientRect();
                    
                    // è·å–è§¦æ‘¸æˆ–é¼ æ ‡ä½ç½®
                    let clientX, clientY;
                    if (event.type.startsWith('touch')) {
                        clientX = event.touches[0].clientX;
                        clientY = event.touches[0].clientY;
                    } else {
                        clientX = event.clientX;
                        clientY = event.clientY;
                    }
                    
                    // è¨ˆç®—ç›¸å°æ–¼æ–æ¡¿å®¹å™¨çš„åæ¨™
                    let relativeX = clientX - rect.left;
                    let relativeY = clientY - rect.top;
                    
                    // è¨ˆç®—å¾ä¸­å¿ƒé»çš„è·é›¢å’Œè§’åº¦
                    const deltaX = relativeX - this.joystickData.centerX;
                    const deltaY = relativeY - this.joystickData.centerY;
                    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                    const angle = Math.atan2(deltaY, deltaX);
                    
                    // é™åˆ¶æ–æ¡¿åœ¨å®¹å™¨å…§çš„é¡¯ç¤º
                    const maxKnobDistance = this.joystickData.containerRadius - this.joystickData.knobRadius;
                    let knobX, knobY;
                    
                    if (distance <= maxKnobDistance) {
                        // å¦‚æœåœ¨å®¹å™¨ç¯„åœå…§ï¼Œç›´æ¥ä½¿ç”¨è¨ˆç®—çš„ä½ç½®
                        knobX = relativeX;
                        knobY = relativeY;
                    } else {
                        // å¦‚æœè¶…å‡ºç¯„åœï¼Œé™åˆ¶æ–æ¡¿é¡¯ç¤ºåœ¨å®¹å™¨é‚Šç·£
                        knobX = this.joystickData.centerX + Math.cos(angle) * maxKnobDistance;
                        knobY = this.joystickData.centerY + Math.sin(angle) * maxKnobDistance;
                        
                        // é¡¯ç¤ºæ–¹å‘æŒ‡ç¤ºå™¨ï¼ˆå¯é¸ï¼‰
                        this.showDirectionIndicator(clientX, clientY, angle);
                    }
                    
                    // æ›´æ–°æ–æ¡¿ä½ç½®
                    this.joystickData.knobX = knobX;
                    this.joystickData.knobY = knobY;
                    if (this.$refs.joystickKnob) {
                        this.$refs.joystickKnob.style.left = `${knobX}px`;
                        this.$refs.joystickKnob.style.top = `${knobY}px`;
                    }
                    
                    // è¨ˆç®—ç§»å‹•æ–¹å‘ - ç„¡è«–æ‰‹æŒ‡æ˜¯å¦è¶…å‡ºå®¹å™¨ï¼Œéƒ½ä½¿ç”¨å¯¦éš›æ–¹å‘
                    const normalizedDeltaX = deltaX / (this.joystickData.containerRadius);
                    const normalizedDeltaY = deltaY / (this.joystickData.containerRadius);
                    
                    // è¨ˆç®—ç§»å‹•æ–¹å‘çš„å¼·åº¦ (0-1ä¹‹é–“)
                    // å¦‚æœè¶…å‡ºå®¹å™¨ç¯„åœï¼Œå¼·åº¦å§‹çµ‚ç‚º1ï¼ˆæœ€å¤§é€Ÿåº¦ï¼‰
                    const directionMagnitude = distance > this.joystickData.containerRadius ? 
                                              1 : distance / this.joystickData.containerRadius;
                    
                    // æ‡‰ç”¨æ­»å€
                    const deadzone = 0.1;
                    if (directionMagnitude > deadzone) {
                        // è¨ˆç®—æœ€çµ‚çš„ç§»å‹•æ–¹å‘ï¼Œè€ƒæ…®è§’åº¦å’Œå¼·åº¦
                        this.moveDirection.x = normalizedDeltaX * (directionMagnitude / 1);
                        this.moveDirection.y = normalizedDeltaY * (directionMagnitude / 1);
                    } else {
                        this.moveDirection = { x: 0, y: 0 };
                    }
                },
                
                // é¡¯ç¤ºæ–¹å‘æŒ‡ç¤ºå™¨ï¼ˆå¯é¸åŠŸèƒ½ï¼‰
                showDirectionIndicator(clientX, clientY, angle) {
                    const indicator = this.$refs.joystickIndicator;
                    if (!indicator) return;
                    
                    // è¨­ç½®æŒ‡ç¤ºå™¨ä½ç½®
                    indicator.style.left = `${clientX - this.$refs.controlsArea.getBoundingClientRect().left}px`;
                    indicator.style.top = `${clientY - this.$refs.controlsArea.getBoundingClientRect().top}px`;
                    indicator.style.opacity = '1';
                    
                    // 3ç§’å¾Œéš±è—æŒ‡ç¤ºå™¨
                    setTimeout(() => {
                        indicator.style.opacity = '0';
                    }, 3000);
                },
                
                // ç»“æŸæ‘‡æ†æ“ä½œ
                endJoystick(event) {
                    if (event) {
                        event.preventDefault();
                    }
                    this.joystickActive = false;
                    this.resetJoystick();
                    
                    // éš±è—æ–¹å‘æŒ‡ç¤ºå™¨
                    const indicator = this.$refs.joystickIndicator;
                    if (indicator) {
                        indicator.style.opacity = '0';
                    }
                    
                    // ç§»é™¤é¼ æ ‡äº‹ä»¶ç›‘å¬å™¨
                    window.removeEventListener('mousemove', this.moveJoystick);
                    window.removeEventListener('mouseup', this.endJoystick);
                },
                
                // æ¿€æ´»åŠ¨ä½œæŒ‰é’®
                activateActionButton(event) {
                    event.preventDefault();
                    this.showSpeechBubble('ğŸ”ª');
                },
                
                // æ˜¾ç¤ºå¯¹è¯æ°”æ³¡
                showSpeechBubble(text, duration = 2000) {
                    // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
                    if (this.bubbleTimer) {
                        clearTimeout(this.bubbleTimer);
                    }
                    
                    // è®¾ç½®æ°”æ³¡æ–‡æœ¬å¹¶æ˜¾ç¤º
                    this.bubbleText = text;
                    this.showBubble = true;
                    
                    // è®¾ç½®è‡ªåŠ¨éšè—å®šæ—¶å™¨
                    this.bubbleTimer = setTimeout(() => {
                        this.showBubble = false;
                    }, duration);
                },
                
                // ç§»åŠ¨ç©å®¶
                movePlayer(deltaTime) {
                    if (this.moveDirection.x === 0 && this.moveDirection.y === 0) return;
                    
                    // è®¡ç®—è¿™ä¸€å¸§è¦ç§»åŠ¨çš„è·ç¦»
                    const moveAmount = this.moveSpeed * (deltaTime / 1000);
                    
                    // å‚¨å­˜åŸå§‹ä½ç½®ä»¥ä¾¿éœ€è¦æ—¶å›é€€
                    const originalPosition = {
                        x: this.playerPosition.x,
                        y: this.playerPosition.y
                    };
                    
                    // åŒæ™‚è™•ç†æ°´å¹³å’Œå‚ç›´ç§»å‹•ï¼Œå¯¦ç¾æ–œå‘ç§»å‹•
                    const newX = this.playerPosition.x + this.moveDirection.x * moveAmount;
                    const newY = this.playerPosition.y + this.moveDirection.y * moveAmount;
                    
                    // ä¿®æ­£é‚Šç•Œæª¢æŸ¥é‚è¼¯ï¼Œè€ƒæ…®ç¶²æ ¼å–®å…ƒæ ¼å¤§å°å’Œé–“éš™
                    const cellSize = this.cellSize;
                    const gap = 1; // ç¶²æ ¼é–“éš™
                    
                    // è¨ˆç®—å¯¦éš›çš„é‚Šç•Œå€¼ï¼ˆè€ƒæ…®åˆ°ç©å®¶æ˜¯ä¸­å¿ƒé»å®šä½ï¼‰
                    const minX = 0;
                    const maxX = this.gridCols - 1;
                    const minY = 0;
                    const maxY = this.gridRows - 1;
                    
                    // åˆ†åˆ¥è™•ç†Xå’ŒYåæ¨™ï¼Œç¢ºä¿ä¸è¶…å‡ºé‚Šç•Œ
                    if (newX >= minX && newX <= maxX) {
                        this.playerPosition.x = newX;
                    } else if (newX < minX) {
                        this.playerPosition.x = minX;
                    } else if (newX > maxX) {
                        this.playerPosition.x = maxX;
                    }
                    
                    if (newY >= minY && newY <= maxY) {
                        this.playerPosition.y = newY;
                    } else if (newY < minY) {
                        this.playerPosition.y = minY;
                    } else if (newY > maxY) {
                        this.playerPosition.y = maxY;
                    }
                    
                    // è¨˜éŒ„ä½ç½®è®ŠåŒ–åˆ°æ§åˆ¶å°
                    if (Math.abs(this.playerPosition.x - originalPosition.x) > 0.01 || 
                        Math.abs(this.playerPosition.y - originalPosition.y) > 0.01) {
                        this.logToConsole(`ç©å®¶ç§»å‹•åˆ°: (${this.playerPosition.x.toFixed(2)}, ${this.playerPosition.y.toFixed(2)})`);
                    }
                },
                
                // ç¢ºä¿ç©å®¶å§‹çµ‚åœ¨ç¶²æ ¼å…§
                constrainPlayerToGrid() {
                    // ä¿®æ­£é‚Šç•Œæª¢æŸ¥é‚è¼¯
                    const minX = 0;
                    const maxX = this.gridCols - 1;
                    const minY = 0;
                    const maxY = this.gridRows - 1;
                    
                    // é™åˆ¶Xåæ¨™
                    if (this.playerPosition.x < minX) {
                        this.playerPosition.x = minX;
                    } else if (this.playerPosition.x > maxX) {
                        this.playerPosition.x = maxX;
                    }
                    
                    // é™åˆ¶Yåæ¨™
                    if (this.playerPosition.y < minY) {
                        this.playerPosition.y = minY;
                    } else if (this.playerPosition.y > maxY) {
                        this.playerPosition.y = maxY;
                    }
                },
                
                // æ¸¸æˆä¸»å¾ªç¯
                gameLoop(timestamp) {
                    // è®¡ç®—å¸§é—´æ—¶é—´å·®
                    if (!this.lastTimestamp) this.lastTimestamp = timestamp;
                    const deltaTime = timestamp - this.lastTimestamp;
                    this.lastTimestamp = timestamp;
                    
                    // æ›´æ–°ç©å®¶ä½ç½®
                    this.movePlayer(deltaTime);
                    
                    // ç»§ç»­ä¸‹ä¸€å¸§
                    this.gameLoopId = requestAnimationFrame(this.gameLoop);
                },
                
                // å¯åŠ¨æ¸¸æˆå¾ªç¯
                startGameLoop() {
                    this.gameLoopId = requestAnimationFrame(this.gameLoop);
                },
                
                // è™•ç†ç¶²æ ¼å–®å…ƒæ ¼æ‡¸åœ
                handleCellHover(index) {
                    const row = Math.floor(index / this.gridCols);
                    const col = index % this.gridCols;
                    
                    this.hoverCell = {
                        row: row,
                        col: col,
                        index: index
                    };
                },
                
                // è™•ç†ç¶²æ ¼å–®å…ƒæ ¼é»æ“Š
                handleCellClick(index) {
                    if (this.isAreaSelectMode) {
                        // å¦‚æœæ˜¯å€åŸŸé¸æ“‡æ¨¡å¼ï¼Œåˆ‡æ›å–®å…ƒæ ¼çš„é¸æ“‡ç‹€æ…‹
                        const cellIndex = this.selectedCells.indexOf(index);
                        if (cellIndex === -1) {
                            this.selectedCells.push(index);
                        } else {
                            this.selectedCells.splice(cellIndex, 1);
                        }
                    } else {
                        // åŸæœ‰çš„é»æ“Šè™•ç†é‚è¼¯
                        const row = Math.floor(index / this.gridCols);
                        const col = index % this.gridCols;
                        
                        this.hoverCell = {
                            row: row,
                            col: col,
                            index: index
                        };
                        
                        this.logToConsole(`é»æ“Šç¶²æ ¼: è¡Œ=${row}, åˆ—=${col}, ç´¢å¼•=${index}`);
                    }
                },
                
                // è™•ç†ç¶²æ ¼é¼ æ¨™ç§»å‹•
                handleGridMouseMove(event) {
                    const gridRect = event.currentTarget.getBoundingClientRect();
                    const x = event.clientX - gridRect.left;
                    const y = event.clientY - gridRect.top;
                    
                    // è¨˜éŒ„åˆ°æ§åˆ¶å° (ç§»é™¤é€™è£¡çš„è¨˜éŒ„ï¼Œæ”¹ç‚ºåªåœ¨é»æ“Šæ™‚è¨˜éŒ„)
                    // this.logToConsole(`æ»‘é¼ ä½ç½®: (${Math.round(x)}, ${Math.round(y)})`);
                },
                
                // æ·»åŠ æ—¥èªŒåˆ°æ§åˆ¶å°
                logToConsole(message) {
                    // é™åˆ¶æ—¥èªŒæ•¸é‡ï¼Œä¿ç•™æœ€æ–°çš„20æ¢
                    if (this.consoleLogs.length >= 20) {
                        this.consoleLogs.shift();
                    }
                    
                    this.consoleLogs.push(message);
                    
                    // æ»¾å‹•åˆ°åº•éƒ¨
                    this.$nextTick(() => {
                        if (this.$refs.consoleOutput) {
                            this.$refs.consoleOutput.scrollTop = this.$refs.consoleOutput.scrollHeight;
                        }
                    });
                },
                
                // é–‹å§‹èª¿æ•´åˆ†éš”æ¢
                startResize(event) {
                    this.resizing = true;
                    this.initialX = event.clientX;
                    this.initialDevPanelWidth = this.$refs.devPanel.offsetWidth;
                    
                    // æ·»åŠ æ´»å‹•ç‹€æ…‹é¡
                    this.$refs.resizer.classList.add('active');
                },
                
                // è™•ç†é¼ æ¨™ç§»å‹• (ç”¨æ–¼åˆ†éš”æ¢èª¿æ•´)
                handleMouseMove(event) {
                    if (!this.resizing) return;
                    
                    const deltaX = this.initialX - event.clientX;
                    const newWidth = this.initialDevPanelWidth + deltaX;
                    
                    // ç²å–æ•´å€‹å®¹å™¨çš„å¯¬åº¦
                    const containerWidth = this.$el.offsetWidth;
                    
                    // è¨ˆç®—æ–°çš„é–‹ç™¼å€å¯¬åº¦å¾Œï¼ŒéŠæˆ²å€åŸŸçš„å¯¬åº¦
                    const gameAreaWidth = containerWidth - newWidth;
                    
                    // ç¢ºä¿éŠæˆ²å€åŸŸå¯¬åº¦åœ¨320pxåˆ°350pxä¹‹é–“
                    if (gameAreaWidth >= 350 && gameAreaWidth <= 370) {
                        this.$refs.devPanel.style.width = `${newWidth}px`;
                    } else if (gameAreaWidth < 350) {
                        // å¦‚æœéŠæˆ²å€åŸŸå¤ªçª„ï¼Œå‰‡è¨­ç½®é–‹ç™¼å€åŸŸå¯¬åº¦ï¼Œä½¿éŠæˆ²å€åŸŸæ­£å¥½ç‚º320px
                        this.$refs.devPanel.style.width = `${containerWidth - 350}px`;
                    } else if (gameAreaWidth > 370) {
                        // å¦‚æœéŠæˆ²å€åŸŸå¤ªå¯¬ï¼Œå‰‡è¨­ç½®é–‹ç™¼å€åŸŸå¯¬åº¦ï¼Œä½¿éŠæˆ²å€åŸŸæ­£å¥½ç‚º350px
                        this.$refs.devPanel.style.width = `${containerWidth - 370}px`;
                    }
                },
                
                // è™•ç†é¼ æ¨™é‡‹æ”¾ (çµæŸåˆ†éš”æ¢èª¿æ•´)
                handleMouseUp() {
                    if (this.resizing) {
                        this.resizing = false;
                        // ç§»é™¤æ´»å‹•ç‹€æ…‹é¡
                        this.$refs.resizer.classList.remove('active');
                    }
                },

                // --- æ–°å¢åœ°åœ–è³‡æ–™åº«æ–¹æ³• ---
                loadTemplatesFromDatabase() {
                    this.isLoading.load = true;
                    this.logToConsole('æ­£åœ¨å¾è³‡æ–™åº«è¼‰å…¥æ¨¡æ¿åˆ—è¡¨...');

                    fetch('/api/vue-game/map-templates'/*, { headers: this.getAuthHeaders() } */) // No longer need auth for GET
                        .then(res => {
                            if (!res.ok) {
                                return res.json().then(err => Promise.reject(err.error || `HTTP ${res.status}`));
                            }
                            return res.json();
                        })
                        .then(data => {
                            this.dbTemplates = data || [];
                            this.dbTemplatesLoaded = true;
                            this.logToConsole(`æˆåŠŸè¼‰å…¥ ${this.dbTemplates.length} å€‹æ¨¡æ¿ã€‚`);
                        })
                        .catch(err => {
                            this.logToConsole(`éŒ¯èª¤: ${err}`);
                            this.showNotification('è¼‰å…¥åˆ—è¡¨å¤±æ•—: ' + err, false);
                        })
                        .finally(() => {
                            this.isLoading.load = false;
                        });
                },

                loadTemplateFromDatabase(templateId) {
                    this.isLoading.load = true;
                    this.logToConsole(`æ­£åœ¨è¼‰å…¥æ¨¡æ¿ ID: ${templateId}...`);

                    fetch(`/api/vue-game/map-templates/${templateId}`/*, { headers: this.getAuthHeaders() } */) // No longer need auth for GET
                        .then(res => res.ok ? res.json() : Promise.reject('è¼‰å…¥æ¨¡æ¿å¤±æ•—'))
                        .then(data => {
                            this.loadedMapData.name = data.name;
                            this.loadedMapData.areas = data.areas || [];
                            this.loadedMapData.components = data.components ? data.components.map(c => ({ id: c.component_id, grid_x: c.grid_x, grid_y: c.grid_y, name: `CompID ${c.component_id}` })) : [];
                            this.showNotification(`æ¨¡æ¿ '${data.name}' è³‡æ–™å·²è¼‰å…¥é è¦½ã€‚`);
                        })
                        .catch(err => this.showNotification('è¼‰å…¥æ¨¡æ¿å¤±æ•—: ' + err, false))
                        .finally(() => this.isLoading.load = false);
                },
                
                // --- Component Library Methods ---
                loadComponentFromJson() {
                    try {
                        const component = JSON.parse(this.componentJsonInput);
                        if (!component.id || !component.name || !component.type) {
                            throw new Error('JSONç„¡æ•ˆæˆ–ç¼ºå°‘ id, name, type');
                        }
                        if (this.loadedComponents.some(c => c.id === component.id)) {
                             this.showNotification('æ­¤IDçš„å…ƒä»¶å·²å­˜åœ¨å…ƒä»¶åº«ã€‚', false);
                             return;
                        }
                        
                        if (component.type === 'static') {
                            this.rehydrateStaticComponent(component);
                        }
                        this.loadedComponents.push(component);
                        this.componentJsonInput = '';
                        this.showNotification(`å…ƒä»¶ '${component.name}' å·²åŠ å…¥ã€‚`);
                    } catch (e) {
                        this.showNotification('è§£æ JSON å¤±æ•—: ' + e.message, false);
                    }
                },
                
                getSmartImageUrl(url) {
                    if (!url) return '';
                    if (url.startsWith('http://localhost') || url.startsWith('http://127.0.0.1')) return url;
                    return `/proxy-image?url=${encodeURIComponent(url)}`;
                },

                rehydrateStaticComponent(component) {
                    if (!component.spritesheetUrl || !component.sourceRect) return;
                    const url = this.getSmartImageUrl(component.spritesheetUrl);
                    const { x, y, w, h } = component.sourceRect;
                    const spritesheet = new Image();
                    spritesheet.crossOrigin = 'Anonymous';
                    spritesheet.src = url;
                    spritesheet.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = w; canvas.height = h;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(spritesheet, x, y, w, h, 0, 0, w, h);
                        this.$set(component, 'imageData', canvas.toDataURL());
                    };
                },

                addOpacity(color, opacity) {
                    if (!color) return `rgba(255, 255, 255, ${opacity})`;

                    if (color.startsWith('#')) {
                        const r = parseInt(color.slice(1, 3), 16);
                        const g = parseInt(color.slice(3, 5), 16);
                        const b = parseInt(color.slice(5, 7), 16);
                        return `rgba(${r}, ${g}, ${b}, ${opacity})`;
                    }
                    if (color.startsWith('rgba')) {
                        return color.replace(/, [0-9\.]+?\)/, `, ${opacity})`);
                    }
                    if (color.startsWith('rgb')) {
                        return color.replace('rgb', 'rgba').replace(')', `, ${opacity})`);
                    }
                    return color;
                },

                mainAnimationLoop(currentTime) {
                    Object.values(this.animationStates).forEach(state => {
                        const { componentRef, canvasName } = state;
                        if (!componentRef || !componentRef.animation) return;
                        
                        let sourceImage = this.spritesheetCache[componentRef.animation.spritesheetUrl];
                        if (!sourceImage) {
                            const img = new Image();
                            img.crossOrigin = "Anonymous";
                            img.src = this.getSmartImageUrl(componentRef.animation.spritesheetUrl);
                            this.$set(this.spritesheetCache, componentRef.animation.spritesheetUrl, img);
                            return;
                        }

                        if (!sourceImage.complete || sourceImage.naturalHeight === 0) return;

                        if (currentTime - state.lastTime > (componentRef.animation.speed || 100)) {
                            state.lastTime = currentTime;
                            state.currentFrame = (state.currentFrame + 1) % componentRef.animation.frames.length;
                            
                            const frameInfo = componentRef.animation.frames[state.currentFrame];
                            const canvasRef = this.$refs[canvasName];
                            if (canvasRef && canvasRef[0]) {
                                const canvas = canvasRef[0];
                                const ctx = canvas.getContext('2d');
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                ctx.drawImage(sourceImage, frameInfo.x, frameInfo.y, frameInfo.w, frameInfo.h, 0, 0, canvas.width, canvas.height);
                            }
                        }
                    });
                    this.animationLoopId = requestAnimationFrame(this.mainAnimationLoop);
                },
                
                showNotification(message, success = true) {
                    this.notification.message = message;
                    this.notification.success = success;
                    this.notification.show = true;
                    if (this.notification.timer) {
                        clearTimeout(this.notification.timer);
                    }
                    this.notification.timer = setTimeout(() => {
                        this.notification.show = false;
                    }, 3000);
                },

                copyComponentInfo(component) {
                    const info = JSON.stringify(component, null, 2);
                    navigator.clipboard.writeText(info).then(() => {
                        this.showNotification(`å…ƒä»¶ "${component.name}" çš„ JSON å·²è¤‡è£½ï¼`);
                    }, () => {
                        this.showNotification('è¤‡è£½å¤±æ•—ï¼', false);
                    });
                },

                // --- Auth Helper ---
                getAuthHeaders() {
                    const savedUserId = localStorage.getItem('boxCurrentUserId');
                    const token = localStorage.getItem(`boxUserToken_${savedUserId}`);
                    const headers = {
                        'Content-Type': 'application/json',
                    };
                    if (savedUserId && token) {
                        headers['Authorization'] = `Bearer ${token}`;
                    }
                    return headers;
                },

                // --- Template Management Methods ---
                saveTemplateToDatabase() {
                    if (!this.currentTemplateName) {
                        this.showNotification('è«‹è¼¸å…¥æ¨¡æ¿åç¨±', false);
                        return;
                    }

                    this.isLoading.save = true;
                    
                    // æº–å‚™è¦ç™¼é€çš„æ•¸æ“š
                    const templateData = {
                        name: this.currentTemplateName,
                        grid_cols: this.gridCols,
                        grid_rows: this.gridRows,
                        areas: this.areas.map(area => ({
                            name: area.name,
                            color: area.color,
                            showName: area.showName || true,
                            cells: area.cells
                        })),
                        components: this.loadedComponents.map(c => ({
                            component_id: c.id,
                            grid_x: c.grid_x || 0,
                            grid_y: c.grid_y || 0
                        }))
                    };

                    try {
                        // ç™¼é€åˆ°å¾Œç«¯ API
                        const response = await fetch('/api/vue-game/map-templates', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                ...this.getAuthHeaders()
                            },
                            body: JSON.stringify(templateData)
                        });

                        if (!response.ok) {
                            throw new Error(await response.text());
                        }

                        const result = await response.json();
                        this.showNotification(`æ¨¡æ¿ '${this.currentTemplateName}' å·²æˆåŠŸä¿å­˜åˆ°è³‡æ–™åº«ï¼`);
                        
                        // é‡æ–°è¼‰å…¥æ¨¡æ¿åˆ—è¡¨
                        await this.loadTemplatesFromDatabase();
                        
                        // å¦‚æœæ˜¯æ–°æ¨¡æ¿ï¼Œæ›´æ–°é¸ä¸­çš„æ¨¡æ¿ID
                        if (result.id && !this.selectedTemplateId) {
                            this.selectedTemplateId = result.id;
                        }
                    } catch (error) {
                        console.error('ä¿å­˜æ¨¡æ¿å¤±æ•—:', error);
                        this.showNotification('ä¿å­˜å¤±æ•—: ' + error.message, false);
                    } finally {
                        this.isLoading.save = false;
                    }
                },

                deleteTemplateFromDatabase() {
                    if (!this.selectedTemplateId) {
                        this.showNotification('è«‹å…ˆé¸æ“‡ä¸€å€‹æ¨¡æ¿', false);
                        return;
                    }
                    if (!confirm(`ç¢ºå®šè¦å¾è³‡æ–™åº«åˆªé™¤æ¨¡æ¿ '${this.currentTemplateName}' å—ï¼Ÿæ­¤æ“ä½œç„¡æ³•å¾©åŸã€‚`)) return;

                    this.isLoading.delete = true;
                    fetch(`/api/vue-game/map-templates/${this.selectedTemplateId}`, { 
                        method: 'DELETE',
                        headers: this.getAuthHeaders()
                    })
                        .then(res => res.ok ? res.json() : Promise.reject('åˆªé™¤å¤±æ•—'))
                        .then(() => {
                            this.showNotification('æ¨¡æ¿å·²å¾è³‡æ–™åº«åˆªé™¤ã€‚');
                            this.createNewScene();
                            this.loadTemplatesFromDatabase();
                        })
                        .catch(err => this.showNotification('åˆªé™¤å¤±æ•—: ' + err, false))
                        .finally(() => this.isLoading.delete = false);
                },

                createNewScene() {
                    this.currentTemplateName = '';
                    this.selectedTemplateId = null;
                    this.areas = [];
                    this.loadedComponents = [];
                    this.showNotification('å·²å»ºç«‹æ–°å ´æ™¯ã€‚');
                },

                selectTemplateForEditing(template) {
                    this.currentTemplateName = template.name;
                    this.selectedTemplateId = template.id;
                    this.applyTemplateToEditor(template.id);
                },

                // ç·¨è¼¯æ¨¡å¼ç›¸é—œæ–¹æ³•
                toggleEditMode() {
                    this.isEditMode = !this.isEditMode;
                    this.isAreaSelectMode = false; // åˆ‡æ›ç·¨è¼¯æ¨¡å¼æ™‚é‡ç½®å€åŸŸé¸æ“‡æ¨¡å¼
                    this.selectedCells = []; // åˆ‡æ›ç·¨è¼¯æ¨¡å¼æ™‚æ¸…ç©ºé¸æ“‡çš„å–®å…ƒæ ¼
                    this.newArea = { name: '', color: '#FF0000' }; // é‡ç½®æ–°å€åŸŸè³‡è¨Š
                },

                toggleAreaSelectMode() {
                    this.isAreaSelectMode = !this.isAreaSelectMode;
                    this.selectedCells = []; // åˆ‡æ›å€åŸŸé¸æ“‡æ¨¡å¼æ™‚æ¸…ç©ºé¸æ“‡çš„å–®å…ƒæ ¼
                    this.newArea = { name: '', color: '#FF0000' }; // é‡ç½®æ–°å€åŸŸè³‡è¨Š
                    if (!this.isAreaSelectMode) {
                        this.editingAreaId = null; // å–æ¶ˆé¸æ“‡æ™‚ï¼Œé‡ç½®æ­£åœ¨ç·¨è¼¯çš„ID
                    }
                },

                saveArea() {
                    if (!this.newArea.name || this.selectedCells.length === 0) {
                        this.showNotification('è«‹é¸æ“‡å–®å…ƒæ ¼ä¸¦è¼¸å…¥å€åŸŸåç¨±', false);
                        return;
                    }

                    // æª¢æŸ¥åç¨±æ˜¯å¦é‡è¤‡
                    const existingAreaByName = this.areas.find(a => a.name === this.newArea.name && a.id !== this.editingAreaId);
                    if (existingAreaByName) {
                        this.showNotification(`å€åŸŸåç¨± '${this.newArea.name}' å·²å­˜åœ¨ã€‚`, false);
                        return;
                    }

                    if (this.editingAreaId) {
                        // æ›´æ–°ç¾æœ‰å€åŸŸ
                        const areaIndex = this.areas.findIndex(a => a.id === this.editingAreaId);
                        if (areaIndex !== -1) {
                            const updatedArea = {
                                ...this.areas[areaIndex],
                                name: this.newArea.name,
                                color: this.newArea.color,
                                cells: [...this.selectedCells]
                            };
                            this.$set(this.areas, areaIndex, updatedArea);
                            this.showNotification(`å€åŸŸ '${updatedArea.name}' å·²æ›´æ–°ã€‚`);
                        }
                    } else {
                        // æ·»åŠ æ–°å€åŸŸ
                        const newArea = {
                            id: Date.now(),
                            name: this.newArea.name,
                            color: this.newArea.color,
                            showName: true,
                            cells: [...this.selectedCells],
                            visible: true
                        };
                        this.areas.push(newArea);
                        this.showNotification(`å€åŸŸ '${newArea.name}' å·²æ·»åŠ ã€‚`);
                    }

                    // é‡ç½®ç‹€æ…‹
                    this.selectedCells = [];
                    this.newArea = { name: '', color: '#FF0000' };
                    this.editingAreaId = null;
                    this.isAreaSelectMode = false; // å„²å­˜å¾Œè‡ªå‹•é€€å‡ºé¸æ“‡æ¨¡å¼

                    this.saveTemplateToDatabase(); // è‡ªå‹•ä¿å­˜åˆ°é›²ç«¯
                },

                editArea(area) {
                    this.isAreaSelectMode = true; // åˆ‡æ›åˆ°å€åŸŸé¸æ“‡æ¨¡å¼
                    this.selectedCells = [...area.cells]; // è¨­ç½®é¸æ“‡çš„å–®å…ƒæ ¼
                    this.newArea = { name: area.name, color: area.color }; // è¨­ç½®ç·¨è¼¯çš„å€åŸŸè³‡è¨Š
                    this.editingAreaId = area.id; // è¨˜éŒ„æ­£åœ¨ç·¨è¼¯çš„å€åŸŸID
                    this.showNotification(`æ­£åœ¨ç·¨è¼¯å€åŸŸ '${area.name}'ã€‚æ‚¨å¯ä»¥ä¿®æ”¹é¸å–ç¯„åœå’Œè³‡è¨Šã€‚`);
                },

                deleteArea(area) {
                    if (!confirm(`ç¢ºå®šè¦åˆªé™¤å€åŸŸ '${area.name}' å—ï¼Ÿæ­¤è®Šæ›´å°‡åœ¨ä¿å­˜æ¨¡æ¿å¾Œç”Ÿæ•ˆã€‚`)) return;

                    const index = this.areas.findIndex(a => a.id === area.id);
                    if (index !== -1) {
                        this.areas.splice(index, 1);

                        // If deleting the area currently being edited, reset the form
                        if (this.editingAreaId === area.id) {
                            this.selectedCells = [];
                            this.newArea = { name: '', color: '#FF0000' };
                            this.editingAreaId = null;
                            this.isAreaSelectMode = false;
                        }

                        this.showNotification(`å€åŸŸ '${area.name}' å·²åˆªé™¤ã€‚`);
                        this.saveTemplateToDatabase(); // è‡ªå‹•ä¿å­˜åˆªé™¤æ“ä½œ
                    } else {
                        this.showNotification('æ‰¾ä¸åˆ°è©²å€åŸŸã€‚', false);
                    }
                },

                // ç²å–å–®å…ƒæ ¼æ‰€å±¬çš„å€åŸŸ
                getCellAreas(index) {
                    return this.areas.filter(area => area.cells.includes(index));
                },

                // ç²å–å–®å…ƒæ ¼çš„å€åŸŸæ–‡å­—èªªæ˜
                getCellAreasText(index) {
                    const areas = this.getCellAreas(index).filter(area => area.visible);
                    return areas.length > 0 ? areas.map(area => area.name).join(', ') : '';
                },

                // é–‹å§‹å–®å…ƒæ ¼é¸æ“‡
                startCellSelection(index) {
                    if (!this.isAreaSelectMode) return;
                    
                    this.selectionStart = index;
                    this.isSelecting = true;
                    
                    // æ·»åŠ æ»‘é¼ äº‹ä»¶ç›£è½
                    window.addEventListener('mousemove', this.handleSelectionMove);
                    window.addEventListener('mouseup', this.endCellSelection);
                    
                    // æ›´æ–°é¸æ“‡çš„å–®å…ƒæ ¼
                    this.updateSelectedCells(index);
                },

                // è™•ç†é¸æ“‡ç§»å‹•
                handleSelectionMove(event) {
                    if (!this.isSelecting) return;
                    
                    const gridRect = this.$el.querySelector('.grid').getBoundingClientRect();
                    const x = event.clientX - gridRect.left;
                    const y = event.clientY - gridRect.top;
                    
                    // è¨ˆç®—æ»‘é¼ æ‰€åœ¨çš„å–®å…ƒæ ¼ç´¢å¼•
                    const col = Math.floor(x / (this.cellSize + 1));
                    const row = Math.floor(y / (this.cellSize + 1));
                    const index = row * this.gridCols + col;
                    
                    // æ›´æ–°é¸æ“‡çš„å–®å…ƒæ ¼
                    this.updateSelectedCells(index);
                },

                // çµæŸå–®å…ƒæ ¼é¸æ“‡
                endCellSelection() {
                    this.isSelecting = false;
                    window.removeEventListener('mousemove', this.handleSelectionMove);
                    window.removeEventListener('mouseup', this.endCellSelection);
                },

                // æ›´æ–°é¸æ“‡çš„å–®å…ƒæ ¼
                updateSelectedCells(currentIndex) {
                    if (!this.isAreaSelectMode) return;
                    
                    const startRow = Math.floor(this.selectionStart / this.gridCols);
                    const startCol = this.selectionStart % this.gridCols;
                    const currentRow = Math.floor(currentIndex / this.gridCols);
                    const currentCol = currentIndex % this.gridCols;
                    
                    // è¨ˆç®—é¸æ“‡ç¯„åœ
                    const minRow = Math.min(startRow, currentRow);
                    const maxRow = Math.max(startRow, currentRow);
                    const minCol = Math.min(startCol, currentCol);
                    const maxCol = Math.max(startCol, currentCol);
                    
                    // æ¸…ç©ºä¹‹å‰çš„é¸æ“‡
                    this.selectedCells = [];
                    
                    // æ·»åŠ ç¯„åœå…§çš„æ‰€æœ‰å–®å…ƒæ ¼
                    for (let row = minRow; row <= maxRow; row++) {
                        for (let col = minCol; col <= maxCol; col++) {
                            const index = row * this.gridCols + col;
                            if (index >= 0 && index < this.gridCells.length) {
                                this.selectedCells.push(index);
                            }
                        }
                    }
                },

                toggleAllAreasVisibility() {
                    const newVisibility = !this.allAreasVisible;
                    this.areas.forEach(area => {
                        this.$set(area, 'visible', newVisibility);
                    });
                },

                toggleAreaVisibility(area) {
                    this.$set(area, 'visible', !area.visible);
                },

                // allAreasVisible: {
                //     get() {
                //         return this.areas.every(area => area.visible);
                //     },
                //     set(value) {
                //         this.areas.forEach(area => {
                //             this.$set(area, 'visible', value);
                //         });
                //     }
                // },

                // ç²å–å–®å…ƒæ ¼çš„é¡å
                getCellClasses(index) {
                    const classes = [];
                    
                    // å¦‚æœæ˜¯ç·¨è¼¯æ¨¡å¼ä¸”å€åŸŸé¸æ“‡æ¨¡å¼é–‹å•Ÿ
                    if (this.isEditMode && this.isAreaSelectMode) {
                        classes.push('selectable');
                        
                        // å¦‚æœå–®å…ƒæ ¼è¢«é¸ä¸­
                        if (this.selectedCells.includes(index)) {
                            classes.push('selected');
                        }
                    }
                    
                    // å¦‚æœå–®å…ƒæ ¼å±¬æ–¼æŸå€‹å€åŸŸ
                    const cellAreas = this.getCellAreas(index);
                    if (cellAreas.length > 0) {
                        classes.push('area-cell');
                        // å¦‚æœæœ‰å¯è¦‹çš„å€åŸŸ
                        if (cellAreas.some(area => area.visible)) {
                            classes.push('visible');
                        }
                    }
                    
                    return classes;
                },

                // å°‡æ¨¡æ¿æ‡‰ç”¨åˆ°ç·¨è¼¯å™¨
                async applyTemplateToEditor(templateId) {
                    this.isLoading.load = true;
                    this.logToConsole(`æ­£åœ¨æ‡‰ç”¨æ¨¡æ¿ ID: ${templateId} åˆ°ç·¨è¼¯å™¨...`);

                    try {
                        const response = await fetch(`/api/vue-game/map-templates/${templateId}`);
                        if (!response.ok) {
                            throw new Error('æ‡‰ç”¨æ¨¡æ¿å¤±æ•—');
                        }

                        const data = await response.json() || {};
                        
                        // æ›´æ–°æ¨¡æ¿åŸºæœ¬ä¿¡æ¯
                        this.currentTemplateName = data.name || 'æœªå‘½åæ¨¡æ¿';
                        this.gridCols = data.grid_cols || this.gridCols;
                        this.gridRows = data.grid_rows || this.gridRows;
                        
                        // æ›´æ–°å€åŸŸä¿¡æ¯ï¼Œæ·»åŠ å¯è¦‹æ€§å±¬æ€§
                        this.areas = (data.areas || []).map(area => ({
                            id: area.id,
                            name: area.name,
                            color: area.color,
                            showName: area.show_name,
                            cells: area.cells || [],
                            visible: true // è¼‰å…¥æ™‚é è¨­ç‚ºå¯è¦‹
                        }));

                        // æ›´æ–°çµ„ä»¶ä¿¡æ¯
                        this.loadedComponents = (data.components || []).map(c => ({
                            id: c.component_id,
                            grid_x: c.grid_x,
                            grid_y: c.grid_y,
                            name: `CompID ${c.component_id}`
                        }));

                        this.showNotification(`æ¨¡æ¿ '${this.currentTemplateName}' å·²è¼‰å…¥ç·¨è¼¯å™¨ã€‚`);
                    } catch (error) {
                        this.showNotification('æ‡‰ç”¨æ¨¡æ¿å¤±æ•—: ' + error.message, false);
                    } finally {
                        this.isLoading.load = false;
                    }
                }
            }
        });
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // User status elements
            const userStatusAvatar = document.getElementById('userStatusAvatar');
            const userStatusName = document.getElementById('userStatusName');
            const userStatus = document.getElementById('userStatus');

            function updateUserStatus() {
                // æª¢æŸ¥æ˜¯å¦æœ‰å·²ä¿å­˜çš„ç™»å…¥ä¿¡æ¯
                const savedUserId = localStorage.getItem('boxCurrentUserId');
                if (!savedUserId) {
                    userStatusAvatar.src = '/images/a01girlmove.gif';
                    userStatusName.textContent = 'æœªç™»å…¥';
                    userStatus.onclick = () => {
                        window.location.href = `/member-login.html?redirect=${encodeURIComponent(window.location.href)}`;
                    };
                    return;
                }
                
                const savedUserToken = localStorage.getItem(`boxUserToken_${savedUserId}`);
                const savedUserAvatarUrl = localStorage.getItem('boxCurrentUserAvatar');
                const savedUserName = localStorage.getItem('boxCurrentUsername');
                const savedDisplayName = localStorage.getItem('boxCurrentDisplayName') || savedUserName;

                // Update the user status indicator
                if (savedUserToken && savedUserName) {
                    userStatusAvatar.src = savedUserAvatarUrl || '/images/a01girlmove.gif';
                    userStatusName.textContent = savedDisplayName;
                    
                    userStatus.onclick = () => {
                        window.location.href = `/member-editor.html?userId=${savedUserId}`;
                    };
                } else {
                    userStatusAvatar.src = '/images/a01girlmove.gif';
                    userStatusName.textContent = 'æœªç™»å…¥';
                    userStatus.onclick = () => {
                        window.location.href = `/member-login.html?redirect=${encodeURIComponent(window.location.href)}`;
                    };
                }
            }

            // Initial check
            updateUserStatus();

            // Listen for storage changes to update status in real-time if needed
            window.addEventListener('storage', (event) => {
                if (event.key === 'boxCurrentUserId' || event.key.startsWith('boxUserToken_')) {
                    updateUserStatus();
                }
            });
        });
    </script>
</body>
</html> 