<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>網格測試頁面</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
    <style>
        body {
            font-family: 'Microsoft JhengHei', Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: white;
        }
        .container {
            display: flex;
            height: 100vh;
        }
        .left-panel {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: auto;
        }
        .right-panel {
            width: 300px;
            padding: 20px;
            background-color: #f9f9f9;
            border-left: 1px solid #ddd;
            overflow-y: auto;
        }
        .resizer {
            width: 8px;
            background-color: #ddd;
            cursor: col-resize;
            position: relative;
        }
        .resizer:hover, .resizer.active {
            background-color: #aaa;
        }
        .resizer::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 30px;
            background-color: #888;
        }
        .grid-container {
            position: relative;
            margin-top: 20px;
            border: 1px solid #ccc;
            overflow: auto;
            max-height: calc(100vh - 60px);
        }
        .grid {
            display: grid;
            grid-gap: 1px;
            background-color: #f0f0f0;
            position: relative;
        }
        .grid-cell {
            background-color: rgba(200, 200, 200, 0.3);
            border: 1px solid rgba(150, 150, 150, 0.3);
            box-sizing: border-box;
        }
        .grid-cell.hidden {
            background-color: transparent;
            border: none;
        }
        .grid-cell.selected {
            background-color: rgba(100, 149, 237, 0.5);
            border: 1px solid rgba(65, 105, 225, 0.8);
        }
        .grid-cell.area-cell {
            position: relative;
        }
        .area-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2;
            font-size: 10px;
            color: white;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.7);
            overflow: hidden;
            pointer-events: none;
        }
        .area-overlap {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                45deg,
                rgba(255, 255, 255, 0.4),
                rgba(255, 255, 255, 0.4) 3px,
                rgba(0, 0, 0, 0.2) 3px,
                rgba(0, 0, 0, 0.2) 6px
            );
            z-index: 10;
            pointer-events: none;
            border: 1px dashed rgba(255, 255, 255, 0.8);
            box-sizing: border-box;
        }
        .controls {
            margin-bottom: 20px;
            width: 100%;
            text-align: center;
        }
        button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
        }
        button:hover {
            background-color: #45a049;
        }
        button.secondary {
            background-color: #2196F3;
        }
        button.secondary:hover {
            background-color: #0b7dda;
        }
        button.danger {
            background-color: #f44336;
        }
        button.danger:hover {
            background-color: #d32f2f;
        }
        button.primary {
            background-color: #4CAF50;
        }
        button.primary:hover {
            background-color: #45a049;
        }
        button.active {
            background-color: #ff9800;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }
        button.active:hover {
            background-color: #e68a00;
        }
        .area-form {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #fff;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .form-group input, .form-group select {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .area-list {
            margin-top: 20px;
        }
        .area-item {
            padding: 10px;
            margin-bottom: 10px;
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            position: relative;
        }
        .area-item h4 {
            margin-top: 0;
            margin-bottom: 5px;
        }
        .area-item p {
            margin: 5px 0;
            font-size: 14px;
        }
        .area-item .actions {
            position: absolute;
            top: 10px;
            right: 10px;
        }
        .area-item .actions button {
            padding: 3px 8px;
            font-size: 12px;
            margin-left: 5px;
        }
        .color-preview {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 3px;
            vertical-align: middle;
            margin-right: 5px;
        }
        .grid-tooltip {
            position: fixed;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 1000;
            pointer-events: none;
            white-space: nowrap;
            transition: opacity 0.2s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        .grid-tooltip .tooltip-title {
            font-weight: bold;
            margin-bottom: 3px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 2px;
        }
        .grid-tooltip .tooltip-content {
            margin-top: 3px;
        }
        .grid-tooltip .area-name {
            color: #8adbff;
        }
        .grid-tooltip .area-list {
            margin-top: 5px;
            padding-top: 5px;
            border-top: 1px dotted rgba(255, 255, 255, 0.3);
        }
        .grid-tooltip .area-tag {
            display: inline-block;
            margin: 2px;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 10px;
            color: white;
        }
        .area-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-gap: 10px;
        }
        .area-grid-item {
            padding: 10px;
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            position: relative;
            display: flex;
            flex-direction: column;
        }
        .area-color-header {
            height: 30px;
            border-radius: 4px 4px 0 0;
            margin: -10px -10px 10px -10px;
        }
        .area-grid-item h4 {
            margin-top: 5px;
            margin-bottom: 5px;
            text-align: center;
        }
        .area-grid-item p {
            margin: 3px 0;
            font-size: 12px;
            text-align: center;
        }
        .area-grid-item .actions {
            margin-top: auto;
            display: flex;
            justify-content: space-between;
            padding-top: 8px;
        }
        .area-grid-item .actions button {
            flex: 1;
            padding: 3px 0;
            font-size: 12px;
            margin: 0 2px;
        }
        .event-log-container {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #fff;
            max-height: 300px;
            overflow-y: auto;
        }
        .event-log-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .event-log-entry {
            font-family: monospace;
            font-size: 12px;
            padding: 3px 0;
            border-bottom: 1px solid #eee;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .event-log-entry:last-child {
            border-bottom: none;
        }
        .component-loader {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #fff;
        }
        .component-loader textarea {
            width: 100%;
            min-height: 150px;
            box-sizing: border-box;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 8px;
            font-family: monospace;
        }
        .component-library {
            margin-top: 20px;
        }
        .library-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(64px, 1fr));
            gap: 10px;
            margin-top: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #fff;
            min-height: 80px;
        }
        .library-item {
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 64px;
            position: relative;
            overflow: hidden;
        }
        .library-item img, .library-item canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        .library-item-name {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(0,0,0,0.5);
            color: white;
            font-size: 10px;
            padding: 2px 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            align-items: center;
        }

        .library-item-name > span {
            flex: 1;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-right: 20px; /* Make space for button */
        }

        .copy-component-button {
            background: transparent;
            border: none;
            color: white;
            cursor: pointer;
            padding: 0 5px;
            margin: 0;
            font-size: 12px;
            flex-shrink: 0;
            line-height: 1;
        }
        .copy-component-button:hover {
            transform: scale(1.1);
        }

        /* Slide-in notification styles */
        .slide-in-notification {
            position: fixed;
            top: 20px;
            right: -350px;
            min-width: 250px;
            padding: 15px 20px;
            background-color: #4CAF50;
            color: white;
            border-radius: 8px 0 0 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            font-size: 14px;
            z-index: 2000;
            transition: right 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        .slide-in-notification.show {
            right: 0;
        }
        .slide-in-notification.error {
            background-color: #f44336;
        }

        /* Template Manager Styles */
        .template-manager {
            margin-bottom: 25px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #fff;
        }
        .template-manager h3 {
            margin-top: 0;
            text-align: center;
        }
        .template-actions {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
        }
        .template-actions button {
            flex: 1;
            margin: 0 3px;
            padding: 8px 5px;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        /* 雲端同步相關樣式 */
        .cloud-sync {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px dashed #ccc;
        }
        .cloud-sync h4 {
            margin-top: 0;
            text-align: center;
            font-size: 16px;
        }
        .template-list {
            max-height: 200px;
            overflow-y: auto;
            margin: 10px 0;
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 5px;
        }
        .template-list-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .template-list-item:hover {
            background-color: #f5f5f5;
        }
        .template-list-item:last-child {
            border-bottom: none;
        }
        .template-list-item .template-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .template-list-item .template-actions {
            display: flex;
            margin-top: 0;
        }
        .template-list-item .template-actions button {
            padding: 2px 5px;
            font-size: 12px;
            margin-left: 5px;
        }
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top-color: #09f;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
            vertical-align: middle;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Styles for component categorization */
        .category-group {
            margin-bottom: 20px;
        }
        .category-group:last-child {
            margin-bottom: 0;
        }
        .category-title {
            font-size: 14px;
            color: #666;
            border-bottom: 1px solid #ddd;
            padding-bottom: 8px;
            margin-top: 0;
            margin-bottom: 12px;
            font-weight: bold;
            text-transform: uppercase;
        }
        .name-group {
            margin-bottom: 15px;
        }
        .name-group-title {
            margin: 0 0 8px 0;
            font-weight: 500;
            color: #333;
        }
        .components-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(64px, 1fr));
            gap: 10px;
        }
        .empty-category-placeholder, .empty-state {
            font-size: 13px;
            color: #888;
            padding: 20px 5px;
            text-align: center;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="container">
            <div class="left-panel">
                <div class="grid-container" ref="gridContainer">
                    <div class="grid" :style="gridContainerStyle">
                        <div
                            v-for="index in gridCellCount"
                            :key="'grid-cell-' + index"
                            :id="'grid-cell-' + index"
                            class="grid-cell"
                            :class="{ 
                                hidden: !editMode, 
                                selected: isSelectedCell(index - 1),
                                'area-cell': getCellAreaInfo(index - 1)
                            }"
                            @click="onCellClick(index - 1, $event)"
                            @mousedown="startAreaSelection(index - 1, $event)"
                            @mouseover="updateAreaSelection(index - 1); showTooltip($event, index - 1)"
                            @mouseout="hideTooltip"
                            @mouseup="endAreaSelection($event)"
                        >
                            <template v-if="editMode">
                                <div 
                                    v-for="(area, areaIndex) in getCellAreas(index - 1)"
                                    :key="'area-' + area.id + '-' + index"
                                    class="area-overlay"
                                    :style="{ 
                                        backgroundColor: addOpacity(area.color, getCellAreas(index - 1).length > 1 ? 0.25 : 0.5),
                                        zIndex: 2 + areaIndex,
                                        opacity: 1 - (areaIndex * 0.1)
                                    }"
                                >
                                </div>
                                <div
                                    v-if="isOverlappingCell(index - 1)"
                                    class="area-overlap"
                                >
                                </div>
                            </template>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="resizer" 
                 @mousedown="startResize" 
                 :class="{ active: isResizing }"></div>
            
            <div class="right-panel" ref="rightPanel">
                <div class="template-manager">
                    <h3>模板管理</h3>
                    <div class="form-group">
                        <label for="templateSelect">選擇模板</label>
                        <select id="templateSelect" v-model="selectedTemplate" @change="loadTemplate">
                            <option value="">-- 選擇一個模板 --</option>
                            <option v-for="(template, name) in templates" :key="name" :value="name">{{ name }}</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="templateName">模板名稱</label>
                        <input type="text" id="templateName" v-model="currentTemplateName" placeholder="輸入新模板名稱或選擇上方模板">
                    </div>
                    <div class="template-actions">
                        <button class="primary" @click="saveTemplate">儲存/更新</button>
                        <button class="danger" @click="deleteTemplate" :disabled="!selectedTemplate">刪除</button>
                        <button class="secondary" @click="createNewScene">新場景</button>
                    </div>
                    
                    <div class="cloud-sync">
                        <h4>雲端同步</h4>
                        <div class="form-group">
                            <button class="primary" @click="saveTemplateToDatabase" :disabled="!currentTemplateName">
                                <span v-if="isLoading.save" class="loading-spinner"></span>
                                保存到資料庫
                            </button>
                            <button class="secondary" @click="loadTemplatesFromDatabase">
                                <span v-if="isLoading.load" class="loading-spinner"></span>
                                從資料庫載入
                            </button>
                        </div>
                        
                        <div v-if="dbTemplates.length > 0" class="template-list">
                            <div v-for="template in dbTemplates" :key="template.id" class="template-list-item">
                                <div class="template-name">{{ template.name }}</div>
                                <div class="template-actions">
                                    <button class="secondary" @click="loadTemplateFromDatabase(template.id)">
                                        載入
                                    </button>
                                    <button class="danger" @click="deleteTemplateFromDatabase(template.id)">
                                        刪除
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div v-else-if="dbTemplatesLoaded" class="empty-state">
                            <p>資料庫中尚無模板。</p>
                        </div>
                    </div>
                </div>

                <div class="controls">
                    <button @click="toggleEditMode">{{ editMode ? '關閉編輯模式' : '開啟編輯模式' }}</button>
                    <button 
                        class="primary" 
                        :class="{ active: isAreaSelectionMode }"
                        @click="toggleAreaSelectionMode">
                        {{ isAreaSelectionMode ? '取消新增區域' : '新增區域' }}
                    </button>
                    <button class="secondary" @click="clearSelection" v-if="selectedCells.length > 0">清除選擇</button>
                    <button class="danger" @click="clearAllAreas" v-if="areas.length > 0">清除所有區域</button>
                </div>
                
                <div class="area-form" v-if="selectedCells.length > 0">
                    <h3>{{ editingAreaIndex >= 0 ? '編輯區域' : '新增區域' }}</h3>
                    <div class="form-group">
                        <label for="areaName">區域名稱</label>
                        <input type="text" id="areaName" v-model="newArea.name" placeholder="輸入區域名稱">
                    </div>
                    <div class="form-group">
                        <label for="areaColor">區域顏色</label>
                        <input type="color" id="areaColor" v-model="newArea.color">
                    </div>
                    <div class="form-group">
                        <label>已選擇單元格數: {{ selectedCells.length }}</label>
                    </div>
                    <button @click="saveArea">儲存區域</button>
                    <button class="secondary" @click="clearSelection">取消</button>
                </div>
                
                <div class="area-list" v-if="areas.length > 0">
                    <h3>已儲存區域</h3>
                    <div class="area-grid">
                        <div class="area-grid-item" v-for="(area, index) in areas" :key="area.id">
                            <div class="area-color-header" :style="{ backgroundColor: area.color }"></div>
                            <h4>{{ area.name }}</h4>
                            <p>單元格數: {{ area.cells.length }}</p>
                            <div class="actions">
                                <button class="secondary" @click="editArea(area)">編輯</button>
                                <button class="danger" @click="deleteArea(index)">刪除</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="component-loader">
                    <h3>載入元件</h3>
                    <div class="form-group">
                        <label for="componentJson">元件 JSON</label>
                        <textarea id="componentJson" v-model="componentJsonInput" rows="3" placeholder="在這裡貼上元件的 JSON"></textarea>
                    </div>
                    <button @click="loadComponentFromJson">加入元件</button>
                </div>

                <div class="component-library">
                    <h3>元件庫</h3>
                    <div v-if="loadedComponents.length > 0">
                        <div v-for="category in categories" :key="category" class="category-group">
                            <h4 class="category-title">{{ category }}</h4>
                            <div v-if="categorizedComponents[category] && Object.keys(categorizedComponents[category]).length > 0">
                                <div v-for="(components, name) in categorizedComponents[category]" :key="name" class="name-group">
                                    <h5 class="name-group-title">{{ name }} ({{ components.length }})</h5>
                                    <div class="components-list">
                                        <div v-for="component in components" :key="component.id" class="library-item">
                                            
                                            <!-- GIF 檔案直接使用原始 URL -->
                                            <img v-if="component.type === 'static' && component.fileType === 'gif'"
                                                 :src="component.spritesheetUrl"
                                                 :alt="component.name">
                                                 
                                            <!-- 其他靜態元件使用 imageData -->
                                            <img v-else-if="component.type === 'static' && component.imageData"
                                                 :src="component.imageData"
                                                 :alt="component.name">
                                            
                                            <canvas v-if="component.type === 'animation'"
                                                   :ref="'anim-canvas-library-' + component.id"
                                                   :width="component.width"
                                                   :height="component.height"></canvas>

                                            <div class="library-item-name">
                                                <button class="copy-component-button" @click.stop="copyComponentInfo(component)" title="複製元件資訊">📋</button>
                                                <span>{{ component.subcategory || component.name }}</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="empty-category-placeholder" v-else>
                                (此分類暫無元件)
                            </div>
                        </div>
                    </div>
                    <div v-else class="empty-state">
                        <p>尚未載入任何元件。</p>
                    </div>
                </div>
                
                <!-- 添加事件日誌顯示區域 -->
                <div class="event-log-container">
                    <div class="event-log-title">
                        <h3>事件日誌</h3>
                        <button class="secondary" @click="eventLog = []">清除日誌</button>
                    </div>
                    <div v-if="eventLog.length > 0">
                        <div v-for="(entry, index) in eventLog" :key="index" class="event-log-entry">
                            {{ entry }}
                        </div>
                    </div>
                    <div v-else class="empty-state">
                        <p>尚無事件日誌。</p>
                    </div>
                </div>
            </div>
        </div>
        
        <div 
            v-if="tooltip.show" 
            class="grid-tooltip" 
            :style="{ left: tooltip.x + 'px', top: tooltip.y + 'px' }"
        >
            <div class="tooltip-title">位置: 行 {{ tooltip.row + 1 }}, 列 {{ tooltip.col + 1 }}</div>
            <div class="tooltip-content">座標: X {{ tooltip.gridX }}, Y {{ tooltip.gridY }}</div>
            <div class="tooltip-content area-list" v-if="tooltip.areas && tooltip.areas.length > 0">
                區域:
                <div v-for="(area, index) in tooltip.areas" :key="index">
                    <span class="area-tag" :style="{ backgroundColor: addOpacity(area.color, 0.7) }">
                        {{ area.name }}
                    </span>
                </div>
            </div>
        </div>

        <div class="slide-in-notification" :class="{ show: notification.show, error: !notification.success }">
            {{ notification.message }}
        </div>
    </div>

    <script>
        new Vue({
            el: '#app',
            data: {
                gridCols: 10,
                gridRows: 24,
                editMode: true,
                lastClickedCell: null,
                isResizing: false,
                notification: {
                    show: false,
                    message: '',
                    success: true,
                    timer: null
                },

                // 模板管理
                templates: {},
                selectedTemplate: '',
                currentTemplateName: '',
                
                // 雲端同步相關
                dbTemplates: [],
                dbTemplatesLoaded: false,
                isLoading: {
                    save: false,
                    load: false,
                    delete: false
                },
                
                // 區域選擇相關
                isSelecting: false,
                selectionStart: -1,
                selectedCells: [],
                isAreaSelectionMode: false,
                
                // 提示框相關
                tooltip: {
                    show: false,
                    x: 0,
                    y: 0,
                    row: 0,
                    col: 0,
                    gridX: 0,
                    gridY: 0,
                    areaName: '',
                    areas: []
                },
                
                // 區域資料
                areas: [],
                newArea: {
                    name: '',
                    color: '#4CAF50',
                    showName: false,
                    cells: []
                },
                editingAreaIndex: -1,

                // 元件庫相關
                categories: ['人物', '物品', '背景', 'UI界面', '特效'],
                componentJsonInput: '{\n  "id": 185,\n  "name": "喵咪盒子",\n  "type": "animation",\n  "width": 29,\n  "height": 31,\n  "category": "人物",\n  "subcategory": "",\n  "scale": 1,\n  "displayScale": 100,\n  "anchor": "bottom-left",\n  "createdAt": "2025-07-11T01:32:56.637Z",\n  "animation": {\n    "spritesheetUrl": "https://sunnyyummy.onrender.com/uploads/1752213327712-12692.png",\n    "speed": 100,\n    "loop": true,\n    "frames": [\n      {\n        "x": 1,\n        "y": 1,\n        "w": 29,\n        "h": 31\n      },\n      {\n        "x": 32,\n        "y": 2,\n        "w": 31,\n        "h": 30\n      },\n      {\n        "x": 65,\n        "y": 2,\n        "w": 29,\n        "h": 29\n      },\n      {\n        "x": 97,\n        "y": 1,\n        "w": 29,\n        "h": 30\n      }\n    ]\n  }\n}',
                loadedComponents: [],
                animationStates: {},
                spritesheetCache: {},
                mainLoopId: null,
                // 添加日誌記錄
                eventLog: [],
                maxLogEntries: 20,
            },
            watch: {
                areas: {
                    handler() { this.saveCurrentStateToLocalStorage(); },
                    deep: true
                },
                loadedComponents: {
                    handler(newComponents) {
                        const activeLibIndexes = new Set();
                        newComponents.forEach((component, index) => {
                            if (component.type === 'animation') {
                                const stateKey = `library-${component.id}`;
                                activeLibIndexes.add(stateKey);
                                if (!this.animationStates[stateKey]) {
                                    this.$set(this.animationStates, stateKey, {
                                        currentFrame: 0,
                                        lastTime: 0,
                                        componentRef: component,
                                        canvasName: `anim-canvas-library-${component.id}`
                                    });
                                }
                            }
                        });
                        
                        Object.keys(this.animationStates).forEach(key => {
                            if (key.startsWith('library-')) {
                                const id = key.replace('library-', '');
                                if (!newComponents.some(c => c.id == id)) {
                                    this.$delete(this.animationStates, key);
                                }
                            }
                        });
                        this.saveCurrentStateToLocalStorage();
                    },
                    deep: true
                }
            },
            computed: {
                gridCellCount() {
                    return this.gridCols * this.gridRows;
                },
                gridContainerStyle() {
                    const cellSize = 32;
                    const gap = 1;
                    const width = this.gridCols * cellSize + (this.gridCols - 1) * gap;
                    const height = this.gridRows * cellSize + (this.gridRows - 1) * gap;
                    return {
                        gridTemplateColumns: `repeat(${this.gridCols}, ${cellSize}px)`,
                        gridTemplateRows: `repeat(${this.gridRows}, ${cellSize}px)`,
                        width: `${width}px`,
                        height: `${height}px`,
                    };
                },
                categorizedComponents() {
                    const grouped = {};
                    this.loadedComponents.forEach((component) => {
                        const category = component.category || '物品';
                        const name = component.name || '未命名';

                        if (!grouped[category]) {
                            grouped[category] = {};
                        }
                        
                        if (!grouped[category][name]) {
                            grouped[category][name] = [];
                        }
                        grouped[category][name].push(component);
                    });
                    return grouped;
                },
            },
            mounted() {
                // 設置右側面板初始寬度
                this.$refs.rightPanel.style.width = '300px';
                
                this.loadTemplatesFromLocalStorage();
                this.loadCurrentStateFromLocalStorage();
                
                // 嘗試載入資料庫模板列表
                this.loadTemplatesFromDatabase();

                // 啟動主動畫循環
                this.mainAnimationLoop();
                
                // 添加文檔點擊事件處理器
                document.addEventListener('click', this.handleDocumentClick);
                
                // 添加全局滑鼠事件監聽器
                document.addEventListener('mouseup', this.handleGlobalMouseUp);
            },
            beforeDestroy() {
                if (this.mainLoopId) {
                    cancelAnimationFrame(this.mainLoopId);
                }
                
                // 移除文檔點擊事件處理器
                document.removeEventListener('click', this.handleDocumentClick);
                
                // 移除全局滑鼠事件監聽器
                document.removeEventListener('mouseup', this.handleGlobalMouseUp);
            },
            methods: {
                showNotification(message, success = true, duration = 3000) {
                    if (this.notification.timer) {
                        clearTimeout(this.notification.timer);
                    }
                    this.notification.message = message;
                    this.notification.success = success;
                    this.notification.show = true;
                    this.notification.timer = setTimeout(() => {
                        this.notification.show = false;
                    }, duration);
                },

                copyComponentInfo(component) {
                    const textToCopy = `unit_components\nid=${component.id}\nname=${component.name}`;
                    
                    navigator.clipboard.writeText(textToCopy)
                        .then(() => {
                            this.showNotification(`'${component.name}' 的資訊已複製！`);
                        })
                        .catch(err => {
                            console.error('複製失敗:', err);
                            this.showNotification('複製失敗，請檢查瀏覽器權限。', false);
                        });
                },

                // 模板管理方法
                saveTemplate() {
                    if (!this.currentTemplateName) {
                        this.showNotification('請輸入模板名稱', false);
                        return;
                    }
                    const isUpdating = !!this.templates[this.currentTemplateName];
                    if (isUpdating) {
                        if (!confirm(`確定要更新模板 '${this.currentTemplateName}' 嗎？`)) {
                            return;
                        }
                    }

                    this.$set(this.templates, this.currentTemplateName, {
                        areas: JSON.parse(JSON.stringify(this.areas)),
                        components: JSON.parse(JSON.stringify(this.loadedComponents)),
                        updatedAt: new Date().toISOString()
                    });

                    this.saveTemplatesToLocalStorage();
                    this.selectedTemplate = this.currentTemplateName;
                    this.showNotification(`模板 '${this.currentTemplateName}' 已${isUpdating ? '更新' : '儲存'}！`);
                },

                // 資料庫同步方法
                saveTemplateToDatabase() {
                    if (!this.currentTemplateName) {
                        this.showNotification('請輸入模板名稱', false);
                        return;
                    }

                    this.isLoading.save = true;

                    // 準備模板數據
                    const templateData = {
                        name: this.currentTemplateName,
                        description: `地圖模板: ${this.currentTemplateName}`,
                        grid_cols: this.gridCols,
                        grid_rows: this.gridRows,
                        areas: this.areas.map(area => ({
                            name: area.name,
                            color: area.color,
                            show_name: area.showName,
                            cells: area.cells
                        })),
                        components: this.loadedComponents.map(comp => ({
                            component_id: comp.id,
                            grid_x: comp.grid_x || 0,
                            grid_y: comp.grid_y || 0,
                            position_x: comp.position_x || 0,
                            position_y: comp.position_y || 0,
                            z_index: comp.z_index || 0
                        }))
                    };

                    // 發送到後端 API
                    fetch('/api/map-templates', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(templateData)
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('保存模板到資料庫失敗');
                        }
                        return response.json();
                    })
                    .then(data => {
                        this.showNotification(`模板 '${this.currentTemplateName}' 已保存到資料庫！`);
                        this.loadTemplatesFromDatabase(); // 重新載入模板列表
                    })
                    .catch(error => {
                        console.error('保存模板到資料庫失敗:', error);
                        this.showNotification('保存模板到資料庫失敗: ' + error.message, false);
                    })
                    .finally(() => {
                        this.isLoading.save = false;
                    });
                },

                loadTemplatesFromDatabase() {
                    this.isLoading.load = true;
                    
                    fetch('/api/map-templates')
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('載入模板列表失敗');
                            }
                            return response.json();
                        })
                        .then(data => {
                            this.dbTemplates = data || [];
                            this.dbTemplatesLoaded = true;
                        })
                        .catch(error => {
                            console.error('載入模板列表失敗:', error);
                            this.showNotification('載入模板列表失敗: ' + error.message, false);
                            this.dbTemplates = [];
                            this.dbTemplatesLoaded = false;
                        })
                        .finally(() => {
                            this.isLoading.load = false;
                        });
                },

                loadTemplateFromDatabase(templateId) {
                    this.isLoading.load = true;
                    
                    fetch(`/api/map-templates/${templateId}`)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('載入模板失敗');
                            }
                            return response.json();
                        })
                        .then(data => {
                            // 設置網格大小
                            this.gridCols = data.grid_cols || 10;
                            this.gridRows = data.grid_rows || 24;
                            
                            // 設置區域
                            this.areas = data.areas.map(area => ({
                                id: area.id || Date.now() + Math.floor(Math.random() * 1000),
                                name: area.name,
                                color: area.color,
                                showName: area.show_name || false,
                                cells: area.cells || []
                            }));
                            
                            // 載入元件 (這裡需要確保元件已在元件庫中)
                            // 這部分可能需要根據實際情況調整
                            const componentIds = data.components.map(c => c.component_id);
                            
                            // 如果需要，可以先載入這些元件
                            // 這裡簡化處理，僅設置位置信息
                            data.components.forEach(comp => {
                                const existingComp = this.loadedComponents.find(c => c.id === comp.component_id);
                                if (existingComp) {
                                    existingComp.grid_x = comp.grid_x;
                                    existingComp.grid_y = comp.grid_y;
                                    existingComp.position_x = comp.position_x;
                                    existingComp.position_y = comp.position_y;
                                    existingComp.z_index = comp.z_index;
                                }
                            });
                            
                            this.currentTemplateName = data.name;
                            this.showNotification(`模板 '${data.name}' 已從資料庫載入。`);
                        })
                        .catch(error => {
                            console.error('載入模板失敗:', error);
                            this.showNotification('載入模板失敗: ' + error.message, false);
                        })
                        .finally(() => {
                            this.isLoading.load = false;
                        });
                },

                deleteTemplateFromDatabase(templateId) {
                    if (!confirm('確定要從資料庫刪除此模板嗎？此操作無法撤銷。')) {
                        return;
                    }
                    
                    fetch(`/api/map-templates/${templateId}`, {
                        method: 'DELETE'
                    })
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('刪除模板失敗');
                            }
                            return response.json();
                        })
                        .then(data => {
                            this.showNotification('模板已從資料庫刪除。');
                            this.loadTemplatesFromDatabase(); // 重新載入模板列表
                        })
                        .catch(error => {
                            console.error('刪除模板失敗:', error);
                            this.showNotification('刪除模板失敗: ' + error.message, false);
                        });
                },

                loadTemplate() {
                    if (!this.selectedTemplate) {
                        this.currentTemplateName = '';
                        return;
                    }
                    const template = this.templates[this.selectedTemplate];
                    if (template) {
                        if (this.areas.length > 0 || this.loadedComponents.length > 0) {
                            if (!confirm(`載入模板 '${this.selectedTemplate}' 將會覆蓋目前未儲存的變更，確定嗎？`)) {
                                this.$nextTick(() => {
                                    this.selectedTemplate = this.findCurrentTemplateName() || '';
                                });
                                return;
                            }
                        }

                        this.areas = JSON.parse(JSON.stringify(template.areas || []));
                        
                        const newComponents = JSON.parse(JSON.stringify(template.components || []));
                        this.loadedComponents = newComponents;
                        
                        // Rehydrate static components
                        this.$nextTick(() => {
                           newComponents.forEach(component => {
                                if (component.type === 'static' && !component.imageData) {
                                    this.rehydrateStaticComponent(component);
                                }
                            });
                        });
                        
                        this.currentTemplateName = this.selectedTemplate;
                        this.showNotification(`模板 '${this.selectedTemplate}' 已載入。`);
                    }
                },

                deleteTemplate() {
                    if (!this.selectedTemplate) return;
                    if (confirm(`確定要永久刪除模板 '${this.selectedTemplate}' 嗎？`)) {
                        this.$delete(this.templates, this.selectedTemplate);
                        this.saveTemplatesToLocalStorage();

                        this.showNotification(`模板 '${this.selectedTemplate}' 已刪除。`);
                        
                        if (this.currentTemplateName === this.selectedTemplate) {
                            this.createNewScene();
                        }
                        this.selectedTemplate = '';
                    }
                },

                createNewScene() {
                    this.areas = [];
                    this.loadedComponents = [];
                    this.selectedTemplate = '';
                    this.currentTemplateName = '';
                    this.clearSelection();
                    this.showNotification('已建立新場景。');
                },

                findCurrentTemplateName() {
                    // This is a helper to find if the current state matches any saved template
                    for (const name in this.templates) {
                        const template = this.templates[name];
                        if (JSON.stringify(template.areas) === JSON.stringify(this.areas) &&
                            JSON.stringify(template.components) === JSON.stringify(this.loadedComponents)) {
                            return name;
                        }
                    }
                    return null;
                },

                // 本地儲存重構
                saveTemplatesToLocalStorage() {
                    try {
                        localStorage.setItem('map-editor-templates', JSON.stringify(this.templates));
                    } catch (e) {
                        console.error('保存模板到 localStorage 失敗', e);
                    }
                },

                loadTemplatesFromLocalStorage() {
                    const savedTemplates = localStorage.getItem('map-editor-templates');
                    if (savedTemplates) {
                        try {
                            this.templates = JSON.parse(savedTemplates);
                        } catch(e) {
                            console.error('從 localStorage 載入模板失敗', e);
                            this.templates = {};
                        }
                    } else {
                        this.templates = {};
                    }
                },
                
                saveCurrentStateToLocalStorage() {
                    try {
                        const state = {
                            areas: this.areas,
                            components: this.loadedComponents
                        };
                        localStorage.setItem('map-editor-current-state', JSON.stringify(state));
                    } catch (e) {
                        console.error('保存當前狀態到 localStorage 失敗', e);
                        this.showNotification('無法保存當前狀態到本地儲存', false);
                    }
                },

                loadCurrentStateFromLocalStorage() {
                    try {
                        const savedState = localStorage.getItem('map-editor-current-state');
                        if (savedState) {
                            try {
                                const state = JSON.parse(savedState);
                                this.areas = state.areas || [];
                                const components = state.components || [];
                                this.loadedComponents = components;
                                
                                // 確保所有靜態元件都被正確處理
                                this.$nextTick(() => {
                                    this.loadedComponents.forEach(component => {
                                        if (component.type === 'static' && !component.imageData) {
                                            this.rehydrateStaticComponent(component);
                                        }
                                    });
                                });
                            } catch(e) {
                                console.error('從 localStorage 載入當前狀態失敗', e);
                                this.areas = [];
                                this.loadedComponents = [];
                            }
                        } else {
                            // 如果沒有保存的狀態，初始化為空
                            this.areas = [];
                            this.loadedComponents = [];
                        }
                    } catch (e) {
                        console.error('讀取 localStorage 失敗', e);
                        this.areas = [];
                        this.loadedComponents = [];
                    }
                },

                // 添加日誌記錄方法
                logEvent(eventName, details) {
                    const timestamp = new Date().toISOString().substr(11, 12); // 時間格式 HH:MM:SS.mmm
                    const logEntry = `${timestamp} - ${eventName}: ${JSON.stringify(details)}`;
                    console.log(logEntry);
                    this.eventLog.unshift(logEntry);
                    
                    // 保持日誌不超過最大條目數
                    if (this.eventLog.length > this.maxLogEntries) {
                        this.eventLog.pop();
                    }
                },
                
                // 處理文檔點擊事件
                handleDocumentClick(event) {
                    // 檢查點擊是否在網格容器內
                    const gridContainer = this.$refs.gridContainer;
                    const isClickInGrid = gridContainer && gridContainer.contains(event.target);
                    
                    // 檢查點擊是否在區域表單內
                    const areaForm = document.querySelector('.area-form');
                    const isClickInForm = areaForm && areaForm.contains(event.target);
                    
                    // 移除日誌偵錯代碼
                    
                    // 如果點擊不在網格或表單內，且不是在編輯區域，則不清除選擇
                    if (!isClickInGrid && !isClickInForm && this.editingAreaIndex < 0) {
                        // 不做任何事情，保持選擇狀態
                        return;
                    }
                },
                
                // 處理全局滑鼠抬起事件
                handleGlobalMouseUp(event) {
                    // 檢查是否在選擇模式且有選中的單元格
                    if (this.isAreaSelectionMode && this.selectedCells.length > 0) {
                        this.logEvent('handleGlobalMouseUp', {
                            selectedCellsCount: this.selectedCells.length,
                            target: event.target.tagName
                        });
                        
                        // 不做任何清除操作，保持選擇狀態
                    }
                },
                toggleEditMode() {
                    this.editMode = !this.editMode;
                },
                onCellClick(index, event) {
                    // 防止事件冒泡，避免其他事件處理器被觸發
                    if (event) {
                        event.stopPropagation();
                    }
                    
                    const row = Math.floor(index / this.gridCols);
                    const col = index % this.gridCols;
                    this.lastClickedCell = `行: ${row + 1}, 列: ${col + 1} (索引: ${index})`;
                    
                    this.logEvent('onCellClick', { 
                        index, 
                        row: row + 1, 
                        col: col + 1,
                        isAreaSelectionMode: this.isAreaSelectionMode,
                        selectedCellsCount: this.selectedCells.length
                    });
                    
                    // 如果在區域選擇模式下，單擊可以切換單元格選擇狀態
                    if (this.editMode && this.isAreaSelectionMode) {
                        // 檢查是否是從 mousedown/mouseup 事件鏈中觸發的點擊
                        // 如果是，則不執行選擇切換邏輯，避免與 startAreaSelection/endAreaSelection 衝突
                        const now = Date.now();
                        if (!this._lastMouseUpTime || now - this._lastMouseUpTime > 50) {
                            const isSelected = this.isSelectedCell(index);
                            if (isSelected && this.selectedCells.length > 1) {
                                // 如果已選中且不是單格選擇，則取消選中
                                this.selectedCells = this.selectedCells.filter(cellIndex => cellIndex !== index);
                            } else if (!isSelected) {
                                // 如果未選中，則選中
                                this.selectedCells = [index]; // 直接替換為單一選擇
                                this.newArea.cells = [index];
                                this.newArea.name = `區域 ${this.areas.length + 1}`;
                            }
                            // 如果已選中且是單格選擇，則不做任何事情，保持選擇狀態
                        }
                        
                        this.logEvent('onCellClick-afterSelection', { 
                            selectedCellsCount: this.selectedCells.length,
                            newAreaCellsCount: this.newArea.cells.length
                        });
                    }
                },
                startResize(event) {
                    this.isResizing = true;
                    document.addEventListener('mousemove', this.resize);
                    document.addEventListener('mouseup', this.stopResize);
                },
                resize(event) {
                    if (!this.isResizing) return;
                    
                    // 計算右側面板的新寬度
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newRightWidth = containerWidth - event.clientX;
                    
                    // 設置最小寬度
                    const minWidth = 200;
                    if (newRightWidth < minWidth) return;
                    
                    // 設置最大寬度
                    const maxWidth = containerWidth - 400; // 確保左側至少有400px
                    if (newRightWidth > maxWidth) return;
                    
                    this.$refs.rightPanel.style.width = `${newRightWidth}px`;
                },
                stopResize() {
                    this.isResizing = false;
                    document.removeEventListener('mousemove', this.resize);
                    document.removeEventListener('mouseup', this.stopResize);
                },
                
                // 區域選擇相關方法
                startAreaSelection(index, event) {
                    // 防止事件冒泡，避免其他事件處理器被觸發
                    if (event) {
                        event.stopPropagation();
                    }
                    
                    this.logEvent('startAreaSelection', { 
                        index, 
                        editMode: this.editMode, 
                        isAreaSelectionMode: this.isAreaSelectionMode
                    });
                    
                    if (!this.editMode || !this.isAreaSelectionMode) return;
                    this.isSelecting = true;
                    this.selectionStart = index;
                    this.selectedCells = [index];
                    
                    // 預先設置區域資料，以便即使是單格選擇也能保持
                    this.newArea.cells = [index];
                    this.newArea.name = `區域 ${this.areas.length + 1}`;
                    
                    this.logEvent('startAreaSelection-afterSetup', { 
                        isSelecting: this.isSelecting,
                        selectionStart: this.selectionStart,
                        selectedCellsCount: this.selectedCells.length,
                        newAreaCellsCount: this.newArea.cells.length
                    });
                },
                updateAreaSelection(index) {
                    if (!this.isSelecting || !this.editMode || !this.isAreaSelectionMode) return;
                    
                    this.logEvent('updateAreaSelection', { 
                        index, 
                        isSelecting: this.isSelecting,
                        selectedCellsCount: this.selectedCells.length
                    });
                    
                    // 計算選擇範圍
                    const startRow = Math.floor(this.selectionStart / this.gridCols);
                    const startCol = this.selectionStart % this.gridCols;
                    const currentRow = Math.floor(index / this.gridCols);
                    const currentCol = index % this.gridCols;
                    
                    const minRow = Math.min(startRow, currentRow);
                    const maxRow = Math.max(startRow, currentRow);
                    const minCol = Math.min(startCol, currentCol);
                    const maxCol = Math.max(startCol, currentCol);
                    
                    // 清空當前選擇
                    this.selectedCells = [];
                    
                    // 添加範圍內的所有單元格
                    for (let row = minRow; row <= maxRow; row++) {
                        for (let col = minCol; col <= maxCol; col++) {
                            const cellIndex = row * this.gridCols + col;
                            this.selectedCells.push(cellIndex);
                        }
                    }
                    
                    this.logEvent('updateAreaSelection-afterCalculation', { 
                        selectedCellsCount: this.selectedCells.length,
                        selectionArea: `${maxRow-minRow+1}x${maxCol-minCol+1}`
                    });
                },
                endAreaSelection(event) {
                    // 防止事件冒泡
                    if (event) {
                        event.stopPropagation();
                    }
                    
                    this.isSelecting = false;
                    this._lastMouseUpTime = Date.now(); // 記錄最後一次 mouseup 時間
                    
                    this.logEvent('endAreaSelection', { 
                        selectedCellsCount: this.selectedCells.length,
                        newAreaCellsCount: this.newArea.cells.length
                    });
                    
                    // 確保選擇不會因為滑鼠放開而消失
                    if (this.selectedCells.length > 0) {
                        // 保持選擇狀態，不做任何改變
                        this.newArea.cells = [...this.selectedCells];
                        
                        // 確保區域表單顯示
                        this.$nextTick(() => {
                            // 強制更新視圖
                            this.$forceUpdate();
                        });
                    }
                    
                    this.logEvent('endAreaSelection-afterSetup', { 
                        isSelecting: this.isSelecting,
                        selectedCellsCount: this.selectedCells.length,
                        newAreaCellsCount: this.newArea.cells.length
                    });
                },
                isSelectedCell(index) {
                    return this.selectedCells.includes(index);
                },
                clearSelection() {
                    this.logEvent('clearSelection', {
                        selectedCellsCount: this.selectedCells.length,
                        editingAreaIndex: this.editingAreaIndex,
                        caller: new Error().stack.split('\n')[2].trim()
                    });
                    
                    this.selectedCells = [];
                    this.newArea.name = '';
                    this.newArea.cells = [];
                    this.editingAreaIndex = -1;
                },
                
                toggleAreaSelectionMode() {
                    this.isAreaSelectionMode = !this.isAreaSelectionMode;
                    if (!this.isAreaSelectionMode) {
                        this.clearSelection();
                    }
                },
                
                // 提示框相關方法
                showTooltip(event, index) {
                    if (!this.editMode) return;
                    
                    const row = Math.floor(index / this.gridCols);
                    const col = index % this.gridCols;
                    
                    // 計算網格座標 (X, Y)
                    const cellSize = 32;
                    const gap = 1;
                    const gridX = col * (cellSize + gap);
                    const gridY = row * (cellSize + gap);
                    
                    // 獲取所有包含此單元格的區域
                    const cellAreas = this.getAllCellAreas(index);
                    
                    // 設置提示框內容
                    this.tooltip.row = row;
                    this.tooltip.col = col;
                    this.tooltip.gridX = gridX;
                    this.tooltip.gridY = gridY;
                    this.tooltip.areas = cellAreas;
                    
                    // 設置提示框位置 (更靠近滑鼠位置)
                    this.tooltip.x = event.clientX + 5;
                    this.tooltip.y = event.clientY + 5;
                    
                    // 顯示提示框
                    this.tooltip.show = true;
                    
                    // 確保提示框不超出視窗
                    this.$nextTick(() => {
                        const tooltip = document.querySelector('.grid-tooltip');
                        if (!tooltip) return;
                        
                        const rect = tooltip.getBoundingClientRect();
                        const windowWidth = window.innerWidth;
                        const windowHeight = window.innerHeight;
                        
                        if (rect.right > windowWidth) {
                            this.tooltip.x = event.clientX - rect.width - 5;
                        }
                        
                        if (rect.bottom > windowHeight) {
                            this.tooltip.y = event.clientY - rect.height - 5;
                        }
                    });
                },
                hideTooltip() {
                    this.tooltip.show = false;
                },
                
                // 區域管理相關方法
                saveArea() {
                    if (this.selectedCells.length === 0 || !this.newArea.name) {
                        alert('請選擇單元格並輸入區域名稱');
                        return;
                    }
                    
                    if (this.editingAreaIndex >= 0) {
                        // 更新現有區域
                        this.areas[this.editingAreaIndex] = {
                            ...this.areas[this.editingAreaIndex],
                            name: this.newArea.name,
                            color: this.newArea.color,
                            showName: false,
                            cells: [...this.selectedCells]
                        };
                    } else {
                        // 新增區域
                        this.areas.push({
                            id: Date.now(),
                            name: this.newArea.name,
                            color: this.newArea.color,
                            showName: false,
                            cells: [...this.selectedCells]
                        });
                    }
                    
                    // 清空選擇並退出區域選擇模式
                    this.clearSelection();
                    this.isAreaSelectionMode = false;
                },
                editArea(area) {
                    // 找到區域索引
                    const index = this.areas.findIndex(a => a.id === area.id);
                    if (index === -1) return;
                    
                    // 設置編輯狀態
                    this.editingAreaIndex = index;
                    this.selectedCells = [...area.cells];
                    this.newArea.name = area.name;
                    this.newArea.color = area.color;
                    this.newArea.showName = area.showName;
                },
                deleteArea(index) {
                    if (confirm('確定要刪除此區域嗎？')) {
                        this.areas.splice(index, 1);
                    }
                },
                clearAllAreas() {
                    if (confirm('確定要刪除所有區域嗎？')) {
                        this.areas = [];
                        this.clearSelection();
                    }
                },
                getCellAreaInfo(index) {
                    // 檢查單元格是否屬於某個區域
                    for (const area of this.areas) {
                        if (area.cells.includes(index)) {
                            return {
                                name: area.name,
                                color: area.color,
                                showName: area.showName
                            };
                        }
                    }
                    return null;
                },
                
                isOverlappingCell(index) {
                    // 檢查單元格是否屬於多個區域
                    let areaCount = 0;
                    for (const area of this.areas) {
                        if (area.cells.includes(index)) {
                            areaCount++;
                            if (areaCount > 1) {
                                return true;
                            }
                        }
                    }
                    return false;
                },
                
                // 顏色透明度處理
                addOpacity(color, opacity) {
                    // 如果是 hex 格式，轉換為 rgba
                    if (color.startsWith('#')) {
                        const r = parseInt(color.slice(1, 3), 16);
                        const g = parseInt(color.slice(3, 5), 16);
                        const b = parseInt(color.slice(5, 7), 16);
                        return `rgba(${r}, ${g}, ${b}, ${opacity})`;
                    }
                    
                    // 如果已經是 rgba 格式，替換透明度
                    if (color.startsWith('rgba')) {
                        return color.replace(/rgba\((.+?), .+?\)/, `rgba($1, ${opacity})`);
                    }
                    
                    // 如果是 rgb 格式，轉換為 rgba
                    if (color.startsWith('rgb')) {
                        return color.replace('rgb', 'rgba').replace(')', `, ${opacity})`);
                    }
                    
                    // 其他情況，返回原始顏色
                    return color;
                },
                
                // 元件庫方法
                getSmartImageUrl(url) {
                    if (url.startsWith('http://localhost') || url.startsWith('http://127.0.0.1')) {
                        return url;
                    }
                    return `/proxy-image?url=${encodeURIComponent(url)}`;
                },

                rehydrateStaticComponent(component) {
                    // 檢測檔案類型
                    if (!component.fileType) {
                        const url = component.spritesheetUrl || '';
                        const extension = url.split('.').pop().toLowerCase();
                        component.fileType = extension === 'gif' ? 'gif' : 
                                            ['jpg', 'jpeg'].includes(extension) ? 'jpg' : 'png';
                    }
                    
                    // 如果是 GIF 檔案，不需要提取
                    if (component.fileType === 'gif') {
                        return;
                    }
                    
                    const url = component.spritesheetUrl;
                    const sourceRect = component.sourceRect;
                    if (!url || !sourceRect) {
                        console.error('靜態元件缺少 spritesheetUrl 或 sourceRect', component);
                        return;
                    }

                    try {
                        const spritesheet = new Image();
                        spritesheet.crossOrigin = 'Anonymous';
                        spritesheet.src = this.getSmartImageUrl(url);

                        spritesheet.onload = () => {
                            try {
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');
                                const { x, y, w, h } = sourceRect;
                                canvas.width = w;
                                canvas.height = h;
                                ctx.drawImage(spritesheet, x, y, w, h, 0, 0, w, h);
                                this.$set(component, 'imageData', canvas.toDataURL());
                            } catch (e) {
                                console.error('處理元件圖像失敗:', e);
                            }
                        };
                        spritesheet.onerror = (e) => {
                            console.error(`無法載入 spritesheet: ${url}`, e);
                        };
                    } catch (e) {
                        console.error('重新處理靜態元件時發生錯誤:', e);
                    }
                },
                
                loadComponentFromJson() {
                    try {
                        const component = JSON.parse(this.componentJsonInput);
                        if (!component.id || !component.name || !component.type) {
                            alert('JSON 無效或缺少必要欄位 (id, name, type)');
                            return;
                        }

                        if (this.loadedComponents.some(c => c.id === component.id)) {
                            alert('此 ID 的元件已存在。');
                            return;
                        }

                        this.loadedComponents.push(component);
                        this.saveComponentsToLocalStorage();
                        this.componentJsonInput = ''; 

                        const newComponent = this.loadedComponents[this.loadedComponents.length - 1];
                        if (newComponent.type === 'static') {
                            this.rehydrateStaticComponent(newComponent);
                        }
                    } catch (e) {
                        alert('解析 JSON 失敗: ' + e.message);
                    }
                },

                saveComponentsToLocalStorage() {
                    try {
                        localStorage.setItem('map-editor-components', JSON.stringify(this.loadedComponents));
                    } catch (e) {
                        console.error('保存元件到 localStorage 失敗', e);
                    }
                },

                loadComponentsFromLocalStorage() {
                    const saved = localStorage.getItem('map-editor-components');
                    if (saved) {
                        try {
                            const components = JSON.parse(saved);
                            this.loadedComponents = components;
                            this.loadedComponents.forEach(component => {
                                if (component.type === 'static' && !component.imageData) {
                                    this.rehydrateStaticComponent(component);
                                }
                            });
                        } catch(e) {
                            console.error('從 localStorage 載入元件失敗', e);
                            this.loadedComponents = [];
                        }
                    }
                },

                mainAnimationLoop(currentTime) {
                    Object.keys(this.animationStates).forEach(stateKey => {
                        const state = this.animationStates[stateKey];
                        if (!state || !state.componentRef) return;

                        const component = state.componentRef;
                        const spritesheetUrl = component.animation.spritesheetUrl;
                        if (!spritesheetUrl) return;

                        let sourceImage = this.spritesheetCache[spritesheetUrl];
                        if (!sourceImage) {
                            const newImg = new Image();
                            newImg.crossOrigin = "Anonymous";
                            newImg.src = this.getSmartImageUrl(spritesheetUrl);
                            this.$set(this.spritesheetCache, spritesheetUrl, newImg);
                            return;
                        }
                        
                        if (!sourceImage.complete || sourceImage.naturalHeight === 0) {
                            return;
                        }

                        const speed = component.animation.speed || 100;

                        if (currentTime - state.lastTime > speed) {
                            state.lastTime = currentTime;
                            
                            let nextFrame = state.currentFrame + 1;
                            if (nextFrame >= component.animation.frames.length) {
                                nextFrame = component.animation.loop ? 0 : state.currentFrame;
                            }
                            state.currentFrame = nextFrame;
                            
                            const frameInfo = component.animation.frames[state.currentFrame];
                            const canvasRef = this.$refs[state.canvasName];

                            if (canvasRef && canvasRef[0]) {
                                const canvas = canvasRef[0];
                                const ctx = canvas.getContext('2d');
                                
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                
                                try {
                                    ctx.drawImage(
                                        sourceImage,
                                        frameInfo.x, frameInfo.y, frameInfo.w, frameInfo.h,
                                        0, 0, canvas.width, canvas.height
                                    );
                                } catch (e) {
                                    console.error('繪製動畫幀時發生錯誤:', e);
                                }
                            }
                        }
                    });

                    this.mainLoopId = requestAnimationFrame(this.mainAnimationLoop);
                },

                // 提示框相關方法
                showTooltip(event, index) {
                    if (!this.editMode) return;
                    
                    const row = Math.floor(index / this.gridCols);
                    const col = index % this.gridCols;
                    
                    // 計算網格座標 (X, Y)
                    const cellSize = 32;
                    const gap = 1;
                    const gridX = col * (cellSize + gap);
                    const gridY = row * (cellSize + gap);
                    
                    // 獲取所有包含此單元格的區域
                    const cellAreas = this.getAllCellAreas(index);
                    
                    // 設置提示框內容
                    this.tooltip.row = row;
                    this.tooltip.col = col;
                    this.tooltip.gridX = gridX;
                    this.tooltip.gridY = gridY;
                    this.tooltip.areas = cellAreas;
                    
                    // 設置提示框位置 (更靠近滑鼠位置)
                    this.tooltip.x = event.clientX + 5;
                    this.tooltip.y = event.clientY + 5;
                    
                    // 顯示提示框
                    this.tooltip.show = true;
                    
                    // 確保提示框不超出視窗
                    this.$nextTick(() => {
                        const tooltip = document.querySelector('.grid-tooltip');
                        if (!tooltip) return;
                        
                        const rect = tooltip.getBoundingClientRect();
                        const windowWidth = window.innerWidth;
                        const windowHeight = window.innerHeight;
                        
                        if (rect.right > windowWidth) {
                            this.tooltip.x = event.clientX - rect.width - 5;
                        }
                        
                        if (rect.bottom > windowHeight) {
                            this.tooltip.y = event.clientY - rect.height - 5;
                        }
                    });
                },
                hideTooltip() {
                    this.tooltip.show = false;
                },
                
                // 本地儲存相關方法
                getAllCellAreas(index) {
                    // 獲取單元格所屬的所有區域
                    const cellAreas = [];
                    for (const area of this.areas) {
                        if (area.cells.includes(index)) {
                            cellAreas.push({
                                id: area.id,
                                name: area.name,
                                color: area.color
                            });
                        }
                    }
                    return cellAreas;
                },
                getCellAreas(index) {
                    // 獲取單元格所屬的所有區域
                    const cellAreas = [];
                    for (const area of this.areas) {
                        if (area.cells.includes(index)) {
                            cellAreas.push({
                                id: area.id,
                                name: area.name,
                                color: area.color
                            });
                        }
                    }
                    return cellAreas;
                }
            }
        });
    </script>
</body>
</html>