<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¶²æ ¼æ¸¬è©¦é é¢</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
    <style>
        body {
            font-family: 'Microsoft JhengHei', Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: white;
        }
        .container {
            display: flex;
            height: 100vh;
        }
        .left-panel {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: auto;
        }
        .right-panel {
            width: 300px;
            padding: 20px;
            background-color: #f9f9f9;
            border-left: 1px solid #ddd;
            overflow-y: auto;
        }
        .resizer {
            width: 8px;
            background-color: #ddd;
            cursor: col-resize;
            position: relative;
        }
        .resizer:hover, .resizer.active {
            background-color: #aaa;
        }
        .resizer::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 30px;
            background-color: #888;
        }
        .grid-container {
            position: relative;
            margin-top: 20px;
            border: 1px solid #ccc;
            overflow: auto;
            max-height: calc(100vh - 60px);
        }
        .grid {
            display: grid;
            grid-gap: 1px;
            background-color: #f0f0f0;
            position: relative;
        }
        .grid-cell {
            background-color: rgba(200, 200, 200, 0.3);
            border: 1px solid rgba(150, 150, 150, 0.3);
            box-sizing: border-box;
        }
        .grid-cell.hidden {
            background-color: transparent;
            border: none;
        }
        .grid-cell.selected {
            background-color: rgba(100, 149, 237, 0.5);
            border: 1px solid rgba(65, 105, 225, 0.8);
        }
        .grid-cell.area-cell {
            position: relative;
        }
        .area-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2;
            font-size: 10px;
            color: white;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.7);
            overflow: hidden;
            pointer-events: none;
        }
        .area-overlap {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                45deg,
                rgba(255, 255, 255, 0.4),
                rgba(255, 255, 255, 0.4) 3px,
                rgba(0, 0, 0, 0.2) 3px,
                rgba(0, 0, 0, 0.2) 6px
            );
            z-index: 10;
            pointer-events: none;
            border: 1px dashed rgba(255, 255, 255, 0.8);
            box-sizing: border-box;
        }
        .controls {
            margin-bottom: 20px;
            width: 100%;
            text-align: center;
        }
        button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
        }
        button:hover {
            background-color: #45a049;
        }
        button.secondary {
            background-color: #2196F3;
        }
        button.secondary:hover {
            background-color: #0b7dda;
        }
        button.danger {
            background-color: #f44336;
        }
        button.danger:hover {
            background-color: #d32f2f;
        }
        button.primary {
            background-color: #4CAF50;
        }
        button.primary:hover {
            background-color: #45a049;
        }
        button.active {
            background-color: #ff9800;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }
        button.active:hover {
            background-color: #e68a00;
        }
        .area-form {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #fff;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .form-group input, .form-group select {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .area-list {
            margin-top: 20px;
        }
        .area-item {
            padding: 10px;
            margin-bottom: 10px;
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            position: relative;
        }
        .area-item h4 {
            margin-top: 0;
            margin-bottom: 5px;
        }
        .area-item p {
            margin: 5px 0;
            font-size: 14px;
        }
        .area-item .actions {
            position: absolute;
            top: 10px;
            right: 10px;
        }
        .area-item .actions button {
            padding: 3px 8px;
            font-size: 12px;
            margin-left: 5px;
        }
        .color-preview {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 3px;
            vertical-align: middle;
            margin-right: 5px;
        }
        .grid-tooltip {
            position: fixed;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 1000;
            pointer-events: none;
            white-space: nowrap;
            transition: opacity 0.2s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        .grid-tooltip .tooltip-title {
            font-weight: bold;
            margin-bottom: 3px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 2px;
        }
        .grid-tooltip .tooltip-content {
            margin-top: 3px;
        }
        .grid-tooltip .area-name {
            color: #8adbff;
        }
        .grid-tooltip .area-list {
            margin-top: 5px;
            padding-top: 5px;
            border-top: 1px dotted rgba(255, 255, 255, 0.3);
        }
        .grid-tooltip .area-tag {
            display: inline-block;
            margin: 2px;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 10px;
            color: white;
        }
        .area-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-gap: 10px;
        }
        .area-grid-item {
            padding: 10px;
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            position: relative;
            display: flex;
            flex-direction: column;
        }
        .area-color-header {
            height: 30px;
            border-radius: 4px 4px 0 0;
            margin: -10px -10px 10px -10px;
        }
        .area-grid-item h4 {
            margin-top: 5px;
            margin-bottom: 5px;
            text-align: center;
        }
        .area-grid-item p {
            margin: 3px 0;
            font-size: 12px;
            text-align: center;
        }
        .area-grid-item .actions {
            margin-top: auto;
            display: flex;
            justify-content: space-between;
            padding-top: 8px;
        }
        .area-grid-item .actions button {
            flex: 1;
            padding: 3px 0;
            font-size: 12px;
            margin: 0 2px;
        }
        .event-log-container {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #fff;
            max-height: 300px;
            overflow-y: auto;
        }
        .event-log-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .event-log-entry {
            font-family: monospace;
            font-size: 12px;
            padding: 3px 0;
            border-bottom: 1px solid #eee;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .event-log-entry:last-child {
            border-bottom: none;
        }
        .component-loader {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #fff;
        }
        .component-loader textarea {
            width: 100%;
            min-height: 150px;
            box-sizing: border-box;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 8px;
            font-family: monospace;
        }
        .component-library {
            margin-top: 20px;
        }
        .library-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(64px, 1fr));
            gap: 10px;
            margin-top: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #fff;
            min-height: 80px;
        }
        .library-item {
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 64px;
            position: relative;
            overflow: hidden;
        }
        .library-item img, .library-item canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        .library-item-name {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(0,0,0,0.5);
            color: white;
            font-size: 10px;
            padding: 2px 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            align-items: center;
        }

        .library-item-name > span {
            flex: 1;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-right: 20px; /* Make space for button */
        }

        .copy-component-button {
            background: transparent;
            border: none;
            color: white;
            cursor: pointer;
            padding: 0 5px;
            margin: 0;
            font-size: 12px;
            flex-shrink: 0;
            line-height: 1;
        }
        .copy-component-button:hover {
            transform: scale(1.1);
        }

        /* Slide-in notification styles */
        .slide-in-notification {
            position: fixed;
            top: 20px;
            right: -350px;
            min-width: 250px;
            padding: 15px 20px;
            background-color: #4CAF50;
            color: white;
            border-radius: 8px 0 0 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            font-size: 14px;
            z-index: 2000;
            transition: right 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }
        .slide-in-notification.show {
            right: 0;
        }
        .slide-in-notification.error {
            background-color: #f44336;
        }

        /* Template Manager Styles */
        .template-manager {
            margin-bottom: 25px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #fff;
        }
        .template-manager h3 {
            margin-top: 0;
            text-align: center;
        }
        .template-actions {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
        }
        .template-actions button {
            flex: 1;
            margin: 0 3px;
            padding: 8px 5px;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        /* é›²ç«¯åŒæ­¥ç›¸é—œæ¨£å¼ */
        .cloud-sync {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px dashed #ccc;
        }
        .cloud-sync h4 {
            margin-top: 0;
            text-align: center;
            font-size: 16px;
        }
        .template-list {
            max-height: 200px;
            overflow-y: auto;
            margin: 10px 0;
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 5px;
        }
        .template-list-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .template-list-item:hover {
            background-color: #f5f5f5;
        }
        .template-list-item:last-child {
            border-bottom: none;
        }
        .template-list-item .template-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .template-list-item .template-actions {
            display: flex;
            margin-top: 0;
        }
        .template-list-item .template-actions button {
            padding: 2px 5px;
            font-size: 12px;
            margin-left: 5px;
        }
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top-color: #09f;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
            vertical-align: middle;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Styles for component categorization */
        .category-group {
            margin-bottom: 20px;
        }
        .category-group:last-child {
            margin-bottom: 0;
        }
        .category-title {
            font-size: 14px;
            color: #666;
            border-bottom: 1px solid #ddd;
            padding-bottom: 8px;
            margin-top: 0;
            margin-bottom: 12px;
            font-weight: bold;
            text-transform: uppercase;
        }
        .name-group {
            margin-bottom: 15px;
        }
        .name-group-title {
            margin: 0 0 8px 0;
            font-weight: 500;
            color: #333;
        }
        .components-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(64px, 1fr));
            gap: 10px;
        }
        .empty-category-placeholder, .empty-state {
            font-size: 13px;
            color: #888;
            padding: 20px 5px;
            text-align: center;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="container">
            <div class="left-panel">
                <div class="grid-container" ref="gridContainer">
                    <div class="grid" :style="gridContainerStyle">
                        <div
                            v-for="index in gridCellCount"
                            :key="'grid-cell-' + index"
                            :id="'grid-cell-' + index"
                            class="grid-cell"
                            :class="{ 
                                hidden: !editMode, 
                                selected: isSelectedCell(index - 1),
                                'area-cell': getCellAreaInfo(index - 1)
                            }"
                            @click="onCellClick(index - 1, $event)"
                            @mousedown="startAreaSelection(index - 1, $event)"
                            @mouseover="updateAreaSelection(index - 1); showTooltip($event, index - 1)"
                            @mouseout="hideTooltip"
                            @mouseup="endAreaSelection($event)"
                        >
                            <template v-if="editMode">
                                <div 
                                    v-for="(area, areaIndex) in getCellAreas(index - 1)"
                                    :key="'area-' + area.id + '-' + index"
                                    class="area-overlay"
                                    :style="{ 
                                        backgroundColor: addOpacity(area.color, getCellAreas(index - 1).length > 1 ? 0.25 : 0.5),
                                        zIndex: 2 + areaIndex,
                                        opacity: 1 - (areaIndex * 0.1)
                                    }"
                                >
                                </div>
                                <div
                                    v-if="isOverlappingCell(index - 1)"
                                    class="area-overlap"
                                >
                                </div>
                            </template>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="resizer" 
                 @mousedown="startResize" 
                 :class="{ active: isResizing }"></div>
            
            <div class="right-panel" ref="rightPanel">
                <div class="template-manager">
                    <h3>æ¨¡æ¿ç®¡ç†</h3>
                    <div class="form-group">
                        <label for="templateSelect">é¸æ“‡æ¨¡æ¿</label>
                        <select id="templateSelect" v-model="selectedTemplate" @change="loadTemplate">
                            <option value="">-- é¸æ“‡ä¸€å€‹æ¨¡æ¿ --</option>
                            <option v-for="(template, name) in templates" :key="name" :value="name">{{ name }}</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="templateName">æ¨¡æ¿åç¨±</label>
                        <input type="text" id="templateName" v-model="currentTemplateName" placeholder="è¼¸å…¥æ–°æ¨¡æ¿åç¨±æˆ–é¸æ“‡ä¸Šæ–¹æ¨¡æ¿">
                    </div>
                    <div class="template-actions">
                        <button class="primary" @click="saveTemplate">å„²å­˜/æ›´æ–°</button>
                        <button class="danger" @click="deleteTemplate" :disabled="!selectedTemplate">åˆªé™¤</button>
                        <button class="secondary" @click="createNewScene">æ–°å ´æ™¯</button>
                    </div>
                    
                    <div class="cloud-sync">
                        <h4>é›²ç«¯åŒæ­¥</h4>
                        <div class="form-group">
                            <button class="primary" @click="saveTemplateToDatabase" :disabled="!currentTemplateName">
                                <span v-if="isLoading.save" class="loading-spinner"></span>
                                ä¿å­˜åˆ°è³‡æ–™åº«
                            </button>
                            <button class="secondary" @click="loadTemplatesFromDatabase">
                                <span v-if="isLoading.load" class="loading-spinner"></span>
                                å¾è³‡æ–™åº«è¼‰å…¥
                            </button>
                        </div>
                        
                        <div v-if="dbTemplates.length > 0" class="template-list">
                            <div v-for="template in dbTemplates" :key="template.id" class="template-list-item">
                                <div class="template-name">{{ template.name }}</div>
                                <div class="template-actions">
                                    <button class="secondary" @click="loadTemplateFromDatabase(template.id)">
                                        è¼‰å…¥
                                    </button>
                                    <button class="danger" @click="deleteTemplateFromDatabase(template.id)">
                                        åˆªé™¤
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div v-else-if="dbTemplatesLoaded" class="empty-state">
                            <p>è³‡æ–™åº«ä¸­å°šç„¡æ¨¡æ¿ã€‚</p>
                        </div>
                    </div>
                </div>

                <div class="controls">
                    <button @click="toggleEditMode">{{ editMode ? 'é—œé–‰ç·¨è¼¯æ¨¡å¼' : 'é–‹å•Ÿç·¨è¼¯æ¨¡å¼' }}</button>
                    <button 
                        class="primary" 
                        :class="{ active: isAreaSelectionMode }"
                        @click="toggleAreaSelectionMode">
                        {{ isAreaSelectionMode ? 'å–æ¶ˆæ–°å¢å€åŸŸ' : 'æ–°å¢å€åŸŸ' }}
                    </button>
                    <button class="secondary" @click="clearSelection" v-if="selectedCells.length > 0">æ¸…é™¤é¸æ“‡</button>
                    <button class="danger" @click="clearAllAreas" v-if="areas.length > 0">æ¸…é™¤æ‰€æœ‰å€åŸŸ</button>
                </div>
                
                <div class="area-form" v-if="selectedCells.length > 0">
                    <h3>{{ editingAreaIndex >= 0 ? 'ç·¨è¼¯å€åŸŸ' : 'æ–°å¢å€åŸŸ' }}</h3>
                    <div class="form-group">
                        <label for="areaName">å€åŸŸåç¨±</label>
                        <input type="text" id="areaName" v-model="newArea.name" placeholder="è¼¸å…¥å€åŸŸåç¨±">
                    </div>
                    <div class="form-group">
                        <label for="areaColor">å€åŸŸé¡è‰²</label>
                        <input type="color" id="areaColor" v-model="newArea.color">
                    </div>
                    <div class="form-group">
                        <label>å·²é¸æ“‡å–®å…ƒæ ¼æ•¸: {{ selectedCells.length }}</label>
                    </div>
                    <button @click="saveArea">å„²å­˜å€åŸŸ</button>
                    <button class="secondary" @click="clearSelection">å–æ¶ˆ</button>
                </div>
                
                <div class="area-list" v-if="areas.length > 0">
                    <h3>å·²å„²å­˜å€åŸŸ</h3>
                    <div class="area-grid">
                        <div class="area-grid-item" v-for="(area, index) in areas" :key="area.id">
                            <div class="area-color-header" :style="{ backgroundColor: area.color }"></div>
                            <h4>{{ area.name }}</h4>
                            <p>å–®å…ƒæ ¼æ•¸: {{ area.cells.length }}</p>
                            <div class="actions">
                                <button class="secondary" @click="editArea(area)">ç·¨è¼¯</button>
                                <button class="danger" @click="deleteArea(index)">åˆªé™¤</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="component-loader">
                    <h3>è¼‰å…¥å…ƒä»¶</h3>
                    <div class="form-group">
                        <label for="componentJson">å…ƒä»¶ JSON</label>
                        <textarea id="componentJson" v-model="componentJsonInput" rows="3" placeholder="åœ¨é€™è£¡è²¼ä¸Šå…ƒä»¶çš„ JSON"></textarea>
                    </div>
                    <button @click="loadComponentFromJson">åŠ å…¥å…ƒä»¶</button>
                </div>

                <div class="component-library">
                    <h3>å…ƒä»¶åº«</h3>
                    <div v-if="loadedComponents.length > 0">
                        <div v-for="category in categories" :key="category" class="category-group">
                            <h4 class="category-title">{{ category }}</h4>
                            <div v-if="categorizedComponents[category] && Object.keys(categorizedComponents[category]).length > 0">
                                <div v-for="(components, name) in categorizedComponents[category]" :key="name" class="name-group">
                                    <h5 class="name-group-title">{{ name }} ({{ components.length }})</h5>
                                    <div class="components-list">
                                        <div v-for="component in components" :key="component.id" class="library-item">
                                            
                                            <!-- GIF æª”æ¡ˆç›´æ¥ä½¿ç”¨åŸå§‹ URL -->
                                            <img v-if="component.type === 'static' && component.fileType === 'gif'"
                                                 :src="component.spritesheetUrl"
                                                 :alt="component.name">
                                                 
                                            <!-- å…¶ä»–éœæ…‹å…ƒä»¶ä½¿ç”¨ imageData -->
                                            <img v-else-if="component.type === 'static' && component.imageData"
                                                 :src="component.imageData"
                                                 :alt="component.name">
                                            
                                            <canvas v-if="component.type === 'animation'"
                                                   :ref="'anim-canvas-library-' + component.id"
                                                   :width="component.width"
                                                   :height="component.height"></canvas>

                                            <div class="library-item-name">
                                                <button class="copy-component-button" @click.stop="copyComponentInfo(component)" title="è¤‡è£½å…ƒä»¶è³‡è¨Š">ğŸ“‹</button>
                                                <span>{{ component.subcategory || component.name }}</span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="empty-category-placeholder" v-else>
                                (æ­¤åˆ†é¡æš«ç„¡å…ƒä»¶)
                            </div>
                        </div>
                    </div>
                    <div v-else class="empty-state">
                        <p>å°šæœªè¼‰å…¥ä»»ä½•å…ƒä»¶ã€‚</p>
                    </div>
                </div>
                
                <!-- æ·»åŠ äº‹ä»¶æ—¥èªŒé¡¯ç¤ºå€åŸŸ -->
                <div class="event-log-container">
                    <div class="event-log-title">
                        <h3>äº‹ä»¶æ—¥èªŒ</h3>
                        <button class="secondary" @click="eventLog = []">æ¸…é™¤æ—¥èªŒ</button>
                    </div>
                    <div v-if="eventLog.length > 0">
                        <div v-for="(entry, index) in eventLog" :key="index" class="event-log-entry">
                            {{ entry }}
                        </div>
                    </div>
                    <div v-else class="empty-state">
                        <p>å°šç„¡äº‹ä»¶æ—¥èªŒã€‚</p>
                    </div>
                </div>
            </div>
        </div>
        
        <div 
            v-if="tooltip.show" 
            class="grid-tooltip" 
            :style="{ left: tooltip.x + 'px', top: tooltip.y + 'px' }"
        >
            <div class="tooltip-title">ä½ç½®: è¡Œ {{ tooltip.row + 1 }}, åˆ— {{ tooltip.col + 1 }}</div>
            <div class="tooltip-content">åº§æ¨™: X {{ tooltip.gridX }}, Y {{ tooltip.gridY }}</div>
            <div class="tooltip-content area-list" v-if="tooltip.areas && tooltip.areas.length > 0">
                å€åŸŸ:
                <div v-for="(area, index) in tooltip.areas" :key="index">
                    <span class="area-tag" :style="{ backgroundColor: addOpacity(area.color, 0.7) }">
                        {{ area.name }}
                    </span>
                </div>
            </div>
        </div>

        <div class="slide-in-notification" :class="{ show: notification.show, error: !notification.success }">
            {{ notification.message }}
        </div>
    </div>

    <script>
        new Vue({
            el: '#app',
            data: {
                gridCols: 10,
                gridRows: 24,
                editMode: true,
                lastClickedCell: null,
                isResizing: false,
                notification: {
                    show: false,
                    message: '',
                    success: true,
                    timer: null
                },

                // æ¨¡æ¿ç®¡ç†
                templates: {},
                selectedTemplate: '',
                currentTemplateName: '',
                
                // é›²ç«¯åŒæ­¥ç›¸é—œ
                dbTemplates: [],
                dbTemplatesLoaded: false,
                isLoading: {
                    save: false,
                    load: false,
                    delete: false
                },
                
                // å€åŸŸé¸æ“‡ç›¸é—œ
                isSelecting: false,
                selectionStart: -1,
                selectedCells: [],
                isAreaSelectionMode: false,
                
                // æç¤ºæ¡†ç›¸é—œ
                tooltip: {
                    show: false,
                    x: 0,
                    y: 0,
                    row: 0,
                    col: 0,
                    gridX: 0,
                    gridY: 0,
                    areaName: '',
                    areas: []
                },
                
                // å€åŸŸè³‡æ–™
                areas: [],
                newArea: {
                    name: '',
                    color: '#4CAF50',
                    showName: false,
                    cells: []
                },
                editingAreaIndex: -1,

                // å…ƒä»¶åº«ç›¸é—œ
                categories: ['äººç‰©', 'ç‰©å“', 'èƒŒæ™¯', 'UIç•Œé¢', 'ç‰¹æ•ˆ'],
                componentJsonInput: '{\n  "id": 185,\n  "name": "å–µå’ªç›’å­",\n  "type": "animation",\n  "width": 29,\n  "height": 31,\n  "category": "äººç‰©",\n  "subcategory": "",\n  "scale": 1,\n  "displayScale": 100,\n  "anchor": "bottom-left",\n  "createdAt": "2025-07-11T01:32:56.637Z",\n  "animation": {\n    "spritesheetUrl": "https://sunnyyummy.onrender.com/uploads/1752213327712-12692.png",\n    "speed": 100,\n    "loop": true,\n    "frames": [\n      {\n        "x": 1,\n        "y": 1,\n        "w": 29,\n        "h": 31\n      },\n      {\n        "x": 32,\n        "y": 2,\n        "w": 31,\n        "h": 30\n      },\n      {\n        "x": 65,\n        "y": 2,\n        "w": 29,\n        "h": 29\n      },\n      {\n        "x": 97,\n        "y": 1,\n        "w": 29,\n        "h": 30\n      }\n    ]\n  }\n}',
                loadedComponents: [],
                animationStates: {},
                spritesheetCache: {},
                mainLoopId: null,
                // æ·»åŠ æ—¥èªŒè¨˜éŒ„
                eventLog: [],
                maxLogEntries: 20,
            },
            watch: {
                areas: {
                    handler() { this.saveCurrentStateToLocalStorage(); },
                    deep: true
                },
                loadedComponents: {
                    handler(newComponents) {
                        const activeLibIndexes = new Set();
                        newComponents.forEach((component, index) => {
                            if (component.type === 'animation') {
                                const stateKey = `library-${component.id}`;
                                activeLibIndexes.add(stateKey);
                                if (!this.animationStates[stateKey]) {
                                    this.$set(this.animationStates, stateKey, {
                                        currentFrame: 0,
                                        lastTime: 0,
                                        componentRef: component,
                                        canvasName: `anim-canvas-library-${component.id}`
                                    });
                                }
                            }
                        });
                        
                        Object.keys(this.animationStates).forEach(key => {
                            if (key.startsWith('library-')) {
                                const id = key.replace('library-', '');
                                if (!newComponents.some(c => c.id == id)) {
                                    this.$delete(this.animationStates, key);
                                }
                            }
                        });
                        this.saveCurrentStateToLocalStorage();
                    },
                    deep: true
                }
            },
            computed: {
                gridCellCount() {
                    return this.gridCols * this.gridRows;
                },
                gridContainerStyle() {
                    const cellSize = 32;
                    const gap = 1;
                    const width = this.gridCols * cellSize + (this.gridCols - 1) * gap;
                    const height = this.gridRows * cellSize + (this.gridRows - 1) * gap;
                    return {
                        gridTemplateColumns: `repeat(${this.gridCols}, ${cellSize}px)`,
                        gridTemplateRows: `repeat(${this.gridRows}, ${cellSize}px)`,
                        width: `${width}px`,
                        height: `${height}px`,
                    };
                },
                categorizedComponents() {
                    const grouped = {};
                    this.loadedComponents.forEach((component) => {
                        const category = component.category || 'ç‰©å“';
                        const name = component.name || 'æœªå‘½å';

                        if (!grouped[category]) {
                            grouped[category] = {};
                        }
                        
                        if (!grouped[category][name]) {
                            grouped[category][name] = [];
                        }
                        grouped[category][name].push(component);
                    });
                    return grouped;
                },
            },
            mounted() {
                // è¨­ç½®å³å´é¢æ¿åˆå§‹å¯¬åº¦
                this.$refs.rightPanel.style.width = '300px';
                
                this.loadTemplatesFromLocalStorage();
                this.loadCurrentStateFromLocalStorage();
                
                // å˜—è©¦è¼‰å…¥è³‡æ–™åº«æ¨¡æ¿åˆ—è¡¨
                this.loadTemplatesFromDatabase();

                // å•Ÿå‹•ä¸»å‹•ç•«å¾ªç’°
                this.mainAnimationLoop();
                
                // æ·»åŠ æ–‡æª”é»æ“Šäº‹ä»¶è™•ç†å™¨
                document.addEventListener('click', this.handleDocumentClick);
                
                // æ·»åŠ å…¨å±€æ»‘é¼ äº‹ä»¶ç›£è½å™¨
                document.addEventListener('mouseup', this.handleGlobalMouseUp);
            },
            beforeDestroy() {
                if (this.mainLoopId) {
                    cancelAnimationFrame(this.mainLoopId);
                }
                
                // ç§»é™¤æ–‡æª”é»æ“Šäº‹ä»¶è™•ç†å™¨
                document.removeEventListener('click', this.handleDocumentClick);
                
                // ç§»é™¤å…¨å±€æ»‘é¼ äº‹ä»¶ç›£è½å™¨
                document.removeEventListener('mouseup', this.handleGlobalMouseUp);
            },
            methods: {
                showNotification(message, success = true, duration = 3000) {
                    if (this.notification.timer) {
                        clearTimeout(this.notification.timer);
                    }
                    this.notification.message = message;
                    this.notification.success = success;
                    this.notification.show = true;
                    this.notification.timer = setTimeout(() => {
                        this.notification.show = false;
                    }, duration);
                },

                copyComponentInfo(component) {
                    const textToCopy = `unit_components\nid=${component.id}\nname=${component.name}`;
                    
                    navigator.clipboard.writeText(textToCopy)
                        .then(() => {
                            this.showNotification(`'${component.name}' çš„è³‡è¨Šå·²è¤‡è£½ï¼`);
                        })
                        .catch(err => {
                            console.error('è¤‡è£½å¤±æ•—:', err);
                            this.showNotification('è¤‡è£½å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç€è¦½å™¨æ¬Šé™ã€‚', false);
                        });
                },

                // æ¨¡æ¿ç®¡ç†æ–¹æ³•
                saveTemplate() {
                    if (!this.currentTemplateName) {
                        this.showNotification('è«‹è¼¸å…¥æ¨¡æ¿åç¨±', false);
                        return;
                    }
                    const isUpdating = !!this.templates[this.currentTemplateName];
                    if (isUpdating) {
                        if (!confirm(`ç¢ºå®šè¦æ›´æ–°æ¨¡æ¿ '${this.currentTemplateName}' å—ï¼Ÿ`)) {
                            return;
                        }
                    }

                    this.$set(this.templates, this.currentTemplateName, {
                        areas: JSON.parse(JSON.stringify(this.areas)),
                        components: JSON.parse(JSON.stringify(this.loadedComponents)),
                        updatedAt: new Date().toISOString()
                    });

                    this.saveTemplatesToLocalStorage();
                    this.selectedTemplate = this.currentTemplateName;
                    this.showNotification(`æ¨¡æ¿ '${this.currentTemplateName}' å·²${isUpdating ? 'æ›´æ–°' : 'å„²å­˜'}ï¼`);
                },

                // è³‡æ–™åº«åŒæ­¥æ–¹æ³•
                saveTemplateToDatabase() {
                    if (!this.currentTemplateName) {
                        this.showNotification('è«‹è¼¸å…¥æ¨¡æ¿åç¨±', false);
                        return;
                    }

                    this.isLoading.save = true;

                    // æº–å‚™æ¨¡æ¿æ•¸æ“š
                    const templateData = {
                        name: this.currentTemplateName,
                        description: `åœ°åœ–æ¨¡æ¿: ${this.currentTemplateName}`,
                        grid_cols: this.gridCols,
                        grid_rows: this.gridRows,
                        areas: this.areas.map(area => ({
                            name: area.name,
                            color: area.color,
                            show_name: area.showName,
                            cells: area.cells
                        })),
                        components: this.loadedComponents.map(comp => ({
                            component_id: comp.id,
                            grid_x: comp.grid_x || 0,
                            grid_y: comp.grid_y || 0,
                            position_x: comp.position_x || 0,
                            position_y: comp.position_y || 0,
                            z_index: comp.z_index || 0
                        }))
                    };

                    // ç™¼é€åˆ°å¾Œç«¯ API
                    fetch('/api/map-templates', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(templateData)
                    })
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('ä¿å­˜æ¨¡æ¿åˆ°è³‡æ–™åº«å¤±æ•—');
                        }
                        return response.json();
                    })
                    .then(data => {
                        this.showNotification(`æ¨¡æ¿ '${this.currentTemplateName}' å·²ä¿å­˜åˆ°è³‡æ–™åº«ï¼`);
                        this.loadTemplatesFromDatabase(); // é‡æ–°è¼‰å…¥æ¨¡æ¿åˆ—è¡¨
                    })
                    .catch(error => {
                        console.error('ä¿å­˜æ¨¡æ¿åˆ°è³‡æ–™åº«å¤±æ•—:', error);
                        this.showNotification('ä¿å­˜æ¨¡æ¿åˆ°è³‡æ–™åº«å¤±æ•—: ' + error.message, false);
                    })
                    .finally(() => {
                        this.isLoading.save = false;
                    });
                },

                loadTemplatesFromDatabase() {
                    this.isLoading.load = true;
                    
                    fetch('/api/map-templates')
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('è¼‰å…¥æ¨¡æ¿åˆ—è¡¨å¤±æ•—');
                            }
                            return response.json();
                        })
                        .then(data => {
                            this.dbTemplates = data || [];
                            this.dbTemplatesLoaded = true;
                        })
                        .catch(error => {
                            console.error('è¼‰å…¥æ¨¡æ¿åˆ—è¡¨å¤±æ•—:', error);
                            this.showNotification('è¼‰å…¥æ¨¡æ¿åˆ—è¡¨å¤±æ•—: ' + error.message, false);
                            this.dbTemplates = [];
                            this.dbTemplatesLoaded = false;
                        })
                        .finally(() => {
                            this.isLoading.load = false;
                        });
                },

                loadTemplateFromDatabase(templateId) {
                    this.isLoading.load = true;
                    
                    fetch(`/api/map-templates/${templateId}`)
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('è¼‰å…¥æ¨¡æ¿å¤±æ•—');
                            }
                            return response.json();
                        })
                        .then(data => {
                            // è¨­ç½®ç¶²æ ¼å¤§å°
                            this.gridCols = data.grid_cols || 10;
                            this.gridRows = data.grid_rows || 24;
                            
                            // è¨­ç½®å€åŸŸ
                            this.areas = data.areas.map(area => ({
                                id: area.id || Date.now() + Math.floor(Math.random() * 1000),
                                name: area.name,
                                color: area.color,
                                showName: area.show_name || false,
                                cells: area.cells || []
                            }));
                            
                            // è¼‰å…¥å…ƒä»¶ (é€™è£¡éœ€è¦ç¢ºä¿å…ƒä»¶å·²åœ¨å…ƒä»¶åº«ä¸­)
                            // é€™éƒ¨åˆ†å¯èƒ½éœ€è¦æ ¹æ“šå¯¦éš›æƒ…æ³èª¿æ•´
                            const componentIds = data.components.map(c => c.component_id);
                            
                            // å¦‚æœéœ€è¦ï¼Œå¯ä»¥å…ˆè¼‰å…¥é€™äº›å…ƒä»¶
                            // é€™è£¡ç°¡åŒ–è™•ç†ï¼Œåƒ…è¨­ç½®ä½ç½®ä¿¡æ¯
                            data.components.forEach(comp => {
                                const existingComp = this.loadedComponents.find(c => c.id === comp.component_id);
                                if (existingComp) {
                                    existingComp.grid_x = comp.grid_x;
                                    existingComp.grid_y = comp.grid_y;
                                    existingComp.position_x = comp.position_x;
                                    existingComp.position_y = comp.position_y;
                                    existingComp.z_index = comp.z_index;
                                }
                            });
                            
                            this.currentTemplateName = data.name;
                            this.showNotification(`æ¨¡æ¿ '${data.name}' å·²å¾è³‡æ–™åº«è¼‰å…¥ã€‚`);
                        })
                        .catch(error => {
                            console.error('è¼‰å…¥æ¨¡æ¿å¤±æ•—:', error);
                            this.showNotification('è¼‰å…¥æ¨¡æ¿å¤±æ•—: ' + error.message, false);
                        })
                        .finally(() => {
                            this.isLoading.load = false;
                        });
                },

                deleteTemplateFromDatabase(templateId) {
                    if (!confirm('ç¢ºå®šè¦å¾è³‡æ–™åº«åˆªé™¤æ­¤æ¨¡æ¿å—ï¼Ÿæ­¤æ“ä½œç„¡æ³•æ’¤éŠ·ã€‚')) {
                        return;
                    }
                    
                    fetch(`/api/map-templates/${templateId}`, {
                        method: 'DELETE'
                    })
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('åˆªé™¤æ¨¡æ¿å¤±æ•—');
                            }
                            return response.json();
                        })
                        .then(data => {
                            this.showNotification('æ¨¡æ¿å·²å¾è³‡æ–™åº«åˆªé™¤ã€‚');
                            this.loadTemplatesFromDatabase(); // é‡æ–°è¼‰å…¥æ¨¡æ¿åˆ—è¡¨
                        })
                        .catch(error => {
                            console.error('åˆªé™¤æ¨¡æ¿å¤±æ•—:', error);
                            this.showNotification('åˆªé™¤æ¨¡æ¿å¤±æ•—: ' + error.message, false);
                        });
                },

                loadTemplate() {
                    if (!this.selectedTemplate) {
                        this.currentTemplateName = '';
                        return;
                    }
                    const template = this.templates[this.selectedTemplate];
                    if (template) {
                        if (this.areas.length > 0 || this.loadedComponents.length > 0) {
                            if (!confirm(`è¼‰å…¥æ¨¡æ¿ '${this.selectedTemplate}' å°‡æœƒè¦†è“‹ç›®å‰æœªå„²å­˜çš„è®Šæ›´ï¼Œç¢ºå®šå—ï¼Ÿ`)) {
                                this.$nextTick(() => {
                                    this.selectedTemplate = this.findCurrentTemplateName() || '';
                                });
                                return;
                            }
                        }

                        this.areas = JSON.parse(JSON.stringify(template.areas || []));
                        
                        const newComponents = JSON.parse(JSON.stringify(template.components || []));
                        this.loadedComponents = newComponents;
                        
                        // Rehydrate static components
                        this.$nextTick(() => {
                           newComponents.forEach(component => {
                                if (component.type === 'static' && !component.imageData) {
                                    this.rehydrateStaticComponent(component);
                                }
                            });
                        });
                        
                        this.currentTemplateName = this.selectedTemplate;
                        this.showNotification(`æ¨¡æ¿ '${this.selectedTemplate}' å·²è¼‰å…¥ã€‚`);
                    }
                },

                deleteTemplate() {
                    if (!this.selectedTemplate) return;
                    if (confirm(`ç¢ºå®šè¦æ°¸ä¹…åˆªé™¤æ¨¡æ¿ '${this.selectedTemplate}' å—ï¼Ÿ`)) {
                        this.$delete(this.templates, this.selectedTemplate);
                        this.saveTemplatesToLocalStorage();

                        this.showNotification(`æ¨¡æ¿ '${this.selectedTemplate}' å·²åˆªé™¤ã€‚`);
                        
                        if (this.currentTemplateName === this.selectedTemplate) {
                            this.createNewScene();
                        }
                        this.selectedTemplate = '';
                    }
                },

                createNewScene() {
                    this.areas = [];
                    this.loadedComponents = [];
                    this.selectedTemplate = '';
                    this.currentTemplateName = '';
                    this.clearSelection();
                    this.showNotification('å·²å»ºç«‹æ–°å ´æ™¯ã€‚');
                },

                findCurrentTemplateName() {
                    // This is a helper to find if the current state matches any saved template
                    for (const name in this.templates) {
                        const template = this.templates[name];
                        if (JSON.stringify(template.areas) === JSON.stringify(this.areas) &&
                            JSON.stringify(template.components) === JSON.stringify(this.loadedComponents)) {
                            return name;
                        }
                    }
                    return null;
                },

                // æœ¬åœ°å„²å­˜é‡æ§‹
                saveTemplatesToLocalStorage() {
                    try {
                        localStorage.setItem('map-editor-templates', JSON.stringify(this.templates));
                    } catch (e) {
                        console.error('ä¿å­˜æ¨¡æ¿åˆ° localStorage å¤±æ•—', e);
                    }
                },

                loadTemplatesFromLocalStorage() {
                    const savedTemplates = localStorage.getItem('map-editor-templates');
                    if (savedTemplates) {
                        try {
                            this.templates = JSON.parse(savedTemplates);
                        } catch(e) {
                            console.error('å¾ localStorage è¼‰å…¥æ¨¡æ¿å¤±æ•—', e);
                            this.templates = {};
                        }
                    } else {
                        this.templates = {};
                    }
                },
                
                saveCurrentStateToLocalStorage() {
                    try {
                        const state = {
                            areas: this.areas,
                            components: this.loadedComponents
                        };
                        localStorage.setItem('map-editor-current-state', JSON.stringify(state));
                    } catch (e) {
                        console.error('ä¿å­˜ç•¶å‰ç‹€æ…‹åˆ° localStorage å¤±æ•—', e);
                        this.showNotification('ç„¡æ³•ä¿å­˜ç•¶å‰ç‹€æ…‹åˆ°æœ¬åœ°å„²å­˜', false);
                    }
                },

                loadCurrentStateFromLocalStorage() {
                    try {
                        const savedState = localStorage.getItem('map-editor-current-state');
                        if (savedState) {
                            try {
                                const state = JSON.parse(savedState);
                                this.areas = state.areas || [];
                                const components = state.components || [];
                                this.loadedComponents = components;
                                
                                // ç¢ºä¿æ‰€æœ‰éœæ…‹å…ƒä»¶éƒ½è¢«æ­£ç¢ºè™•ç†
                                this.$nextTick(() => {
                                    this.loadedComponents.forEach(component => {
                                        if (component.type === 'static' && !component.imageData) {
                                            this.rehydrateStaticComponent(component);
                                        }
                                    });
                                });
                            } catch(e) {
                                console.error('å¾ localStorage è¼‰å…¥ç•¶å‰ç‹€æ…‹å¤±æ•—', e);
                                this.areas = [];
                                this.loadedComponents = [];
                            }
                        } else {
                            // å¦‚æœæ²’æœ‰ä¿å­˜çš„ç‹€æ…‹ï¼Œåˆå§‹åŒ–ç‚ºç©º
                            this.areas = [];
                            this.loadedComponents = [];
                        }
                    } catch (e) {
                        console.error('è®€å– localStorage å¤±æ•—', e);
                        this.areas = [];
                        this.loadedComponents = [];
                    }
                },

                // æ·»åŠ æ—¥èªŒè¨˜éŒ„æ–¹æ³•
                logEvent(eventName, details) {
                    const timestamp = new Date().toISOString().substr(11, 12); // æ™‚é–“æ ¼å¼ HH:MM:SS.mmm
                    const logEntry = `${timestamp} - ${eventName}: ${JSON.stringify(details)}`;
                    console.log(logEntry);
                    this.eventLog.unshift(logEntry);
                    
                    // ä¿æŒæ—¥èªŒä¸è¶…éæœ€å¤§æ¢ç›®æ•¸
                    if (this.eventLog.length > this.maxLogEntries) {
                        this.eventLog.pop();
                    }
                },
                
                // è™•ç†æ–‡æª”é»æ“Šäº‹ä»¶
                handleDocumentClick(event) {
                    // æª¢æŸ¥é»æ“Šæ˜¯å¦åœ¨ç¶²æ ¼å®¹å™¨å…§
                    const gridContainer = this.$refs.gridContainer;
                    const isClickInGrid = gridContainer && gridContainer.contains(event.target);
                    
                    // æª¢æŸ¥é»æ“Šæ˜¯å¦åœ¨å€åŸŸè¡¨å–®å…§
                    const areaForm = document.querySelector('.area-form');
                    const isClickInForm = areaForm && areaForm.contains(event.target);
                    
                    // ç§»é™¤æ—¥èªŒåµéŒ¯ä»£ç¢¼
                    
                    // å¦‚æœé»æ“Šä¸åœ¨ç¶²æ ¼æˆ–è¡¨å–®å…§ï¼Œä¸”ä¸æ˜¯åœ¨ç·¨è¼¯å€åŸŸï¼Œå‰‡ä¸æ¸…é™¤é¸æ“‡
                    if (!isClickInGrid && !isClickInForm && this.editingAreaIndex < 0) {
                        // ä¸åšä»»ä½•äº‹æƒ…ï¼Œä¿æŒé¸æ“‡ç‹€æ…‹
                        return;
                    }
                },
                
                // è™•ç†å…¨å±€æ»‘é¼ æŠ¬èµ·äº‹ä»¶
                handleGlobalMouseUp(event) {
                    // æª¢æŸ¥æ˜¯å¦åœ¨é¸æ“‡æ¨¡å¼ä¸”æœ‰é¸ä¸­çš„å–®å…ƒæ ¼
                    if (this.isAreaSelectionMode && this.selectedCells.length > 0) {
                        this.logEvent('handleGlobalMouseUp', {
                            selectedCellsCount: this.selectedCells.length,
                            target: event.target.tagName
                        });
                        
                        // ä¸åšä»»ä½•æ¸…é™¤æ“ä½œï¼Œä¿æŒé¸æ“‡ç‹€æ…‹
                    }
                },
                toggleEditMode() {
                    this.editMode = !this.editMode;
                },
                onCellClick(index, event) {
                    // é˜²æ­¢äº‹ä»¶å†’æ³¡ï¼Œé¿å…å…¶ä»–äº‹ä»¶è™•ç†å™¨è¢«è§¸ç™¼
                    if (event) {
                        event.stopPropagation();
                    }
                    
                    const row = Math.floor(index / this.gridCols);
                    const col = index % this.gridCols;
                    this.lastClickedCell = `è¡Œ: ${row + 1}, åˆ—: ${col + 1} (ç´¢å¼•: ${index})`;
                    
                    this.logEvent('onCellClick', { 
                        index, 
                        row: row + 1, 
                        col: col + 1,
                        isAreaSelectionMode: this.isAreaSelectionMode,
                        selectedCellsCount: this.selectedCells.length
                    });
                    
                    // å¦‚æœåœ¨å€åŸŸé¸æ“‡æ¨¡å¼ä¸‹ï¼Œå–®æ“Šå¯ä»¥åˆ‡æ›å–®å…ƒæ ¼é¸æ“‡ç‹€æ…‹
                    if (this.editMode && this.isAreaSelectionMode) {
                        // æª¢æŸ¥æ˜¯å¦æ˜¯å¾ mousedown/mouseup äº‹ä»¶éˆä¸­è§¸ç™¼çš„é»æ“Š
                        // å¦‚æœæ˜¯ï¼Œå‰‡ä¸åŸ·è¡Œé¸æ“‡åˆ‡æ›é‚è¼¯ï¼Œé¿å…èˆ‡ startAreaSelection/endAreaSelection è¡çª
                        const now = Date.now();
                        if (!this._lastMouseUpTime || now - this._lastMouseUpTime > 50) {
                            const isSelected = this.isSelectedCell(index);
                            if (isSelected && this.selectedCells.length > 1) {
                                // å¦‚æœå·²é¸ä¸­ä¸”ä¸æ˜¯å–®æ ¼é¸æ“‡ï¼Œå‰‡å–æ¶ˆé¸ä¸­
                                this.selectedCells = this.selectedCells.filter(cellIndex => cellIndex !== index);
                            } else if (!isSelected) {
                                // å¦‚æœæœªé¸ä¸­ï¼Œå‰‡é¸ä¸­
                                this.selectedCells = [index]; // ç›´æ¥æ›¿æ›ç‚ºå–®ä¸€é¸æ“‡
                                this.newArea.cells = [index];
                                this.newArea.name = `å€åŸŸ ${this.areas.length + 1}`;
                            }
                            // å¦‚æœå·²é¸ä¸­ä¸”æ˜¯å–®æ ¼é¸æ“‡ï¼Œå‰‡ä¸åšä»»ä½•äº‹æƒ…ï¼Œä¿æŒé¸æ“‡ç‹€æ…‹
                        }
                        
                        this.logEvent('onCellClick-afterSelection', { 
                            selectedCellsCount: this.selectedCells.length,
                            newAreaCellsCount: this.newArea.cells.length
                        });
                    }
                },
                startResize(event) {
                    this.isResizing = true;
                    document.addEventListener('mousemove', this.resize);
                    document.addEventListener('mouseup', this.stopResize);
                },
                resize(event) {
                    if (!this.isResizing) return;
                    
                    // è¨ˆç®—å³å´é¢æ¿çš„æ–°å¯¬åº¦
                    const containerWidth = document.querySelector('.container').offsetWidth;
                    const newRightWidth = containerWidth - event.clientX;
                    
                    // è¨­ç½®æœ€å°å¯¬åº¦
                    const minWidth = 200;
                    if (newRightWidth < minWidth) return;
                    
                    // è¨­ç½®æœ€å¤§å¯¬åº¦
                    const maxWidth = containerWidth - 400; // ç¢ºä¿å·¦å´è‡³å°‘æœ‰400px
                    if (newRightWidth > maxWidth) return;
                    
                    this.$refs.rightPanel.style.width = `${newRightWidth}px`;
                },
                stopResize() {
                    this.isResizing = false;
                    document.removeEventListener('mousemove', this.resize);
                    document.removeEventListener('mouseup', this.stopResize);
                },
                
                // å€åŸŸé¸æ“‡ç›¸é—œæ–¹æ³•
                startAreaSelection(index, event) {
                    // é˜²æ­¢äº‹ä»¶å†’æ³¡ï¼Œé¿å…å…¶ä»–äº‹ä»¶è™•ç†å™¨è¢«è§¸ç™¼
                    if (event) {
                        event.stopPropagation();
                    }
                    
                    this.logEvent('startAreaSelection', { 
                        index, 
                        editMode: this.editMode, 
                        isAreaSelectionMode: this.isAreaSelectionMode
                    });
                    
                    if (!this.editMode || !this.isAreaSelectionMode) return;
                    this.isSelecting = true;
                    this.selectionStart = index;
                    this.selectedCells = [index];
                    
                    // é å…ˆè¨­ç½®å€åŸŸè³‡æ–™ï¼Œä»¥ä¾¿å³ä½¿æ˜¯å–®æ ¼é¸æ“‡ä¹Ÿèƒ½ä¿æŒ
                    this.newArea.cells = [index];
                    this.newArea.name = `å€åŸŸ ${this.areas.length + 1}`;
                    
                    this.logEvent('startAreaSelection-afterSetup', { 
                        isSelecting: this.isSelecting,
                        selectionStart: this.selectionStart,
                        selectedCellsCount: this.selectedCells.length,
                        newAreaCellsCount: this.newArea.cells.length
                    });
                },
                updateAreaSelection(index) {
                    if (!this.isSelecting || !this.editMode || !this.isAreaSelectionMode) return;
                    
                    this.logEvent('updateAreaSelection', { 
                        index, 
                        isSelecting: this.isSelecting,
                        selectedCellsCount: this.selectedCells.length
                    });
                    
                    // è¨ˆç®—é¸æ“‡ç¯„åœ
                    const startRow = Math.floor(this.selectionStart / this.gridCols);
                    const startCol = this.selectionStart % this.gridCols;
                    const currentRow = Math.floor(index / this.gridCols);
                    const currentCol = index % this.gridCols;
                    
                    const minRow = Math.min(startRow, currentRow);
                    const maxRow = Math.max(startRow, currentRow);
                    const minCol = Math.min(startCol, currentCol);
                    const maxCol = Math.max(startCol, currentCol);
                    
                    // æ¸…ç©ºç•¶å‰é¸æ“‡
                    this.selectedCells = [];
                    
                    // æ·»åŠ ç¯„åœå…§çš„æ‰€æœ‰å–®å…ƒæ ¼
                    for (let row = minRow; row <= maxRow; row++) {
                        for (let col = minCol; col <= maxCol; col++) {
                            const cellIndex = row * this.gridCols + col;
                            this.selectedCells.push(cellIndex);
                        }
                    }
                    
                    this.logEvent('updateAreaSelection-afterCalculation', { 
                        selectedCellsCount: this.selectedCells.length,
                        selectionArea: `${maxRow-minRow+1}x${maxCol-minCol+1}`
                    });
                },
                endAreaSelection(event) {
                    // é˜²æ­¢äº‹ä»¶å†’æ³¡
                    if (event) {
                        event.stopPropagation();
                    }
                    
                    this.isSelecting = false;
                    this._lastMouseUpTime = Date.now(); // è¨˜éŒ„æœ€å¾Œä¸€æ¬¡ mouseup æ™‚é–“
                    
                    this.logEvent('endAreaSelection', { 
                        selectedCellsCount: this.selectedCells.length,
                        newAreaCellsCount: this.newArea.cells.length
                    });
                    
                    // ç¢ºä¿é¸æ“‡ä¸æœƒå› ç‚ºæ»‘é¼ æ”¾é–‹è€Œæ¶ˆå¤±
                    if (this.selectedCells.length > 0) {
                        // ä¿æŒé¸æ“‡ç‹€æ…‹ï¼Œä¸åšä»»ä½•æ”¹è®Š
                        this.newArea.cells = [...this.selectedCells];
                        
                        // ç¢ºä¿å€åŸŸè¡¨å–®é¡¯ç¤º
                        this.$nextTick(() => {
                            // å¼·åˆ¶æ›´æ–°è¦–åœ–
                            this.$forceUpdate();
                        });
                    }
                    
                    this.logEvent('endAreaSelection-afterSetup', { 
                        isSelecting: this.isSelecting,
                        selectedCellsCount: this.selectedCells.length,
                        newAreaCellsCount: this.newArea.cells.length
                    });
                },
                isSelectedCell(index) {
                    return this.selectedCells.includes(index);
                },
                clearSelection() {
                    this.logEvent('clearSelection', {
                        selectedCellsCount: this.selectedCells.length,
                        editingAreaIndex: this.editingAreaIndex,
                        caller: new Error().stack.split('\n')[2].trim()
                    });
                    
                    this.selectedCells = [];
                    this.newArea.name = '';
                    this.newArea.cells = [];
                    this.editingAreaIndex = -1;
                },
                
                toggleAreaSelectionMode() {
                    this.isAreaSelectionMode = !this.isAreaSelectionMode;
                    if (!this.isAreaSelectionMode) {
                        this.clearSelection();
                    }
                },
                
                // æç¤ºæ¡†ç›¸é—œæ–¹æ³•
                showTooltip(event, index) {
                    if (!this.editMode) return;
                    
                    const row = Math.floor(index / this.gridCols);
                    const col = index % this.gridCols;
                    
                    // è¨ˆç®—ç¶²æ ¼åº§æ¨™ (X, Y)
                    const cellSize = 32;
                    const gap = 1;
                    const gridX = col * (cellSize + gap);
                    const gridY = row * (cellSize + gap);
                    
                    // ç²å–æ‰€æœ‰åŒ…å«æ­¤å–®å…ƒæ ¼çš„å€åŸŸ
                    const cellAreas = this.getAllCellAreas(index);
                    
                    // è¨­ç½®æç¤ºæ¡†å…§å®¹
                    this.tooltip.row = row;
                    this.tooltip.col = col;
                    this.tooltip.gridX = gridX;
                    this.tooltip.gridY = gridY;
                    this.tooltip.areas = cellAreas;
                    
                    // è¨­ç½®æç¤ºæ¡†ä½ç½® (æ›´é è¿‘æ»‘é¼ ä½ç½®)
                    this.tooltip.x = event.clientX + 5;
                    this.tooltip.y = event.clientY + 5;
                    
                    // é¡¯ç¤ºæç¤ºæ¡†
                    this.tooltip.show = true;
                    
                    // ç¢ºä¿æç¤ºæ¡†ä¸è¶…å‡ºè¦–çª—
                    this.$nextTick(() => {
                        const tooltip = document.querySelector('.grid-tooltip');
                        if (!tooltip) return;
                        
                        const rect = tooltip.getBoundingClientRect();
                        const windowWidth = window.innerWidth;
                        const windowHeight = window.innerHeight;
                        
                        if (rect.right > windowWidth) {
                            this.tooltip.x = event.clientX - rect.width - 5;
                        }
                        
                        if (rect.bottom > windowHeight) {
                            this.tooltip.y = event.clientY - rect.height - 5;
                        }
                    });
                },
                hideTooltip() {
                    this.tooltip.show = false;
                },
                
                // å€åŸŸç®¡ç†ç›¸é—œæ–¹æ³•
                saveArea() {
                    if (this.selectedCells.length === 0 || !this.newArea.name) {
                        alert('è«‹é¸æ“‡å–®å…ƒæ ¼ä¸¦è¼¸å…¥å€åŸŸåç¨±');
                        return;
                    }
                    
                    if (this.editingAreaIndex >= 0) {
                        // æ›´æ–°ç¾æœ‰å€åŸŸ
                        this.areas[this.editingAreaIndex] = {
                            ...this.areas[this.editingAreaIndex],
                            name: this.newArea.name,
                            color: this.newArea.color,
                            showName: false,
                            cells: [...this.selectedCells]
                        };
                    } else {
                        // æ–°å¢å€åŸŸ
                        this.areas.push({
                            id: Date.now(),
                            name: this.newArea.name,
                            color: this.newArea.color,
                            showName: false,
                            cells: [...this.selectedCells]
                        });
                    }
                    
                    // æ¸…ç©ºé¸æ“‡ä¸¦é€€å‡ºå€åŸŸé¸æ“‡æ¨¡å¼
                    this.clearSelection();
                    this.isAreaSelectionMode = false;
                },
                editArea(area) {
                    // æ‰¾åˆ°å€åŸŸç´¢å¼•
                    const index = this.areas.findIndex(a => a.id === area.id);
                    if (index === -1) return;
                    
                    // è¨­ç½®ç·¨è¼¯ç‹€æ…‹
                    this.editingAreaIndex = index;
                    this.selectedCells = [...area.cells];
                    this.newArea.name = area.name;
                    this.newArea.color = area.color;
                    this.newArea.showName = area.showName;
                },
                deleteArea(index) {
                    if (confirm('ç¢ºå®šè¦åˆªé™¤æ­¤å€åŸŸå—ï¼Ÿ')) {
                        this.areas.splice(index, 1);
                    }
                },
                clearAllAreas() {
                    if (confirm('ç¢ºå®šè¦åˆªé™¤æ‰€æœ‰å€åŸŸå—ï¼Ÿ')) {
                        this.areas = [];
                        this.clearSelection();
                    }
                },
                getCellAreaInfo(index) {
                    // æª¢æŸ¥å–®å…ƒæ ¼æ˜¯å¦å±¬æ–¼æŸå€‹å€åŸŸ
                    for (const area of this.areas) {
                        if (area.cells.includes(index)) {
                            return {
                                name: area.name,
                                color: area.color,
                                showName: area.showName
                            };
                        }
                    }
                    return null;
                },
                
                isOverlappingCell(index) {
                    // æª¢æŸ¥å–®å…ƒæ ¼æ˜¯å¦å±¬æ–¼å¤šå€‹å€åŸŸ
                    let areaCount = 0;
                    for (const area of this.areas) {
                        if (area.cells.includes(index)) {
                            areaCount++;
                            if (areaCount > 1) {
                                return true;
                            }
                        }
                    }
                    return false;
                },
                
                // é¡è‰²é€æ˜åº¦è™•ç†
                addOpacity(color, opacity) {
                    // å¦‚æœæ˜¯ hex æ ¼å¼ï¼Œè½‰æ›ç‚º rgba
                    if (color.startsWith('#')) {
                        const r = parseInt(color.slice(1, 3), 16);
                        const g = parseInt(color.slice(3, 5), 16);
                        const b = parseInt(color.slice(5, 7), 16);
                        return `rgba(${r}, ${g}, ${b}, ${opacity})`;
                    }
                    
                    // å¦‚æœå·²ç¶“æ˜¯ rgba æ ¼å¼ï¼Œæ›¿æ›é€æ˜åº¦
                    if (color.startsWith('rgba')) {
                        return color.replace(/rgba\((.+?), .+?\)/, `rgba($1, ${opacity})`);
                    }
                    
                    // å¦‚æœæ˜¯ rgb æ ¼å¼ï¼Œè½‰æ›ç‚º rgba
                    if (color.startsWith('rgb')) {
                        return color.replace('rgb', 'rgba').replace(')', `, ${opacity})`);
                    }
                    
                    // å…¶ä»–æƒ…æ³ï¼Œè¿”å›åŸå§‹é¡è‰²
                    return color;
                },
                
                // å…ƒä»¶åº«æ–¹æ³•
                getSmartImageUrl(url) {
                    if (url.startsWith('http://localhost') || url.startsWith('http://127.0.0.1')) {
                        return url;
                    }
                    return `/proxy-image?url=${encodeURIComponent(url)}`;
                },

                rehydrateStaticComponent(component) {
                    // æª¢æ¸¬æª”æ¡ˆé¡å‹
                    if (!component.fileType) {
                        const url = component.spritesheetUrl || '';
                        const extension = url.split('.').pop().toLowerCase();
                        component.fileType = extension === 'gif' ? 'gif' : 
                                            ['jpg', 'jpeg'].includes(extension) ? 'jpg' : 'png';
                    }
                    
                    // å¦‚æœæ˜¯ GIF æª”æ¡ˆï¼Œä¸éœ€è¦æå–
                    if (component.fileType === 'gif') {
                        return;
                    }
                    
                    const url = component.spritesheetUrl;
                    const sourceRect = component.sourceRect;
                    if (!url || !sourceRect) {
                        console.error('éœæ…‹å…ƒä»¶ç¼ºå°‘ spritesheetUrl æˆ– sourceRect', component);
                        return;
                    }

                    try {
                        const spritesheet = new Image();
                        spritesheet.crossOrigin = 'Anonymous';
                        spritesheet.src = this.getSmartImageUrl(url);

                        spritesheet.onload = () => {
                            try {
                                const canvas = document.createElement('canvas');
                                const ctx = canvas.getContext('2d');
                                const { x, y, w, h } = sourceRect;
                                canvas.width = w;
                                canvas.height = h;
                                ctx.drawImage(spritesheet, x, y, w, h, 0, 0, w, h);
                                this.$set(component, 'imageData', canvas.toDataURL());
                            } catch (e) {
                                console.error('è™•ç†å…ƒä»¶åœ–åƒå¤±æ•—:', e);
                            }
                        };
                        spritesheet.onerror = (e) => {
                            console.error(`ç„¡æ³•è¼‰å…¥ spritesheet: ${url}`, e);
                        };
                    } catch (e) {
                        console.error('é‡æ–°è™•ç†éœæ…‹å…ƒä»¶æ™‚ç™¼ç”ŸéŒ¯èª¤:', e);
                    }
                },
                
                loadComponentFromJson() {
                    try {
                        const component = JSON.parse(this.componentJsonInput);
                        if (!component.id || !component.name || !component.type) {
                            alert('JSON ç„¡æ•ˆæˆ–ç¼ºå°‘å¿…è¦æ¬„ä½ (id, name, type)');
                            return;
                        }

                        if (this.loadedComponents.some(c => c.id === component.id)) {
                            alert('æ­¤ ID çš„å…ƒä»¶å·²å­˜åœ¨ã€‚');
                            return;
                        }

                        this.loadedComponents.push(component);
                        this.saveComponentsToLocalStorage();
                        this.componentJsonInput = ''; 

                        const newComponent = this.loadedComponents[this.loadedComponents.length - 1];
                        if (newComponent.type === 'static') {
                            this.rehydrateStaticComponent(newComponent);
                        }
                    } catch (e) {
                        alert('è§£æ JSON å¤±æ•—: ' + e.message);
                    }
                },

                saveComponentsToLocalStorage() {
                    try {
                        localStorage.setItem('map-editor-components', JSON.stringify(this.loadedComponents));
                    } catch (e) {
                        console.error('ä¿å­˜å…ƒä»¶åˆ° localStorage å¤±æ•—', e);
                    }
                },

                loadComponentsFromLocalStorage() {
                    const saved = localStorage.getItem('map-editor-components');
                    if (saved) {
                        try {
                            const components = JSON.parse(saved);
                            this.loadedComponents = components;
                            this.loadedComponents.forEach(component => {
                                if (component.type === 'static' && !component.imageData) {
                                    this.rehydrateStaticComponent(component);
                                }
                            });
                        } catch(e) {
                            console.error('å¾ localStorage è¼‰å…¥å…ƒä»¶å¤±æ•—', e);
                            this.loadedComponents = [];
                        }
                    }
                },

                mainAnimationLoop(currentTime) {
                    Object.keys(this.animationStates).forEach(stateKey => {
                        const state = this.animationStates[stateKey];
                        if (!state || !state.componentRef) return;

                        const component = state.componentRef;
                        const spritesheetUrl = component.animation.spritesheetUrl;
                        if (!spritesheetUrl) return;

                        let sourceImage = this.spritesheetCache[spritesheetUrl];
                        if (!sourceImage) {
                            const newImg = new Image();
                            newImg.crossOrigin = "Anonymous";
                            newImg.src = this.getSmartImageUrl(spritesheetUrl);
                            this.$set(this.spritesheetCache, spritesheetUrl, newImg);
                            return;
                        }
                        
                        if (!sourceImage.complete || sourceImage.naturalHeight === 0) {
                            return;
                        }

                        const speed = component.animation.speed || 100;

                        if (currentTime - state.lastTime > speed) {
                            state.lastTime = currentTime;
                            
                            let nextFrame = state.currentFrame + 1;
                            if (nextFrame >= component.animation.frames.length) {
                                nextFrame = component.animation.loop ? 0 : state.currentFrame;
                            }
                            state.currentFrame = nextFrame;
                            
                            const frameInfo = component.animation.frames[state.currentFrame];
                            const canvasRef = this.$refs[state.canvasName];

                            if (canvasRef && canvasRef[0]) {
                                const canvas = canvasRef[0];
                                const ctx = canvas.getContext('2d');
                                
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                
                                try {
                                    ctx.drawImage(
                                        sourceImage,
                                        frameInfo.x, frameInfo.y, frameInfo.w, frameInfo.h,
                                        0, 0, canvas.width, canvas.height
                                    );
                                } catch (e) {
                                    console.error('ç¹ªè£½å‹•ç•«å¹€æ™‚ç™¼ç”ŸéŒ¯èª¤:', e);
                                }
                            }
                        }
                    });

                    this.mainLoopId = requestAnimationFrame(this.mainAnimationLoop);
                },

                // æç¤ºæ¡†ç›¸é—œæ–¹æ³•
                showTooltip(event, index) {
                    if (!this.editMode) return;
                    
                    const row = Math.floor(index / this.gridCols);
                    const col = index % this.gridCols;
                    
                    // è¨ˆç®—ç¶²æ ¼åº§æ¨™ (X, Y)
                    const cellSize = 32;
                    const gap = 1;
                    const gridX = col * (cellSize + gap);
                    const gridY = row * (cellSize + gap);
                    
                    // ç²å–æ‰€æœ‰åŒ…å«æ­¤å–®å…ƒæ ¼çš„å€åŸŸ
                    const cellAreas = this.getAllCellAreas(index);
                    
                    // è¨­ç½®æç¤ºæ¡†å…§å®¹
                    this.tooltip.row = row;
                    this.tooltip.col = col;
                    this.tooltip.gridX = gridX;
                    this.tooltip.gridY = gridY;
                    this.tooltip.areas = cellAreas;
                    
                    // è¨­ç½®æç¤ºæ¡†ä½ç½® (æ›´é è¿‘æ»‘é¼ ä½ç½®)
                    this.tooltip.x = event.clientX + 5;
                    this.tooltip.y = event.clientY + 5;
                    
                    // é¡¯ç¤ºæç¤ºæ¡†
                    this.tooltip.show = true;
                    
                    // ç¢ºä¿æç¤ºæ¡†ä¸è¶…å‡ºè¦–çª—
                    this.$nextTick(() => {
                        const tooltip = document.querySelector('.grid-tooltip');
                        if (!tooltip) return;
                        
                        const rect = tooltip.getBoundingClientRect();
                        const windowWidth = window.innerWidth;
                        const windowHeight = window.innerHeight;
                        
                        if (rect.right > windowWidth) {
                            this.tooltip.x = event.clientX - rect.width - 5;
                        }
                        
                        if (rect.bottom > windowHeight) {
                            this.tooltip.y = event.clientY - rect.height - 5;
                        }
                    });
                },
                hideTooltip() {
                    this.tooltip.show = false;
                },
                
                // æœ¬åœ°å„²å­˜ç›¸é—œæ–¹æ³•
                getAllCellAreas(index) {
                    // ç²å–å–®å…ƒæ ¼æ‰€å±¬çš„æ‰€æœ‰å€åŸŸ
                    const cellAreas = [];
                    for (const area of this.areas) {
                        if (area.cells.includes(index)) {
                            cellAreas.push({
                                id: area.id,
                                name: area.name,
                                color: area.color
                            });
                        }
                    }
                    return cellAreas;
                },
                getCellAreas(index) {
                    // ç²å–å–®å…ƒæ ¼æ‰€å±¬çš„æ‰€æœ‰å€åŸŸ
                    const cellAreas = [];
                    for (const area of this.areas) {
                        if (area.cells.includes(index)) {
                            cellAreas.push({
                                id: area.id,
                                name: area.name,
                                color: area.color
                            });
                        }
                    }
                    return cellAreas;
                }
            }
        });
    </script>
</body>
</html>