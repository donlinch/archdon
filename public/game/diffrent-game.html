<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>找出 5 個不同之處（帶簡易編輯器）</title>
  <style>
    body {
      font-family: sans-serif;
      background-color: #fffbe6;
      text-align: center;
      margin: 0;
      padding: 10px;
    }
    h1, h2 {
      color: #ff8c00;
      margin: 15px 0;
    }
    .tabs {
      display: flex;
      justify-content: center;
      margin: 20px 0;
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 100;
      flex-direction: column;
      gap: 10px;
    }
    .tab {
      padding: 10px 20px;
      background-color: #ff8c00;
      color: white;
      border: none;
      cursor: pointer;
      border-radius: 30px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      text-align: center;
      transition: all 0.3s ease;
      font-weight: bold;
    }
    .tab.active {
      background-color: #e67e00;
      transform: scale(1.1);
    }
    .tab-content {
      display: none;
    }
    .tab-content.active {
      display: block;
    }
    .game-container {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 10px;
      flex-wrap: wrap;
    }
    .image-container {
      position: relative;
      margin-bottom: 10px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
      border-radius: 12px;
      overflow: hidden;
    }
    .image-container img {
      width: 90vw;
      max-width: 400px;
      height: auto;
      border: none;
      border-radius: 10px;
      display: block;
    }
    .image-label {
      font-size: 16px;
      font-weight: bold;
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: rgba(255, 255, 255, 0.8);
      padding: 3px 8px;
      border-radius: 4px;
      z-index: 5;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .dot {
      position: absolute;
      width: 30px;
      height: 30px;
      border: 2px solid red;
      border-radius: 50%;
      cursor: pointer;
      transform: translate(-50%, -50%);
    }
    .dot.found {
      background-color: rgba(255, 0, 0, 0.5);
      animation: pulse 1s infinite alternate;
    }
    .dot.hint {
      border: 2px dashed gold;
      background-color: rgba(255, 255, 0, 0.3);
      box-shadow: 0 0 10px gold;
    }
    .editor-dot {
      position: absolute;
      width: 30px;
      height: 30px;
      border: 2px solid red;
      border-radius: 50%;
      background-color: rgba(255, 0, 0, 0.3);
      cursor: move;
      transform: translate(-50%, -50%);
    }
    .editor-dot.reference {
      background-color: rgba(255, 0, 0, 0.2);
      border: 2px dashed red;
      cursor: default;
    }
    .label {
      position: absolute;
      font-weight: bold;
      color: red;
      background-color: white;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      line-height: 20px;
      font-size: 12px;
      transform: translate(-50%, -50%);
      display: none;
    }
    .label.show {
      display: block;
    }
    .game-status-container {
      width: auto;
      max-width: 450px;
      margin: 0 auto 10px;
      padding: 8px 15px;
      background-color: #fff8e1;
      border-radius: 10px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      display: inline-block;
    }
    #status {
      margin: 0;
      font-size: 18px;
      color: #008800;
      font-weight: bold;
      display: inline-block;
    }
    #timer {
      margin-left: 15px;
      display: inline-block;
      color: #ff6600;
      font-weight: bold;
    }
    #timer-display {
      font-weight: bold;
    }
    #message {
      min-height: 24px;
      font-size: 16px;
      color: #0066cc;
      font-weight: bold;
      margin: 0 0 0 15px;
      display: inline-block;
    }
    .controls {
      margin: 10px 0 20px;
      display: flex;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .button {
      padding: 10px 15px;
      background-color: #ff8c00;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      transition: all 0.3s;
    }
    .button:hover {
      background-color: #e67e00;
      transform: scale(1.05);
    }
    .button.hint {
      background-color: #ffc107;
    }
    .button.reset {
      background-color: #6c757d;
    }
    .difference-list {
      max-width: 90%;
      margin: 20px auto;
      text-align: left;
      background-color: #fff;
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      display: none;
    }
    .difference-list.show {
      display: block;
    }
    .difference-list h3 {
      margin-top: 0;
      color: #ff8c00;
    }
    .difference-list ul {
      padding-left: 20px;
    }
    .difference-list li {
      margin-bottom: 8px;
    }
    @keyframes pulse {
      0% { transform: translate(-50%, -50%) scale(1); opacity: 0.7; }
      100% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.9; }
    }
    .editor-container {
      margin: 20px auto;
      max-width: 90%;
      background-color: #fff;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    #output {
      width: 100%;
      height: 150px;
      font-family: monospace;
      white-space: pre-wrap;
      text-align: left;
      background: #f5f5f5;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      overflow-y: auto;
      margin-top: 15px;
      font-size: 14px;
    }
    .edit-instructions {
      background-color: #fffbcc;
      padding: 10px;
      border-radius: 5px;
      margin-bottom: 20px;
      text-align: left;
    }
    .edit-instructions p {
      margin: 5px 0;
    }
    .edit-instructions ul {
      margin: 5px 0;
      padding-left: 25px;
    }
    .edit-instructions li {
      margin-bottom: 5px;
    }
    /* 手機版特別設定（螢幕寬度小於 768px） */
    @media (max-width: 768px) {
      body {
        padding: 5px;
      }
      h1 {
        font-size: 24px;
        margin: 10px 0;
      }
      .game-container {
        flex-direction: column;
        align-items: center;
        gap: 5px;
        margin-top: 5px;
      }
      .image-container {
        margin-bottom: 5px;
        width: 100%;
      }
      .image-container img {
        width: 100%;
        max-width: none;
        max-height: 40vh;
        object-fit: contain;
      }
      .controls {
        flex-direction: row;
        flex-wrap: wrap;
        margin: 5px 0 15px;
      }
      .button {
        width: auto;
        padding: 8px 12px;
        font-size: 14px;
      }
      .tabs {
        bottom: 10px;
        right: 10px;
      }
      .tab {
        padding: 8px 15px;
        font-size: 14px;
      }
      .game-status-container {
        margin: 5px auto;
        padding: 5px;
      }
      #status {
        font-size: 16px;
        margin: 5px 0;
      }
      #message {
        min-height: 20px;
        font-size: 14px;
      }
      .image-label {
        font-size: 14px;
        padding: 2px 6px;
      }
      .dot, .editor-dot {
        width: 24px;
        height: 24px;
      }
    }
    .level-transition {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      color: white;
      text-align: center;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.5s;
    }
    .level-transition.show {
      opacity: 1;
      visibility: visible;
    }
    .level-transition h2 {
      font-size: 32px;
      margin-bottom: 20px;
      color: #ffc107;
    }
    .level-transition p {
      font-size: 18px;
      margin-bottom: 30px;
    }
    .level-transition button {
      padding: 12px 24px;
      background-color: #ff8c00;
      color: white;
      border: none;
      border-radius: 5px;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
    }
    .level-transition button:hover {
      background-color: #e67e00;
      transform: scale(1.05);
    }
    .level-indicator {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: rgba(255, 255, 255, 0.8);
      padding: 5px 10px;
      border-radius: 20px;
      font-weight: bold;
      color: #ff8c00;
      z-index: 10;
    }
    .level-select {
      display: inline-block;
      position: relative;
      margin-left: 10px;
    }
    
    .level-select select {
      padding: 8px 12px;
      background-color: #6200ee;
      color: white;
      border: none;
      border-radius: 5px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
      padding-right: 30px;
    }
    
    .level-select::after {
      content: "▼";
      font-size: 10px;
      color: white;
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      pointer-events: none;
    }
    
    /* Leaderboard styles */
    .leaderboard-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      color: white;
      text-align: center;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.5s;
    }
    
    .leaderboard-container.show {
      opacity: 1;
      visibility: visible;
    }
    
    .leaderboard-content {
      background-color: #fff;
      color: #333;
      border-radius: 10px;
      padding: 20px;
      width: 90%;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
    }
    
    .leaderboard-content h2 {
      margin-top: 0;
      color: #ff8c00;
    }
    
    .leaderboard-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 15px;
    }
    
    .leaderboard-table th, .leaderboard-table td {
      padding: 8px;
      text-align: left;
      border-bottom: 1px solid #ddd;
    }
    
    .leaderboard-table th {
      background-color: #f2f2f2;
      position: sticky;
      top: 0;
    }
    
    .leaderboard-table tr:nth-child(even) {
      background-color: #f9f9f9;
    }
    
    .leaderboard-table tr:hover {
      background-color: #f1f1f1;
    }
    
    .name-entry-form {
      margin-top: 20px;
      padding: 15px;
      background-color: #f2f2f2;
      border-radius: 8px;
    }
    
    .name-entry-form input {
      padding: 8px 12px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 4px;
      margin-right: 10px;
    }
    
    .name-entry-form button {
      padding: 8px 15px;
      background-color: #ff8c00;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
    }
    
    .leaderboard-buttons {
      margin-top: 20px;
      display: flex;
      gap: 15px;
    }
    
    .leaderboard-buttons button {
      padding: 10px 20px;
      background-color: #ff8c00;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
    }
    
    .leaderboard-buttons button.secondary {
      background-color: #6c757d;
    }
  </style>
</head>
<body>
  
  <div class="tabs">
    <div class="tab active" data-tab="game">遊戲模式</div>
    <div class="tab" data-tab="editor">編輯器模式</div>
  </div>
  
  <div id="game-tab" class="tab-content active">
    <div class="game-container">
      <div class="image-container" id="left-image">
        <img src="https://sunnyyummy.onrender.com/uploads/1745928020704-22308.png" alt="原圖" />
        <!-- 差異點1: D vs O (第二個D變成O) -->
        <div class="dot" id="diff1" data-id="1" style="top: 30%; left: 67%;"></div>
        <div class="label" id="label1" style="top: 30%; left: 67%;">1</div>
        
        <!-- 差異點2: YOMMY vs YOMMY (MM vs M) -->
        <div class="dot" id="diff2" data-id="2" style="top: 70%; left: 67%;"></div>
        <div class="label" id="label2" style="top: 70%; left: 67%;">2</div>
        
        <!-- 差異點3: 右邊角色眼睛樣式 -->
        <div class="dot" id="diff3" data-id="3" style="top: 50%; left: 83%;"></div>
        <div class="label" id="label3" style="top: 50%; left: 83%;">3</div>
        
        <!-- 差異點4: 粉色帽子 -->
        <div class="dot" id="diff4" data-id="4" style="top: 50%; left: 38%;"></div>
        <div class="label" id="label4" style="top: 50%; left: 38%;">4</div>
        
        <!-- 差異點5: 中間角色表情 -->
        <div class="dot" id="diff5" data-id="5" style="top: 52%; left: 60%;"></div>
        <div class="label" id="label5" style="top: 52%; left: 60%;">5</div>
        
        <div class="image-label">原圖</div>
      </div>
      
      <div class="game-status-container">
        <div id="status">已找到：<span id="found-count">0</span> / <span id="total-count">5</span></div>
        <div id="timer" style="margin-left: 15px; display: inline-block; color: #ff6600; font-weight: bold;">時間：<span id="timer-display">00:00</span></div>
        <div id="message"></div>
      </div>
      
      <div class="image-container" id="right-image">
        <img src="https://sunnyyummy.onrender.com/uploads/1745928028967-85686.png" alt="修改版" />
        <!-- 差異點1: D vs O (第二個D變成O) -->
        <div class="dot" id="diff1-right" data-id="1" style="top: 30%; left: 67%;"></div>
        <div class="label" id="label1-right" style="top: 30%; left: 67%;">1</div>
        
        <!-- 差異點2: YOMMY vs YOMMY (MM vs M) -->
        <div class="dot" id="diff2-right" data-id="2" style="top: 70%; left: 67%;"></div>
        <div class="label" id="label2-right" style="top: 70%; left: 67%;">2</div>
        
        <!-- 差異點3: 右邊角色眼睛樣式 -->
        <div class="dot" id="diff3-right" data-id="3" style="top: 50%; left: 83%;"></div>
        <div class="label" id="label3-right" style="top: 50%; left: 83%;">3</div>
        
        <!-- 差異點4: 粉色帽子 -->
        <div class="dot" id="diff4-right" data-id="4" style="top: 50%; left: 38%;"></div>
        <div class="label" id="label4-right" style="top: 50%; left: 38%;">4</div>
        
        <!-- 差異點5: 中間角色表情 -->
        <div class="dot" id="diff5-right" data-id="5" style="top: 52%; left: 60%;"></div>
        <div class="label" id="label5-right" style="top: 52%; left: 60%;">5</div>
        
        <div class="image-label">修改版</div>
      </div>
    </div>
    
    <div class="controls">
      <button class="button hint" id="hint-button">提示</button>
      <button class="button" id="show-answers-button">顯示所有答案</button>
      <button class="button reset" id="reset-button">重新開始</button>
    </div>
  </div>
  
  <div id="editor-tab" class="tab-content">
    <h2>編輯器模式 ✏️</h2>
    
    <div class="game-container">
      <div class="image-container" id="edit-left">
        <img src="" alt="原圖" id="left-edit-img" />
        <div class="image-label">原圖</div>
      </div>
      
      <div class="image-container" id="edit-right">
        <img src="" alt="修改版" id="right-edit-img" />
        <div class="image-label">修改版</div>
      </div>
    </div>
    
    <div class="controls">
      <button class="button reset" id="clear-editor">清除所有</button>
      <button class="button" id="save-editor" style="background-color: #28a745;">保存</button>
      <div class="level-select">
        <select id="level-selector">
          <!-- 選項將由JavaScript動態填充 -->
        </select>
      </div>
      <button class="button" id="add-new-level" style="background-color: #0275d8;">新增圖片</button>
    </div>
    
    <!-- 添加輸出區域 -->
    <div style="margin-top: 20px;">
      <textarea id="output" style="width: 100%; height: 100px; font-family: monospace;" readonly></textarea>
    </div>
    
    <!-- 新增圖片表單 -->
    <div id="new-level-form" style="display: none; margin-top: 20px; background: #f8f9fa; padding: 15px; border-radius: 8px;">
      <h3>新增圖片</h3>
      <div style="margin-bottom: 10px;">
        <label>圖片名稱: <input type="text" id="new-level-name" style="margin-left: 10px;"></label>
      </div>
      <div style="margin-bottom: 10px;">
        <label>原圖URL: <input type="text" id="new-left-image" style="margin-left: 10px; width: 300px;"></label>
      </div>
      <div style="margin-bottom: 10px;">
        <label>修改版URL: <input type="text" id="new-right-image" style="margin-left: 10px; width: 300px;"></label>
      </div>
      <button class="button" id="submit-new-level" style="background-color: #28a745;">提交</button>
      <button class="button" id="cancel-new-level" style="background-color: #dc3545;">取消</button>
    </div>
  </div>
  
  <div class="level-transition" id="level-transition">
    <h2>恭喜完成第一關！</h2>
    <p>準備好挑戰第二關了嗎？</p>
    <button id="next-level-button">開始第二關</button>
  </div>
  
  <!-- 排行榜 -->
  <div class="leaderboard-container" id="leaderboard-container">
    <div class="leaderboard-content">
      <h2>排行榜</h2>
      <div id="name-entry-container" class="name-entry-form">
        <p>恭喜完成所有關卡！總耗時: <span id="final-time-display"></span></p>
        <input type="text" id="player-name" placeholder="請輸入您的名字" maxlength="20">
        <button id="submit-score">提交成績</button>
      </div>
      <table class="leaderboard-table">
        <thead>
          <tr>
            <th>排名</th>
            <th>名字</th>
            <th>時間</th>
            <th>日期</th>
          </tr>
        </thead>
        <tbody id="leaderboard-rows">
          <!-- 排行榜資料將動態填入 -->
        </tbody>
      </table>
      <div class="leaderboard-buttons">
        <button id="close-leaderboard" class="secondary">關閉</button>
        <button id="restart-game">重新開始</button>
      </div>
    </div>
  </div>
  
  <script>
    // 切換標籤頁
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        // 移除所有標籤和內容的active類
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        
        // 添加active類到當前標籤和對應的內容
        tab.classList.add('active');
        document.getElementById(tab.getAttribute('data-tab') + '-tab').classList.add('active');
      });
    });
    
    // ----- 遊戲模式代碼 -----
    const allLevels = [
      {
        // 第一關
        levelId: 1,
        storageKey: 'differentGameLevel1Data',
        leftImage: "https://sunnyyummy.onrender.com/uploads/1745928020704-22308.png",
        rightImage: "https://sunnyyummy.onrender.com/uploads/1745928028967-85686.png",
        // 保持第一關的初始點位數據，以便在localStorage沒有數據時使用
        differences: [
          { id: 'diff1', description: '差異點位於右上區域 (D vs O)', position: { top: '30%', left: '67%' } },
          { id: 'diff2', description: '差異點位於右下區域 (YOMMY vs YOMY)', position: { top: '70%', left: '67%' } },
          { id: 'diff3', description: '差異點位於右側眼睛樣式', position: { top: '50%', left: '83%' } },
          { id: 'diff4', description: '差異點位於左側粉色帽子', position: { top: '50%', left: '38%' } },
          { id: 'diff5', description: '差異點位於中間角色表情', position: { top: '52%', left: '60%' } }
        ]
      },
      {
        // 第二關
        levelId: 2,
        storageKey: 'differentGameLevel2Data',
        leftImage: "https://sunnyyummy.onrender.com/uploads/1745941255784-4084.png",
        rightImage: "https://sunnyyummy.onrender.com/uploads/1745941265630-74495.png",
        differences: [] // 初始為空，期望從 localStorage 載入
      },
      {
        // 第三關
        levelId: 3,
        storageKey: 'differentGameLevel3Data',
        leftImage: "https://sunnyyummy.onrender.com/uploads/1745944114845-94074.png",
        rightImage: "https://sunnyyummy.onrender.com/uploads/1745944121794-50612.png",
        differences: [ // 添加第三關的默認差異點 (如果 localStorage 沒有)
          { id: 'diff1', description: '第三關差異點A', position: { top: '20%', left: '25%' } },
          { id: 'diff2', description: '第三關差異點B', position: { top: '15%', left: '75%' } },
          { id: 'diff3', description: '第三關差異點C', position: { top: '50%', left: '50%' } },
          { id: 'diff4', description: '第三關差異點D', position: { top: '80%', left: '30%' } },
          { id: 'diff5', description: '第三關差異點E', position: { top: '75%', left: '70%' } }
        ]
      },
      {
        // 第四關 (範例)
        levelId: 4,
        storageKey: 'differentGameLevel4Data',
        leftImage: "https://sunnyyummy.onrender.com/uploads/1745945120161-78277.png",
        rightImage: "https://sunnyyummy.onrender.com/uploads/1745945134090-91988.png",
        differences: [ // 第四關的默認差異點
          { id: 'diff1', description: '第四關差異點1', position: { top: '25%', left: '15%' } },
          { id: 'diff2', description: '第四關差異點2', position: { top: '35%', left: '80%' } },
          { id: 'diff3', description: '第四關差異點3', position: { top: '60%', left: '50%' } },
          { id: 'diff4', description: '第四關差異點4', position: { top: '75%', left: '20%' } },
          { id: 'diff5', description: '第四關差異點5', position: { top: '85%', left: '70%' } }
        ]
      }
    ];

    // 創建 allLevels 的深拷貝以備修改
    const allLevelsData = JSON.parse(JSON.stringify(allLevels));

   // 修改 getRandomLevels 函數以確保返回正確的格式
async function getRandomLevels() {
  try {
    const response = await fetch('/api/diffrent-game/levels/random');
    const levels = await response.json();
    
    if (!levels || !Array.isArray(levels) || levels.length === 0) {
      console.warn('API未返回有效關卡，使用默認關卡');
      return allLevels; // 使用默認關卡
    }
    
    // 格式化確保每個level有正確的屬性
    const formattedLevels = levels.map(level => ({
      id: level.id,
      levelId: level.id,
      leftImage: level.left_image_url,
      rightImage: level.right_image_url
    }));
    console.log("隨機選擇的關卡:", formattedLevels.map(l => l.id));
    return formattedLevels;
  } catch (error) {
    console.error('無法獲取隨機關卡:', error);
    console.warn('使用默認關卡作為備用');
    return allLevels; // 失敗時使用默認關卡
  }
}

    // ----- 遊戲狀態變數 -----
    let gameLevels = []; // 儲存當前遊戲會用到的隨機關卡
    let currentLevel = 0;
    // let differences = []; // 不再需要全局 differences

    let foundCount = 0;
    const foundDifferences = new Set();
    const messageElement = document.getElementById('message');
    const foundCountElement = document.getElementById('found-count');
    const totalCountElement = document.getElementById('total-count');
    const resetButton = document.getElementById('reset-button');
    const showAnswersButton = document.getElementById('show-answers-button');
    const hintButton = document.getElementById('hint-button');
    const levelTransition = document.getElementById('level-transition');
    const nextLevelButton = document.getElementById('next-level-button');

    // 計時器相關變數
    let timerInterval;
    let startTime;
    let totalElapsedTime = 0;
    let timerRunning = false;
    const timerDisplay = document.getElementById('timer-display');

    let answersVisible = false;

    // ----- DOM 元素 -----
    const leftImageContainer = document.getElementById('left-image');
    const rightImageContainer = document.getElementById('right-image');
    const leftImageElement = leftImageContainer.querySelector('img');
    const rightImageElement = rightImageContainer.querySelector('img');
    const levelIndicator = document.createElement('div'); // 關卡指示器只需要創建一次
    levelIndicator.className = 'level-indicator';
    leftImageContainer.appendChild(levelIndicator); // 添加到左圖容器


    
    // 設置新遊戲或重置遊戲
    async function setupNewGame() {
      console.log("Setting up new game...");
      
      // 重置遊戲狀態
      foundDifferences.clear();
      foundCount = 0;
      foundCountElement.textContent = '0';
      messageElement.textContent = '';
      answersVisible = false;
      showAnswersButton.textContent = '顯示所有答案';

      // 重置計時器
      clearInterval(timerInterval);
      timerRunning = false;
      totalElapsedTime = 0;
      timerDisplay.textContent = '00:00';
      
      // 確保先有遊戲數據再開始計時器
      try {
        gameLevels = await getRandomLevels(); // 獲取新的隨機關卡列表
        
        if (!gameLevels || gameLevels.length === 0) {
          console.error("無法獲取遊戲關卡");
          messageElement.textContent = "載入遊戲關卡失敗，請重新整理頁面";
          return;
        }
        
        currentLevel = 0;
        startTimer(); // 啟動計時器
        
        // 加載第一個關卡
        loadLevel(currentLevel);
      } catch (error) {
        console.error("初始化遊戲失敗:", error);
        messageElement.textContent = "初始化遊戲失敗，請重新整理頁面";
      }
    }

    // 修改 loadLevel 使其異步並正確處理數據
    async function loadLevel(levelIndex) {
      if (levelIndex < 0 || levelIndex >= gameLevels.length) {
        console.error("無效的關卡索引:", levelIndex);
        messageElement.textContent = "遊戲已完成或出現錯誤！";
        pauseTimer();
        return;
      }
      console.log(`Loading level index: ${levelIndex}`);
      const level = gameLevels[levelIndex]; // level has { id, levelId, leftImage, rightImage }

      if (!level || !level.id || !level.leftImage || !level.rightImage) {
        console.error("關卡對象缺少必要屬性:", level);
        messageElement.textContent = "無法載入關卡，數據不完整";
        return;
      }

      // 更新圖片
      leftImageElement.src = level.leftImage;
      rightImageElement.src = level.rightImage;
      levelIndicator.textContent = `關卡 ${levelIndex + 1}`;

      // 清空舊的差異點顯示
      resetGameDisplay();

      // 從API加載當前關卡的差異點數據
      const { success, differences: apiDifferences, savedDots: apiSavedDots } = await loadDifferencesFromAPI(level.id);
      
      let finalDifferences = [];
      let finalPositions = {}; // Map: dataId -> position {top, left}
      
      if (success && apiDifferences.length > 0) {
        console.log(`Level ${level.id} data loaded from API.`);
        finalDifferences = apiDifferences;
        apiSavedDots.forEach(dot => {
          finalPositions[dot.id] = dot.rightPosition;
        });
      } else {
        console.warn(`API failed or returned no data for level ${level.id}. Trying default data.`);
        const defaultLevelData = allLevels.find(l => l.levelId === level.id || l.id === level.id); // Find default data
        if (defaultLevelData && defaultLevelData.differences && defaultLevelData.differences.length > 0) {
          console.log(`Using default difference data for level ${level.id}.`);
          finalDifferences = defaultLevelData.differences; // Use default descriptions/ids
          // Attempt to get positions from default data if they exist
          finalDifferences.forEach((diff, index) => {
            const dataIdMatch = String(diff.id).match(/\d+$/);
            const dataId = dataIdMatch ? parseInt(dataIdMatch[0]) : index + 1;
            if (diff.position) {
              finalPositions[dataId] = diff.position;
            } else {
              // Fallback position if even default data lacks it
              finalPositions[dataId] = { top: `${15 + index * 15}%`, left: `${20 + index * 10}%` };
              console.warn(`Default data for diff ${dataId} also lacks position. Using fallback.`);
            }
          });
        } else {
          console.error(`No data found for level ${level.id} from API or defaults.`);
          messageElement.textContent = `錯誤：無法載入關卡 ${level.id} 的差異點！`;
          finalDifferences = [];
          finalPositions = {};
        }
      }
      
      // **** 將加載的數據存儲到當前 level 對象中，供 handleGameClick 等使用 ****
      level.differences = finalDifferences; // Store descriptions/diffIds
      level.positions = finalPositions; // Store positions map { dataId: {top, left} }
      
      // 創建差異點 DOM 元素
      createDifferencePoints(finalDifferences, finalPositions); // Pass data directly
    }

    // 載入下一關
    function loadNextLevel() {
      levelTransition.classList.remove('show');
      currentLevel++;
      if (currentLevel >= gameLevels.length) {
        // 所有隨機選擇的關卡都已完成
        messageElement.textContent = `恭喜！你完成所有 ${gameLevels.length} 個關卡！總耗時： ${timerDisplay.textContent}`;
        pauseTimer();
        // 可以選擇禁用按鈕或顯示完成畫面
        nextLevelButton.disabled = true;
        // 可以選擇自動回到第一關 (如果需要循環)
        // setupNewGame();
        return;
      }

      // 重置當前關卡的狀態 (找到的點數等)
      foundDifferences.clear();
      foundCount = 0;
      foundCountElement.textContent = '0';
      totalCountElement.textContent = '5'; // 默認值，將在loadLevel中更新
      messageElement.textContent = '';
      answersVisible = false;
      showAnswersButton.textContent = '顯示所有答案';

      // 加載下一個關卡
      loadLevel(currentLevel);
      
      // 確保計時器繼續運行 (關卡之間不重置)
      startTimer();
    }

    // 從API載入關卡差異點數據
    async function loadDifferencesFromAPI(levelId) { // 只接收 levelId
      let differences = [];
      let savedDots = [];
      let success = false;
      
      try {
        const response = await fetch(`/api/diffrent-game/differences/${levelId}`);
        
        if (!response.ok) {
          throw new Error(`API響應錯誤: ${response.status}`);
        }
        
        const apiDifferences = await response.json();
        
        if (apiDifferences && Array.isArray(apiDifferences) && apiDifferences.length > 0) {
          console.log(`從API獲取到 ${apiDifferences.length} 個差異點 for level ${levelId}`);
          
          // 處理差異點格式以符合前端需求
          differences = apiDifferences.map(diff => ({
            id: `diff${diff.id}`, // 遊戲模式用的 ID
            description: diff.description || `差異點 ${diff.id}`
          }));
          
          savedDots = apiDifferences.map(diff => ({
            id: diff.id, // 編輯器和查找用的數字 ID
            rightPosition: {
              top: diff.position_top,
              left: diff.position_left
            }
          }));
          
          success = true;
        } else {
          console.warn(`關卡 ${levelId} API未返回差異點數據`);
          // 這裡不再嘗試使用默認值，調用者需要處理這種情況
        }
      } catch (error) {
        console.error(`從API載入關卡 ${levelId} 數據錯誤:`, error);
        // 調用者需要處理錯誤情況
      }
      
      // 返回獲取到的數據和成功狀態
      return { success, differences, savedDots };
    }

    // 重置游戲顯示 (清除點和標籤)
    function resetGameDisplay() {
      // 移除已有的點和標籤
      document.querySelectorAll('#left-image .dot, #left-image .label, #right-image .dot, #right-image .label').forEach(el => {
        if (el !== levelIndicator) { // 不要移除關卡指示器
          el.remove();
        }
      });
      console.log("Game display reset (dots and labels removed).");
    }

    // 修改 createDifferencePoints 以使用傳入的數據
    function createDifferencePoints(differences, positionsMap) {
      if (!differences || differences.length === 0) {
        console.warn('No differences provided to createDifferencePoints');
        totalCountElement.textContent = '0'; // Update total count display
        return;
      }
      
      // 清除現有點 (確保 resetGameDisplay 已被調用，但再次執行無害)
      // document.querySelectorAll('.dot, .label').forEach(el => {
      //   if (el !== levelIndicator) el.remove();
      // });
      
      const leftContainer = document.getElementById('left-image');
      const rightContainer = document.getElementById('right-image');
      
      if (!leftContainer || !rightContainer) {
        console.error('Image containers not found');
        return;
      }
      
      console.log(`Creating ${differences.length} difference points in DOM.`);
      totalCountElement.textContent = `${differences.length}`; // Update total count display
      foundCountElement.textContent = '0'; // Reset found count display for the new level
      
      // 為每個差異創建點
      differences.forEach((diff, index) => {
        const diffIdMatch = String(diff.id).match(/\d+$/);
        const dataId = diffIdMatch ? parseInt(diffIdMatch[0]) : index + 1; // Ensure dataId is a number
        
        // 從 map 中獲取位置
        const position = positionsMap[dataId];
        
        if (!position || !position.top || !position.left) {
           console.warn(`Position data missing or invalid for difference dataId ${dataId}. Skipping dot creation.`);
           // Assign a default position if needed, or skip
           // position = { top: `${15 + index * 15}%`, left: `${20 + index * 10}%` };
           return; // Skip creating this dot if position is invalid
        }
        
        // 確保使用百分比位置
        const posTop = String(position.top).includes('%') ? position.top : `${position.top}%`;
        const posLeft = String(position.left).includes('%') ? position.left : `${position.left}%`;
        const finalPosition = { top: posTop, left: posLeft };
        
        const dotIdBase = `diff${dataId}`;
        const labelIdBase = `label${dataId}`;
        
        // 創建左右圖的點和標籤
        createDotElement(leftContainer, dotIdBase, dataId, finalPosition);
        createLabelElement(leftContainer, labelIdBase, dataId, finalPosition);
        
        createDotElement(rightContainer, `${dotIdBase}-right`, dataId, finalPosition);
        createLabelElement(rightContainer, `${labelIdBase}-right`, dataId, finalPosition);
        
        // (Optional) 檢查 foundDifferences - resetGameDisplay 應該已經處理了顯示
        // if (foundDifferences.has(String(dataId))) { ... }
      });
    }

    // createDotElement 和 createLabelElement 不需要修改，但要確保它們正確使用傳入的 finalPosition
    // 輔助函數：創建點元素 (檢查)
    function createDotElement(container, id, dataId, position) {
      const dot = document.createElement('div');
      dot.className = 'dot';
      dot.id = id;
      dot.setAttribute('data-id', dataId); // 使用數字 ID 作為 data-id
      
      // 使用傳入的位置
      dot.style.top = position.top;
      dot.style.left = position.left;
      
      // 初始隱藏所有點
      dot.style.display = 'none';
      
      // 將點添加到提供的容器中（左或右圖）
      container.appendChild(dot);
      
      return dot;
    }

    // 輔助函數：創建標籤元素 (檢查)
    function createLabelElement(container, id, dataId, position) {
      const label = document.createElement('div');
      label.className = 'label';
      label.id = id;
      label.style.top = position.top;
      label.style.left = position.left;
      label.textContent = dataId; // 顯示數字 ID
      // 初始隱藏
      // label.style.display = 'none'; // label class handles this with .show
      container.appendChild(label);
    }


    // 為游戲模式中的每個圖片容器添加點擊事件 (使用事件委派)
    leftImageContainer.addEventListener('click', function(e) {
      handleGameClick(e, this, false);
    });

    rightImageContainer.addEventListener('click', function(e) {
      handleGameClick(e, this, true);
    });

    function handleGameClick(e, container, isRight) {
      // 點擊的是圖片本身或容器，而不是點或標籤
      if (!e.target.matches('img') && e.target !== container) {
        return;
      }
      const level = gameLevels[currentLevel];
      if (!level || !level.differences || level.differences.length === 0 || !level.positions) return; // 沒有點可以找或位置數據缺失

      // 計算點擊相對於圖片的位置
      const img = container.querySelector('img');
      const rect = img.getBoundingClientRect();
      const x = ((e.clientX - rect.left) / rect.width) * 100;
      const y = ((e.clientY - rect.top) / rect.height) * 100;
      console.log(`Click at (${x.toFixed(2)}%, ${y.toFixed(2)}%) on ${isRight ? 'right' : 'left'} image`);

      // 檢查是否點擊在差異點附近
      let found = false;
      for (let i = 0; i < level.differences.length; i++) {
        const diff = level.differences[i];
        const diffIdMatch = String(diff.id).match(/\d+$/);
        if (!diffIdMatch) continue;
        const dataId = diffIdMatch[0]; // 獲取數字 ID (字符串形式)
        const dataIdNum = parseInt(dataId); // 數字形式用於查找 position map

        // **** 從 level.positions 獲取位置 ****
        const diffPosition = level.positions[dataIdNum];

        if (!diffPosition) {
             console.warn(`Position data not found in level.positions for dataId: ${dataIdNum}`);
             continue;
        }

        const diffX = parseFloat(diffPosition.left);
        const diffY = parseFloat(diffPosition.top);

        // 計算距離
        const distance = Math.sqrt(Math.pow(x - diffX, 2) + Math.pow(y - diffY, 2));
        const clickRadius = 5; // 點擊半徑（百分比）

        console.log(`Checking distance to diff ${dataId}: ${distance.toFixed(2)}% (Target: < ${clickRadius}%)`);

        if (distance < clickRadius) { // 調整點擊範圍
          if (!foundDifferences.has(dataId)) {
            console.log(`Found difference ${dataId}!`);
            foundDifferences.add(dataId);
            foundCount++;
            foundCountElement.textContent = `${foundCount}`;

            // 顯示左右兩邊的點和標籤
            document.querySelectorAll(`.dot[data-id="${dataId}"]`).forEach(dot => {
              dot.style.display = 'block';
              dot.classList.add('found');
            });
            document.querySelectorAll(`.label[data-id="${dataId}"]`).forEach(label => {
              label.classList.add('show');
            });

            messageElement.textContent = `找到了: ${diff.description || `差異點 ${dataId}`}`; // Use description from diff

            // 檢查是否找到所有差異點
            if (foundCount === level.differences.length) {
               console.log("All differences found for this level!");
               setTimeout(showCompletionMessage, 1000); // 延遲顯示過關信息
            }
          } else {
              console.log(`Difference ${dataId} already found.`);
              messageElement.textContent = `這個點已經找到了！`;
              setTimeout(() => { messageElement.textContent = ''; }, 1500);
          }
          found = true;
          break; // 找到一個就停止檢查
        }
      }

      // 如果點擊不在任何差異點附近
      if (!found && e.target.matches('img')) {
        console.log("Missed.");
        messageElement.textContent = '請再試一次';
        setTimeout(() => { messageElement.textContent = ''; }, 1000);
      }
    }

    // 提示按鈕功能
    hintButton.addEventListener('click', () => {
      const level = gameLevels[currentLevel];
      if (!level || !level.differences) return;

      if (foundCount >= level.differences.length) {
        messageElement.textContent = '你已經找到所有不同之處！';
        return;
      }

      // 找出尚未找到的差異點的 data-id
      const notFoundIds = level.differences
          .map(diff => {
              const match = String(diff.id).match(/\d+$/);
              return match ? match[0] : null;
          })
          .filter(id => id && !foundDifferences.has(id));

      if (notFoundIds.length > 0) {
        // 隨機選擇一個未找到的 data-id
        const randomIndex = Math.floor(Math.random() * notFoundIds.length);
        const hintDataId = notFoundIds[randomIndex];
        const hintDiff = level.differences.find(d => String(d.id).endsWith(hintDataId));

        console.log(`Hint for difference: ${hintDataId}`);

        // 顯示提示的點（閃爍效果）
        document.querySelectorAll(`.dot[data-id="${hintDataId}"]`).forEach(dot => {
            dot.style.display = 'block';
            dot.classList.add('hint');
            // 移除可能存在的 found 樣式，以顯示 hint 樣式
            dot.classList.remove('found');
        });

        messageElement.textContent = `提示：${hintDiff ? hintDiff.description : '一個未找到的點'}`;

        // 3秒後隱藏提示效果
        setTimeout(() => {
          if (!foundDifferences.has(hintDataId)) { // 確保在提示期間沒有被找到
             document.querySelectorAll(`.dot[data-id="${hintDataId}"]`).forEach(dot => {
                 dot.style.display = 'none'; // 隱藏回去
                 dot.classList.remove('hint');
             });
             messageElement.textContent = '';
          } else {
              // 如果在提示期間被找到了，只需移除 hint 樣式
              document.querySelectorAll(`.dot[data-id="${hintDataId}"]`).forEach(dot => {
                  dot.classList.remove('hint');
              });
          }
        }, 3000);
      }
    });

    // 顯示/隱藏所有答案
    showAnswersButton.addEventListener('click', () => {
      answersVisible = !answersVisible;
      const level = gameLevels[currentLevel];
      if (!level || !level.differences) return;

      level.differences.forEach(diff => {
          const match = String(diff.id).match(/\d+$/);
          if (!match) return;
          const dataId = match[0];

          const dots = document.querySelectorAll(`.dot[data-id="${dataId}"]`);
          const labels = document.querySelectorAll(`.label[data-id="${dataId}"]`);

          if (answersVisible) {
              dots.forEach(dot => {
                  dot.style.display = 'block';
                  if (!foundDifferences.has(dataId)) {
                      dot.classList.add('hint'); // 對未找到的用提示樣式
                      dot.classList.remove('found');
                  }
              });
              labels.forEach(label => label.classList.add('show'));
          } else {
              // 隱藏答案
              dots.forEach(dot => {
                  if (!foundDifferences.has(dataId)) {
                      dot.style.display = 'none'; // 隱藏未找到的
                      dot.classList.remove('hint');
                  } else {
                      dot.classList.remove('hint'); // 確保已找到的沒有 hint 樣式
                  }
              });
              labels.forEach(label => {
                  if (!foundDifferences.has(dataId)) {
                      label.classList.remove('show'); // 隱藏未找到的標籤
                  }
              });
          }
      });

      showAnswersButton.textContent = answersVisible ? '隱藏答案' : '顯示所有答案';
      messageElement.textContent = answersVisible ? '已顯示所有答案' : '';
    });


    // ----- 編輯器模式代碼 -----
    // 獲取編輯器元素 (保持不變)
    const editLeftContainer = document.getElementById('edit-left');
    const editRightContainer = document.getElementById('edit-right');
    const editLeftImg = document.getElementById('left-edit-img');
    const editRightImg = document.getElementById('right-edit-img');
    const levelSelector = document.getElementById('level-selector');
    const saveEditorButton = document.getElementById('save-editor');
    const clearEditorButton = document.getElementById('clear-editor');
    const output = document.getElementById('output'); // Make sure output is defined here
    const addNewLevelButton = document.getElementById('add-new-level'); // Add this if not already defined
    const newLevelForm = document.getElementById('new-level-form'); // Add this

    // 編輯器變數 (保持不變)
    let editorDots = []; // { id: number, description: string, rightPosition: {top: string, left: string} }
      let dotCounter = 1;


    // **** Define Editor Functions Globally ****
    async function populateLevelSelector() {
      // Add check for element existence inside the function
      if (!levelSelector) {
          console.warn("Level selector element not found, cannot populate.");
          return;
        }
        try {
          const response = await fetch('/api/diffrent-game/levels');
        if (!response.ok) throw new Error('Failed to fetch levels');
          const levels = await response.json();
          
          levelSelector.innerHTML = ''; // 清空現有選項
          levels.forEach(level => {
            const option = document.createElement('option');
          option.value = level.id; // Use API ID
          option.textContent = `ID:${level.id} - ${level.level_name || `圖片 ${level.id}`}`; // Use name from API
            levelSelector.appendChild(option);
          });
          
        // 如果有關卡，自動觸發載入第一個
          if (levels.length > 0) {
          levelSelector.dispatchEvent(new Event('change')); // Trigger loading for the first level
        } else {
           // Handle case with no levels
           if (editLeftImg) editLeftImg.src = "";
           if (editRightImg) editRightImg.src = "";
           clearEditorDisplay(); // Call clear function which should also check elements
           console.warn("No levels found to populate editor selector.");
          }
        } catch (error) {
          console.error('獲取關卡列表失敗:', error);
          alert('無法載入關卡列表，請刷新頁面再試');
        // Clear editor state if levels fail to load
        if (editLeftImg) editLeftImg.src = "";
        if (editRightImg) editRightImg.src = "";
        clearEditorDisplay(); // Call clear function
      }
    }

    async function loadLevelIntoEditor(levelId) {
      // Add checks for necessary elements at the beginning
      if (!editLeftImg || !editRightImg || !output) {
          console.error("Cannot load level into editor: Missing essential DOM elements.");
          return;
      }

      console.log(`Loading level ${levelId} into editor...`);
      clearEditorDisplay(); // Clear previous state first

        try {
        // 1. Fetch Level Images
        const levelResponse = await fetch(`/api/diffrent-game/levels/${levelId}`);
        if (!levelResponse.ok) throw new Error(`Failed to fetch level details for ID ${levelId}`);
        const levelData = await levelResponse.json();

        if (levelData && levelData.left_image_url && levelData.right_image_url) {
          editLeftImg.src = levelData.left_image_url;
          editRightImg.src = levelData.right_image_url;
        } else {
           throw new Error(`Incomplete level data received for ID ${levelId}`);
        }

        // 2. Fetch Differences
        const { success, savedDots } = await loadDifferencesFromAPI(levelId); // Use the modified function

        if (success && savedDots.length > 0) {
           console.log(`Loaded ${savedDots.length} differences from API for editor.`);
           // Populate editorDots and create visual elements
           editorDots = savedDots.map(dot => ({ // savedDots has { id: number, rightPosition: { top, left } }
               id: dot.id,
               description: `差異點 ${dot.id}`, // Default description, maybe fetch full diff data if needed?
               rightPosition: dot.rightPosition,
           }));

           // Reset dotCounter based on loaded dots
           const maxId = editorDots.reduce((max, dot) => Math.max(max, dot.id || 0), 0);
                   dotCounter = maxId + 1;

           // Create DOM elements for loaded dots
           editorDots.forEach(dotData => {
                        createEditorDotElements(dotData.id, dotData.rightPosition);
                   });

              } else {
           console.log(`No differences found in API for level ${levelId}. Editor starts empty.`);
           // editorDots is already cleared by clearEditorDisplay
           dotCounter = 1; // Reset counter for new dots
              }

        updateOutput(); // Update the HTML code output

          } catch (error) {
         console.error(`Error loading level ${levelId} into editor:`, error);
         alert(`無法載入圖片 ${levelId} 的編輯數據。`);
         // Clear editor in case of error
         editLeftImg.src = "";
         editRightImg.src = "";
         clearEditorDisplay();
          }
    }

      function clearEditorDisplay() {
          document.querySelectorAll('#editor-tab .editor-dot').forEach(dot => {
            dot.remove();
          });
          editorDots = [];
        dotCounter = 1; // Reset counter
        updateOutput(); // Update output to show empty state
          console.log("Editor display cleared.");
      }

      function addEditorDot(e) {
      // Add check for necessary element
      if (!editRightImg) return;

      if (editorDots.length >= 5) { // Limit check is good
          alert('最多只能添加5個差異點！');
          return;
        }
        const rect = editRightImg.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width) * 100;
        const y = ((e.clientY - rect.top) / rect.height) * 100;
        const position = { top: y.toFixed(2) + '%', left: x.toFixed(2) + '%' };
      const newDotId = dotCounter; // Use the counter

        console.log(`Adding editor dot ${newDotId} at`, position);

      // Create DOM elements
        createEditorDotElements(newDotId, position);

      // Update internal data (editorDots)
        editorDots.push({
        id: newDotId, // Store the number ID
        description: `差異點 ${newDotId}`, // Temporary description
          rightPosition: position
        });
      dotCounter++; // Increment counter

      updateOutput(); // Update HTML output
      }

      function createEditorDotElements(id, position) {
        // Add checks for necessary elements
        if (!editRightContainer || !editLeftContainer) return;

          const rightDot = document.createElement('div');
          rightDot.className = 'editor-dot';
          rightDot.setAttribute('data-id', id);
          rightDot.style.top = position.top;
          rightDot.style.left = position.left;
          editRightContainer.appendChild(rightDot);
        makeDotDraggable(rightDot);

          const leftDot = document.createElement('div');
        leftDot.className = 'editor-dot reference';
        leftDot.setAttribute('data-id', id);
          leftDot.style.top = position.top;
          leftDot.style.left = position.left;
          editLeftContainer.appendChild(leftDot);
      }

      function makeDotDraggable(element) {
        element.addEventListener('mousedown', startDragDot);
        element.addEventListener('touchstart', startDragDot, { passive: false }); // passive: false for preventDefault
      }

      function startDragDot(e) {
      // e.preventDefault(); // Consider if needed
      e.stopPropagation();

        const dot = e.target;
      if (!dot.classList.contains('editor-dot') || dot.classList.contains('reference') || !editRightImg || !editLeftContainer) {
        return; // Ensure it's a draggable dot and containers exist
        }

        const dotId = dot.getAttribute('data-id');
        const referenceDot = editLeftContainer.querySelector(`.editor-dot.reference[data-id="${dotId}"]`);
        const containerRect = editRightImg.getBoundingClientRect();

        function moveHandler(moveEvent) {
         if (moveEvent.type === 'touchmove') { moveEvent.preventDefault(); }

           let clientX, clientY;
           if (moveEvent.type === 'mousemove' || moveEvent.type === 'mousedown') {
           clientX = moveEvent.clientX; clientY = moveEvent.clientY;
           } else if (moveEvent.type === 'touchmove' || moveEvent.type === 'touchstart') {
           clientX = moveEvent.touches[0].clientX; clientY = moveEvent.touches[0].clientY;
         } else { return; }

           let x = ((clientX - containerRect.left) / containerRect.width) * 100;
           let y = ((clientY - containerRect.top) / containerRect.height) * 100;
         x = Math.max(1, Math.min(99, x)); y = Math.max(1, Math.min(99, y));
           const newPosition = { top: y.toFixed(2) + '%', left: x.toFixed(2) + '%' };

         dot.style.left = newPosition.left; dot.style.top = newPosition.top;
         if (referenceDot) { referenceDot.style.left = newPosition.left; referenceDot.style.top = newPosition.top; }

           const dotData = editorDots.find(d => d.id == dotId);
         if (dotData) { dotData.rightPosition = newPosition; updateOutput(); }
        }

        function endDragHandler() {
          document.removeEventListener('mousemove', moveHandler);
          document.removeEventListener('mouseup', endDragHandler);
          document.removeEventListener('touchmove', moveHandler);
          document.removeEventListener('touchend', endDragHandler);
          console.log(`Dot ${dotId} drag ended at`, dot.style.top, dot.style.left);
        }

        document.addEventListener('mousemove', moveHandler);
        document.addEventListener('mouseup', endDragHandler);
        document.addEventListener('touchmove', moveHandler, { passive: false });
        document.addEventListener('touchend', endDragHandler);
      }

    function updateOutput() {
      if (!output) return; // Guard against missing element
      if (editorDots.length === 0) {
        output.value = '// 點擊右側修改版圖片添加差異點，代碼將顯示在這裡';
        return;
      }
      let code = `<!-- ${editorDots.length} 個差異點位置 (基於右圖) -->\n\n`;
      // Sort by numerical ID before generating code
      editorDots.sort((a, b) => (a.id || 0) - (b.id || 0)).forEach(dot => {
        // Ensure dot.id is a number and position exists
        if (typeof dot.id !== 'number' || !dot.rightPosition) return;
        const position = dot.rightPosition;
        const dataId = dot.id; // Use the number ID
        // Generate description dynamically or use stored one if available
        const rightX = parseFloat(position.left);
        const rightY = parseFloat(position.top);
        let locationHint = '';
        if (rightX < 33) locationHint += '左側'; else if (rightX < 66) locationHint += '中央'; else locationHint += '右側';
        if (rightY < 33) locationHint += '上方'; else if (rightY < 66) locationHint += '中部'; else locationHint += '下方';
        const description = dot.description || `差異點位於${locationHint}區域`; // Use dynamic description

        code += `<!-- ${description} -->\n`;
        // Game mode elements
        code += `<div class="dot" id="diff${dataId}" data-id="${dataId}" style="top: ${position.top}; left: ${position.left};"></div>\n`;
        code += `<div class="label" id="label${dataId}" style="top: ${position.top}; left: ${position.left};">${dataId}</div>\n`;
        code += `<div class="dot" id="diff${dataId}-right" data-id="${dataId}" style="top: ${position.top}; left: ${position.left};"></div>\n`;
        code += `<div class="label" id="label${dataId}-right" style="top: ${position.top}; left: ${position.left};">${dataId}</div>\n\n`;
      });
      output.value = code;
    }
    // **** End of Globally Defined Editor Functions ****


    // **** Add Event Listeners (checking for element existence first) ****
    if (!editLeftContainer || !editRightContainer || !editLeftImg || !editRightImg ||
        !levelSelector || !saveEditorButton || !clearEditorButton || !output || !addNewLevelButton || !newLevelForm) {
      console.error("找不到編輯器模式所需的DOM元素. Editor functionality might be limited.");
      // You could potentially disable the editor tab here if needed
    } else {
      // Add Editor-Specific Event Listeners Here

      // 右圖容器點擊事件
      editRightContainer.addEventListener('click', function(e) {
        if (e.target === editRightImg) {
          addEditorDot(e); // Calls the globally defined function
        }
      });

      // 關卡選擇變化事件
      levelSelector.addEventListener('change', async function() {
        const selectedLevelId = parseInt(this.value);
        if (!isNaN(selectedLevelId)) {
          await loadLevelIntoEditor(selectedLevelId); // Calls the globally defined function
        }
      });

      // 清除按鈕事件
      clearEditorButton.addEventListener('click', clearEditorDisplay); // Calls the globally defined function

      // 保存按鈕事件
      saveEditorButton.addEventListener('click', async function() {
        if (editorDots.length === 0) {
          alert('沒有差異點可保存！');
          return;
        }
        const selectedLevelId = parseInt(levelSelector.value);
        if (isNaN(selectedLevelId)) {
            alert('請先選擇一個有效的圖片！');
            return;
        }
        const differencesData = editorDots.map(dot => { /* ... formatting logic ... */
            const posTop = String(dot.rightPosition.top);
            const posLeft = String(dot.rightPosition.left);
            const rightX = parseFloat(posLeft);
            const rightY = parseFloat(posTop);
          let locationHint = '';
            if (rightX < 33) locationHint += '左側'; else if (rightX < 66) locationHint += '中央'; else locationHint += '右側';
            if (rightY < 33) locationHint += '上方'; else if (rightY < 66) locationHint += '中部'; else locationHint += '下方';
            const description = `差異點位於${locationHint}區域`;
            return { position_top: posTop, position_left: posLeft, description: description };
        });
        console.log("Saving differences to API:", { levelId: selectedLevelId, differences: differencesData });
        try {
          const response = await fetch('/api/diffrent-game/differences', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ levelId: selectedLevelId, differences: differencesData })
          });
          if (response.ok) {
            alert(`已成功保存第 ${selectedLevelId} 張圖片數據！`);
            const gameLevelIndex = gameLevels.findIndex(gl => gl.id === selectedLevelId);
            if (gameLevelIndex !== -1 && gameLevelIndex === currentLevel) {
              console.log("Reloading current game level after editor save.");
              await loadLevel(currentLevel);
            }
          } else {
             const errorData = await response.json().catch(() => ({ message: '保存失敗，服務器返回錯誤' }));
             console.error("Save failed:", response.status, errorData);
             alert(`保存失敗： ${errorData.message || response.statusText}`);
          }
        } catch (error) {
          console.error('保存差異點出錯:', error);
          alert('網絡錯誤，無法保存數據。');
        }
      });

      // 新增圖片表單相關事件
      addNewLevelButton.addEventListener('click', function() {
          if(newLevelForm) newLevelForm.style.display = 'block';
       });
      const cancelNewLevelButton = document.getElementById('cancel-new-level');
      if (cancelNewLevelButton) {
          cancelNewLevelButton.addEventListener('click', function() {
              if(newLevelForm) {
                  newLevelForm.style.display = 'none';
                  const nameInput = document.getElementById('new-level-name');
                  const leftInput = document.getElementById('new-left-image');
                  const rightInput = document.getElementById('new-right-image');
                  if(nameInput) nameInput.value = '';
                  if(leftInput) leftInput.value = '';
                  if(rightInput) rightInput.value = '';
              }
          });
      }
      const submitNewLevelButton = document.getElementById('submit-new-level');
      if (submitNewLevelButton) {
          submitNewLevelButton.addEventListener('click', async function() {
              const nameInput = document.getElementById('new-level-name');
              const leftInput = document.getElementById('new-left-image');
              const rightInput = document.getElementById('new-right-image');
              if (!nameInput || !leftInput || !rightInput) return;
              const levelName = nameInput.value.trim();
              const leftImage = leftInput.value.trim();
              const rightImage = rightInput.value.trim();
              if (!levelName || !leftImage || !rightImage) { alert('請填寫所有欄位'); return; }
      try {
        const response = await fetch('/api/diffrent-game/levels', {
          method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify({ level_name: levelName, left_image_url: leftImage, right_image_url: rightImage, active: true })
        });
        if (response.ok) {
          alert('新圖片添加成功！');
                      if(newLevelForm) newLevelForm.style.display = 'none';
                      await populateLevelSelector(); // Reload selector
                  } else { alert('添加失敗，請稍後再試'); }
      } catch (error) {
        console.error('添加新圖片出錯:', error);
        alert('網絡錯誤，無法添加新圖片');
      }
    });
      }
    } // End of editor listener setup block

    // ----- 遊戲完成與過渡 (保持不變) -----
    // getLevelTransitionMessage, showCompletionMessage

    // ----- 計時器 (保持不變) -----
    // startTimer, pauseTimer, updateTimer

    // ----- 排行榜 (保持不變 - API calls look okay) -----
    // loadLeaderboardData, submitScore, displayLeaderboard, showLeaderboard etc.

    // ----- 初始調用 -----
    window.onload = async function() { // Make async
      // Initialize editor first (to populate selector)
      await populateLevelSelector(); // Wait for selector to be populated

      // Then setup the game (which might depend on selector/initial load)
      await setupNewGame(); // Wait for game setup

      // Set up event listeners that depend on elements being ready
      nextLevelButton.addEventListener('click', loadNextLevel); // loadNextLevel itself calls async loadLevel
      resetButton.addEventListener('click', setupNewGame); // setupNewGame calls async loadLevel

      // Ensure editor output area is initially updated
      updateOutput(); // Call this after potential initial editor load
    };

    function startTimer() {
        if (!timerRunning) {
            startTime = Date.now() - totalElapsedTime;
            timerInterval = setInterval(updateTimer, 1000);
            timerRunning = true;
            console.log("Timer started.");
        }
    }
    function pauseTimer() {
        if (timerRunning) {
            clearInterval(timerInterval);
            timerRunning = false;
            totalElapsedTime = Date.now() - startTime;
            console.log("Timer paused. Total elapsed time:", totalElapsedTime);
        }
    }
    function updateTimer() {
        if (!timerRunning) return;
        const currentTime = Date.now();
        const elapsedTime = currentTime - startTime;
        const seconds = Math.floor((elapsedTime / 1000) % 60);
        const minutes = Math.floor((elapsedTime / (1000 * 60)) % 60);
        timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        totalElapsedTime = elapsedTime;
    }

    function showCompletionMessage() {
      levelTransition.querySelector('h2').textContent = `恭喜完成第 ${currentLevel + 1} 關！`;
      if (currentLevel + 1 < gameLevels.length) {
        levelTransition.querySelector('p').textContent = `準備好挑戰第 ${currentLevel + 2} 關了嗎？`;
        nextLevelButton.textContent = `開始第 ${currentLevel + 2} 關`;
        nextLevelButton.disabled = false;
      } else {
        levelTransition.querySelector('p').textContent = `你已經完成所有關卡！`;
        nextLevelButton.textContent = `全部完成`;
        nextLevelButton.disabled = true;
      }
      levelTransition.classList.add('show');
    }
  </script>
</body>
</html>