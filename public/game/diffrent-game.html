<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>找出 5 個不同之處（帶簡易編輯器）</title>
  <style>
    body {
      font-family: sans-serif;
      background-color: #fffbe6;
      text-align: center;
      margin: 0;
      padding: 10px;
    }
    h1, h2 {
      color: #ff8c00;
      margin: 15px 0;
    }
    .tabs {
      display: flex;
      justify-content: center;
      margin: 20px 0;
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 100;
      flex-direction: column;
      gap: 10px;
    }
    .tab {
      padding: 10px 20px;
      background-color: #ff8c00;
      color: white;
      border: none;
      cursor: pointer;
      border-radius: 30px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      text-align: center;
      transition: all 0.3s ease;
      font-weight: bold;
    }
    .tab.active {
      background-color: #e67e00;
      transform: scale(1.1);
    }
    .tab-content {
      display: none;
    }
    .tab-content.active {
      display: block;
    }
    .game-container {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 10px;
      flex-wrap: wrap;
    }
    .image-container {
      position: relative;
      margin-bottom: 10px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
      border-radius: 12px;
      overflow: hidden;
    }
    .image-container img {
      width: 90vw;
      max-width: 400px;
      height: auto;
      border: none;
      border-radius: 10px;
      display: block;
    }
    .image-label {
      font-size: 16px;
      font-weight: bold;
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: rgba(255, 255, 255, 0.8);
      padding: 3px 8px;
      border-radius: 4px;
      z-index: 5;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .dot {
      position: absolute;
      width: 30px;
      height: 30px;
      border: 2px solid red;
      border-radius: 50%;
      cursor: pointer;
      transform: translate(-50%, -50%);
    }
    .dot.found {
      background-color: rgba(255, 0, 0, 0.5);
      animation: pulse 1s infinite alternate;
    }
    .dot.hint {
      border: 2px dashed gold;
      background-color: rgba(255, 255, 0, 0.3);
      box-shadow: 0 0 10px gold;
    }
    .editor-dot {
      position: absolute;
      width: 30px;
      height: 30px;
      border: 2px solid red;
      border-radius: 50%;
      background-color: rgba(255, 0, 0, 0.3);
      cursor: move;
      transform: translate(-50%, -50%);
    }
    .editor-dot.reference {
      background-color: rgba(255, 0, 0, 0.2);
      border: 2px dashed red;
      cursor: default;
    }
    .label {
      position: absolute;
      font-weight: bold;
      color: red;
      background-color: white;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      line-height: 20px;
      font-size: 12px;
      transform: translate(-50%, -50%);
      display: none;
    }
    .label.show {
      display: block;
    }
    .game-status-container {
      width: auto;
      max-width: 450px;
      margin: 0 auto 10px;
      padding: 8px 15px;
      background-color: #fff8e1;
      border-radius: 10px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      display: inline-block;
    }
    #status {
      margin: 0;
      font-size: 18px;
      color: #008800;
      font-weight: bold;
      display: inline-block;
    }
    #timer {
      margin-left: 15px;
      display: inline-block;
      color: #ff6600;
      font-weight: bold;
    }
    #timer-display {
      font-weight: bold;
    }
    #message {
      min-height: 24px;
      font-size: 16px;
      color: #0066cc;
      font-weight: bold;
      margin: 0 0 0 15px;
      display: inline-block;
    }
    .controls {
      margin: 10px 0 20px;
      display: flex;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .button {
      padding: 10px 15px;
      background-color: #ff8c00;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      transition: all 0.3s;
    }
    .button:hover {
      background-color: #e67e00;
      transform: scale(1.05);
    }
    .button.hint {
      background-color: #ffc107;
    }
    .button.reset {
      background-color: #6c757d;
    }
    .difference-list {
      max-width: 90%;
      margin: 20px auto;
      text-align: left;
      background-color: #fff;
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      display: none;
    }
    .difference-list.show {
      display: block;
    }
    .difference-list h3 {
      margin-top: 0;
      color: #ff8c00;
    }
    .difference-list ul {
      padding-left: 20px;
    }
    .difference-list li {
      margin-bottom: 8px;
    }
    @keyframes pulse {
      0% { transform: translate(-50%, -50%) scale(1); opacity: 0.7; }
      100% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.9; }
    }
    .editor-container {
      margin: 20px auto;
      max-width: 90%;
      background-color: #fff;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    #output {
      width: 100%;
      height: 150px;
      font-family: monospace;
      white-space: pre-wrap;
      text-align: left;
      background: #f5f5f5;
      padding: 10px;
      border: 1px solid #ccc;
      border-radius: 5px;
      overflow-y: auto;
      margin-top: 15px;
      font-size: 14px;
    }
    .edit-instructions {
      background-color: #fffbcc;
      padding: 10px;
      border-radius: 5px;
      margin-bottom: 20px;
      text-align: left;
    }
    .edit-instructions p {
      margin: 5px 0;
    }
    .edit-instructions ul {
      margin: 5px 0;
      padding-left: 25px;
    }
    .edit-instructions li {
      margin-bottom: 5px;
    }
    /* 手機版特別設定（螢幕寬度小於 768px） */
    @media (max-width: 768px) {
      body {
        padding: 5px;
      }
      h1 {
        font-size: 24px;
        margin: 10px 0;
      }
      .game-container {
        flex-direction: column;
        align-items: center;
        gap: 5px;
        margin-top: 5px;
      }
      .image-container {
        margin-bottom: 5px;
        width: 100%;
      }
      .image-container img {
        width: 100%;
        max-width: none;
        max-height: 40vh;
        object-fit: contain;
      }
      .controls {
        flex-direction: row;
        flex-wrap: wrap;
        margin: 5px 0 15px;
      }
      .button {
        width: auto;
        padding: 8px 12px;
        font-size: 14px;
      }
      .tabs {
        bottom: 10px;
        right: 10px;
      }
      .tab {
        padding: 8px 15px;
        font-size: 14px;
      }
      .game-status-container {
        margin: 5px auto;
        padding: 5px;
      }
      #status {
        font-size: 16px;
        margin: 5px 0;
      }
      #message {
        min-height: 20px;
        font-size: 14px;
      }
      .image-label {
        font-size: 14px;
        padding: 2px 6px;
      }
      .dot, .editor-dot {
        width: 24px;
        height: 24px;
      }
    }
    .level-transition {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      color: white;
      text-align: center;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.5s;
    }
    .level-transition.show {
      opacity: 1;
      visibility: visible;
    }
    .level-transition h2 {
      font-size: 32px;
      margin-bottom: 20px;
      color: #ffc107;
    }
    .level-transition p {
      font-size: 18px;
      margin-bottom: 30px;
    }
    .level-transition button {
      padding: 12px 24px;
      background-color: #ff8c00;
      color: white;
      border: none;
      border-radius: 5px;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
    }
    .level-transition button:hover {
      background-color: #e67e00;
      transform: scale(1.05);
    }
    .level-indicator {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: rgba(255, 255, 255, 0.8);
      padding: 5px 10px;
      border-radius: 20px;
      font-weight: bold;
      color: #ff8c00;
      z-index: 10;
    }
    .level-select {
      display: inline-block;
      position: relative;
      margin-left: 10px;
    }
    
    .level-select select {
      padding: 8px 12px;
      background-color: #6200ee;
      color: white;
      border: none;
      border-radius: 5px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
      padding-right: 30px;
    }
    
    .level-select::after {
      content: "▼";
      font-size: 10px;
      color: white;
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      pointer-events: none;
    }
    
    /* Leaderboard styles */
    .leaderboard-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      color: white;
      text-align: center;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.5s;
    }
    
    .leaderboard-container.show {
      opacity: 1;
      visibility: visible;
    }
    
    .leaderboard-content {
      background-color: #fff;
      color: #333;
      border-radius: 10px;
      padding: 20px;
      width: 90%;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
    }
    
    .leaderboard-content h2 {
      margin-top: 0;
      color: #ff8c00;
    }
    
    .leaderboard-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 15px;
    }
    
    .leaderboard-table th, .leaderboard-table td {
      padding: 8px;
      text-align: left;
      border-bottom: 1px solid #ddd;
    }
    
    .leaderboard-table th {
      background-color: #f2f2f2;
      position: sticky;
      top: 0;
    }
    
    .leaderboard-table tr:nth-child(even) {
      background-color: #f9f9f9;
    }
    
    .leaderboard-table tr:hover {
      background-color: #f1f1f1;
    }
    
    .name-entry-form {
      margin-top: 20px;
      padding: 15px;
      background-color: #f2f2f2;
      border-radius: 8px;
    }
    
    .name-entry-form input {
      padding: 8px 12px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 4px;
      margin-right: 10px;
    }
    
    .name-entry-form button {
      padding: 8px 15px;
      background-color: #ff8c00;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
    }
    
    .leaderboard-buttons {
      margin-top: 20px;
      display: flex;
      gap: 15px;
    }
    
    .leaderboard-buttons button {
      padding: 10px 20px;
      background-color: #ff8c00;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
    }
    
    .leaderboard-buttons button.secondary {
      background-color: #6c757d;
    }
  </style>
</head>
<body>
  
  <div class="tabs">
    <div class="tab active" data-tab="game">遊戲模式</div>
    <div class="tab" data-tab="editor">編輯器模式</div>
  </div>
  
  <div id="game-tab" class="tab-content active">
    <div class="game-container">
      <div class="image-container" id="left-image">
        <img src="https://sunnyyummy.onrender.com/uploads/1745928020704-22308.png" alt="原圖" />
        <!-- 差異點1: D vs O (第二個D變成O) -->
        <div class="dot" id="diff1" data-id="1" style="top: 30%; left: 67%;"></div>
        <div class="label" id="label1" style="top: 30%; left: 67%;">1</div>
        
        <!-- 差異點2: YOMMY vs YOMMY (MM vs M) -->
        <div class="dot" id="diff2" data-id="2" style="top: 70%; left: 67%;"></div>
        <div class="label" id="label2" style="top: 70%; left: 67%;">2</div>
        
        <!-- 差異點3: 右邊角色眼睛樣式 -->
        <div class="dot" id="diff3" data-id="3" style="top: 50%; left: 83%;"></div>
        <div class="label" id="label3" style="top: 50%; left: 83%;">3</div>
        
        <!-- 差異點4: 粉色帽子 -->
        <div class="dot" id="diff4" data-id="4" style="top: 50%; left: 38%;"></div>
        <div class="label" id="label4" style="top: 50%; left: 38%;">4</div>
        
        <!-- 差異點5: 中間角色表情 -->
        <div class="dot" id="diff5" data-id="5" style="top: 52%; left: 60%;"></div>
        <div class="label" id="label5" style="top: 52%; left: 60%;">5</div>
        
        <div class="image-label">原圖</div>
      </div>
      
      <div class="game-status-container">
        <div id="status">已找到：<span id="found-count">0</span> / <span id="total-count">5</span></div>
        <div id="timer" style="margin-left: 15px; display: inline-block; color: #ff6600; font-weight: bold;">時間：<span id="timer-display">00:00</span></div>
        <div id="message"></div>
      </div>
      
      <div class="image-container" id="right-image">
        <img src="https://sunnyyummy.onrender.com/uploads/1745928028967-85686.png" alt="修改版" />
        <!-- 差異點1: D vs O (第二個D變成O) -->
        <div class="dot" id="diff1-right" data-id="1" style="top: 30%; left: 67%;"></div>
        <div class="label" id="label1-right" style="top: 30%; left: 67%;">1</div>
        
        <!-- 差異點2: YOMMY vs YOMMY (MM vs M) -->
        <div class="dot" id="diff2-right" data-id="2" style="top: 70%; left: 67%;"></div>
        <div class="label" id="label2-right" style="top: 70%; left: 67%;">2</div>
        
        <!-- 差異點3: 右邊角色眼睛樣式 -->
        <div class="dot" id="diff3-right" data-id="3" style="top: 50%; left: 83%;"></div>
        <div class="label" id="label3-right" style="top: 50%; left: 83%;">3</div>
        
        <!-- 差異點4: 粉色帽子 -->
        <div class="dot" id="diff4-right" data-id="4" style="top: 50%; left: 38%;"></div>
        <div class="label" id="label4-right" style="top: 50%; left: 38%;">4</div>
        
        <!-- 差異點5: 中間角色表情 -->
        <div class="dot" id="diff5-right" data-id="5" style="top: 52%; left: 60%;"></div>
        <div class="label" id="label5-right" style="top: 52%; left: 60%;">5</div>
        
        <div class="image-label">修改版</div>
      </div>
    </div>
    
    <div class="controls">
      <button class="button hint" id="hint-button">提示</button>
      <button class="button" id="show-answers-button">顯示所有答案</button>
      <button class="button reset" id="reset-button">重新開始</button>
    </div>
  </div>
  
  <div id="editor-tab" class="tab-content">
    <h2>編輯器模式 ✏️</h2>
    
    <div class="edit-instructions">
      <p><strong>使用說明：</strong></p>
      <ul>
        <li>從下拉選單選擇要編輯的圖片</li>
        <li>只需在<strong>修改版圖片</strong>上添加差異點（最多5個）</li>
        <li>添加後可以點擊並拖動紅點調整位置</li>
        <li>點擊【保存】將差異點儲存</li>
        <li>點擊【清除所有】重新開始</li>
      </ul>
    </div>
    
    <div class="game-container">
      <div class="image-container" id="edit-left">
        <img src="https://sunnyyummy.onrender.com/uploads/1745928020704-22308.png" alt="原圖" id="left-edit-img" />
        <div class="image-label">原圖</div>
      </div>
      
      <div class="image-container" id="edit-right">
        <img src="https://sunnyyummy.onrender.com/uploads/1745928028967-85686.png" alt="修改版" id="right-edit-img" />
        <div class="image-label">修改版</div>
      </div>
    </div>
    
    <div class="controls">
      <button class="button reset" id="clear-editor">清除所有</button>
      <button class="button" id="save-editor" style="background-color: #28a745;">保存</button>
      <button class="button" id="load-editor" style="background-color: #007bff;">加載</button>
      <div class="level-select">
        <select id="level-selector">
          <option value="1">第一關圖片</option>
          <option value="2">第二關圖片</option>
          <option value="3">第三關圖片</option>
        </select>
      </div>
    </div>
    
    <div class="editor-container">
      <h3>生成的HTML代碼：</h3>
      <textarea id="output" readonly></textarea>
    </div>
  </div>
  
  <div class="level-transition" id="level-transition">
    <h2>恭喜完成第一關！</h2>
    <p>準備好挑戰第二關了嗎？</p>
    <button id="next-level-button">開始第二關</button>
  </div>
  
  <!-- 排行榜 -->
  <div class="leaderboard-container" id="leaderboard-container">
    <div class="leaderboard-content">
      <h2>排行榜</h2>
      <div id="name-entry-container" class="name-entry-form">
        <p>恭喜完成所有關卡！總耗時: <span id="final-time-display"></span></p>
        <input type="text" id="player-name" placeholder="請輸入您的名字" maxlength="20">
        <button id="submit-score">提交成績</button>
      </div>
      <table class="leaderboard-table">
        <thead>
          <tr>
            <th>排名</th>
            <th>名字</th>
            <th>時間</th>
            <th>日期</th>
          </tr>
        </thead>
        <tbody id="leaderboard-rows">
          <!-- 排行榜資料將動態填入 -->
        </tbody>
      </table>
      <div class="leaderboard-buttons">
        <button id="close-leaderboard" class="secondary">關閉</button>
        <button id="restart-game">重新開始</button>
      </div>
    </div>
  </div>
  
  <script>
    // 切換標籤頁
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        // 移除所有標籤和內容的active類
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        
        // 添加active類到當前標籤和對應的內容
        tab.classList.add('active');
        document.getElementById(tab.getAttribute('data-tab') + '-tab').classList.add('active');
      });
    });
    
    // ----- 遊戲模式代碼 -----
    const allLevels = [
      {
        // 第一關
        levelId: 1,
        storageKey: 'differentGameLevel1Data',
        leftImage: "https://sunnyyummy.onrender.com/uploads/1745928020704-22308.png",
        rightImage: "https://sunnyyummy.onrender.com/uploads/1745928028967-85686.png",
        // 保持第一關的初始點位數據，以便在localStorage沒有數據時使用
        differences: [
          { id: 'diff1', description: '差異點位於右上區域 (D vs O)', position: { top: '30%', left: '67%' } },
          { id: 'diff2', description: '差異點位於右下區域 (YOMMY vs YOMY)', position: { top: '70%', left: '67%' } },
          { id: 'diff3', description: '差異點位於右側眼睛樣式', position: { top: '50%', left: '83%' } },
          { id: 'diff4', description: '差異點位於左側粉色帽子', position: { top: '50%', left: '38%' } },
          { id: 'diff5', description: '差異點位於中間角色表情', position: { top: '52%', left: '60%' } }
        ]
      },
      {
        // 第二關
        levelId: 2,
        storageKey: 'differentGameLevel2Data',
        leftImage: "https://sunnyyummy.onrender.com/uploads/1745941255784-4084.png",
        rightImage: "https://sunnyyummy.onrender.com/uploads/1745941265630-74495.png",
        differences: [] // 初始為空，期望從 localStorage 載入
      },
      {
        // 第三關
        levelId: 3,
        storageKey: 'differentGameLevel3Data',
        leftImage: "https://sunnyyummy.onrender.com/uploads/1745944114845-94074.png",
        rightImage: "https://sunnyyummy.onrender.com/uploads/1745944121794-50612.png",
        differences: [ // 添加第三關的默認差異點 (如果 localStorage 沒有)
          { id: 'diff1', description: '第三關差異點A', position: { top: '20%', left: '25%' } },
          { id: 'diff2', description: '第三關差異點B', position: { top: '15%', left: '75%' } },
          { id: 'diff3', description: '第三關差異點C', position: { top: '50%', left: '50%' } },
          { id: 'diff4', description: '第三關差異點D', position: { top: '80%', left: '30%' } },
          { id: 'diff5', description: '第三關差異點E', position: { top: '75%', left: '70%' } }
        ]
      },
      {
        // 第四關 (範例)
        levelId: 4,
        storageKey: 'differentGameLevel4Data',
        leftImage: "https://sunnyyummy.onrender.com/uploads/1745945120161-78277.png",
        rightImage: "https://sunnyyummy.onrender.com/uploads/1745945134090-91988.png",
        differences: [ // 第四關的默認差異點
          { id: 'diff1', description: '第四關差異點1', position: { top: '25%', left: '15%' } },
          { id: 'diff2', description: '第四關差異點2', position: { top: '35%', left: '80%' } },
          { id: 'diff3', description: '第四關差異點3', position: { top: '60%', left: '50%' } },
          { id: 'diff4', description: '第四關差異點4', position: { top: '75%', left: '20%' } },
          { id: 'diff5', description: '第四關差異點5', position: { top: '85%', left: '70%' } }
        ]
      }
    ];

    // 創建 allLevels 的深拷貝以備修改
    const allLevelsData = JSON.parse(JSON.stringify(allLevels));

    // 替換getRandomLevels函數
    async function getRandomLevels() {
      try {
        const response = await fetch('/api/diffrent-game/levels/random');
        const levels = await response.json();
        console.log("隨機選擇的關卡:", levels.map(l => l.id));
        return levels;
      } catch (error) {
        console.error('無法獲取隨機關卡:', error);
        return []; // 返回空數組以防錯誤
      }
    }

    // ----- 遊戲狀態變數 -----
    let gameLevels = []; // 儲存當前遊戲會用到的隨機關卡
    let currentLevel = 0;
    // let differences = []; // 不再需要全局 differences

    let foundCount = 0;
    const foundDifferences = new Set();
    const messageElement = document.getElementById('message');
    const foundCountElement = document.getElementById('found-count');
    const totalCountElement = document.getElementById('total-count');
    const resetButton = document.getElementById('reset-button');
    const showAnswersButton = document.getElementById('show-answers-button');
    const hintButton = document.getElementById('hint-button');
    const levelTransition = document.getElementById('level-transition');
    const nextLevelButton = document.getElementById('next-level-button');

    // 計時器相關變數
    let timerInterval;
    let startTime;
    let totalElapsedTime = 0;
    let timerRunning = false;
    const timerDisplay = document.getElementById('timer-display');

    let answersVisible = false;

    // ----- DOM 元素 -----
    const leftImageContainer = document.getElementById('left-image');
    const rightImageContainer = document.getElementById('right-image');
    const leftImageElement = leftImageContainer.querySelector('img');
    const rightImageElement = rightImageContainer.querySelector('img');
    const levelIndicator = document.createElement('div'); // 關卡指示器只需要創建一次
    levelIndicator.className = 'level-indicator';
    leftImageContainer.appendChild(levelIndicator); // 添加到左圖容器


    // 初始化遊戲
    window.onload = function() {
      setupNewGame();
      // 設置關卡轉換按鈕事件
      nextLevelButton.addEventListener('click', loadNextLevel);
      // 設置重置按鈕事件
      resetButton.addEventListener('click', setupNewGame);
      // 初始化編輯器選項
      populateLevelSelector();
      // 確保編輯器輸出區域初始為空或提示
      updateOutput();
    };

    // 設置新遊戲或重置遊戲
    function setupNewGame() {
      console.log("Setting up new game...");
      gameLevels = getRandomLevels(); // 獲取新的隨機關卡列表
      currentLevel = 0;

      // 重置遊戲狀態
      foundDifferences.clear();
      foundCount = 0;
      foundCountElement.textContent = '0';
      messageElement.textContent = '';
      answersVisible = false;
      showAnswersButton.textContent = '顯示所有答案';

      // 重置計時器
      clearInterval(timerInterval);
      timerRunning = false;
      totalElapsedTime = 0;
      timerDisplay.textContent = '00:00';
      startTimer(); // 啟動計時器

      // 加載第一個關卡
      loadLevel(currentLevel);
    }

    // 加載指定索引的關卡
    function loadLevel(levelIndex) {
      if (levelIndex < 0 || levelIndex >= gameLevels.length) {
        console.error("無效的關卡索引:", levelIndex);
        // 可以顯示遊戲結束或其他訊息
        messageElement.textContent = "遊戲已完成或出現錯誤！";
        pauseTimer();
        return;
      }
      console.log(`Loading level index: ${levelIndex}`);
      const level = gameLevels[levelIndex];

      // 更新圖片
      leftImageElement.src = level.leftImage;
      rightImageElement.src = level.rightImage;

      // 更新關卡指示器 (顯示 1-based index)
      levelIndicator.textContent = `關卡 ${levelIndex + 1}`;

      // 清空舊的差異點顯示
      resetGameDisplay();

      // 嘗試從 localStorage 載入當前關卡的差異點數據
      // loadLevelDataFromStorage 會修改 level.differences 和 level.savedDots
      const loadedFromStorage = loadLevelDataFromStorage(level);
      console.log(`Level data loaded from storage for level ${level.levelId}?`, loadedFromStorage);

      // 根據更新後的 level.differences 和 level.savedDots 創建差異點
      createDifferencePoints();
    }


    // 載入下一關
    function loadNextLevel() {
      levelTransition.classList.remove('show');
      currentLevel++;
      if (currentLevel >= gameLevels.length) {
        // 所有隨機選擇的關卡都已完成
        messageElement.textContent = `恭喜！你完成所有 ${gameLevels.length} 個關卡！總耗時： ${timerDisplay.textContent}`;
        pauseTimer();
        // 可以選擇禁用按鈕或顯示完成畫面
        nextLevelButton.disabled = true;
        // 可以選擇自動回到第一關 (如果需要循環)
        // setupNewGame();
        return;
      }

      // 重置當前關卡的狀態 (找到的點數等)
      foundDifferences.clear();
      foundCount = 0;
      foundCountElement.textContent = '0';
      totalCountElement.textContent = '5'; // 默認值，將在loadLevel中更新
      messageElement.textContent = '';
      answersVisible = false;
      showAnswersButton.textContent = '顯示所有答案';

      // 加載下一個關卡
      loadLevel(currentLevel);
      
      // 確保計時器繼續運行 (關卡之間不重置)
      startTimer();
    }

    // 替換loadLevelDataFromStorage函數
    async function loadLevelDataFromStorage(level) {
      try {
        const response = await fetch(`/api/diffrent-game/differences/${level.id}`);
        const differences = await response.json();
        
        if (differences.length > 0) {
          // 處理差異點格式以符合前端需求
          level.differences = differences.map(diff => ({
            id: `diff${diff.id}`,
            description: diff.description
          }));
          
          level.savedDots = differences.map(diff => ({
            id: diff.id,
            rightPosition: {
              top: diff.position_top,
              left: diff.position_left
            }
          }));
          
          return true;
        }
        
        return false;
      } catch (error) {
        console.error(`從API載入關卡 ${level.id} 數據錯誤:`, error);
        return false;
      }
    }

    // 重置游戲顯示 (清除點和標籤)
    function resetGameDisplay() {
      // 移除已有的點和標籤
      document.querySelectorAll('#left-image .dot, #left-image .label, #right-image .dot, #right-image .label').forEach(el => {
        if (el !== levelIndicator) { // 不要移除關卡指示器
          el.remove();
        }
      });
      console.log("Game display reset (dots and labels removed).");
    }

    // 創建差異點
    function createDifferencePoints() {
      const level = gameLevels[currentLevel]; // 獲取當前關卡物件

      // 再次檢查 level 和 differences
      if (!level || !level.differences || !Array.isArray(level.differences)) {
          console.error("無法創建差異點：缺少關卡數據或有效的差異點定義", level);
          messageElement.textContent = "錯誤：無法載入關卡差異點！";
          return;
      }
      if (level.differences.length === 0) {
          console.warn(`關卡 ${level.levelId} 沒有定義差異點，將不創建任何點。`);
          messageElement.textContent = "此關卡尚未設置差異點。";
          foundCountElement.textContent = `0`;
          totalCountElement.textContent = `${level.differences.length}`; // 使用單獨的元素顯示總數
          return;
      }

      console.log(`為關卡 ${level.levelId} 創建 ${level.differences.length} 個差異點`);
      foundCountElement.textContent = `0`;
      totalCountElement.textContent = `${level.differences.length}`; // 使用單獨的元素顯示總數

      // 獲取保存的位置數據 (如果存在)
      const positionsData = level.savedDots || [];
      console.log("Using saved positions data:", positionsData);

      // 創建位置查找表 (基於點的數字 id)
      const positionMap = {};
      positionsData.forEach(dot => {
        const dataId = parseInt(dot.id); // savedDots 裡存的是數字 id
        if (!isNaN(dataId) && dot.rightPosition) {
           positionMap[dataId] = dot.rightPosition;
        } else {
           console.warn("保存的位置數據格式不正確或缺少 ID/Position:", dot);
        }
      });
       console.log("Constructed position map:", positionMap);


      // 遍歷當前關卡的 differences 陣列來創建 DOM 元素
      level.differences.forEach((diff, index) => {
         // 從 diff.id (例如 "diff3") 中提取數字 ID
         const diffIdMatch = diff.id ? String(diff.id).match(/\d+$/) : null;
         // **** 修改: 確保 diff.id 存在且是字符串或數字 ****
         if (!diff.id) {
             console.error("Difference definition is missing 'id':", diff);
             return; // 跳過這個無效的差異點
         }
         const dataId = diffIdMatch ? parseInt(diffIdMatch[0]) : (index + 1); // 如果 ID 格式不對，使用索引+1 作為備用

         if (isNaN(dataId)) {
           console.error("無法從差異點 ID 中提取數字:", diff.id);
           return; // 跳過這個差異點
         }

         // 查找該差異點的位置
         let position = positionMap[dataId];
         // 如果 localStorage 中沒有這個點的位置，嘗試從 differences 自身的定義中獲取
         if (!position && diff.position) {
             position = diff.position;
             console.log(`Using default position from definition for diff ${dataId}`);
         }
         // 如果兩者都沒有，提供一個簡單的預設分佈作為最後手段
         if (!position) {
             position = { top: `${15 + index * 15}%`, left: `${20 + index * 10}%` };
             console.warn(`Position not found for diff ${dataId}, using fallback position.`);
         }


         // --- 創建 DOM 元素 ---
         const dotIdBase = `diff${dataId}`;
         const labelIdBase = `label${dataId}`;

         // 左圖點和標籤
         createDotElement(leftImageContainer, dotIdBase, dataId, position);
         createLabelElement(leftImageContainer, labelIdBase, dataId, position);

         // 右圖點和標籤
         createDotElement(rightImageContainer, `${dotIdBase}-right`, dataId, position);
         createLabelElement(rightImageContainer, `${labelIdBase}-right`, dataId, position);
      });
       console.log("Difference points created in DOM.");
    }

    // 輔助函數：創建點元素
    function createDotElement(container, id, dataId, position) {
      const dot = document.createElement('div');
      dot.className = 'dot';
      dot.id = id;
      dot.setAttribute('data-id', dataId); // 使用數字 ID 作為 data-id
      dot.style.top = position.top;
      dot.style.left = position.left;
      dot.style.display = 'none'; // 初始隱藏
      // 檢查是否已找到 (雖然重置時會清除 set，但以防萬一)
      if (foundDifferences.has(String(dataId))) {
          dot.style.display = 'block';
          dot.classList.add('found');
      }
      container.appendChild(dot);
    }

    // 輔助函數：創建標籤元素
    function createLabelElement(container, id, dataId, position) {
      const label = document.createElement('div');
      label.className = 'label';
      label.id = id;
      label.style.top = position.top;
      label.style.left = position.left;
      label.textContent = dataId; // 顯示數字 ID
      if (foundDifferences.has(String(dataId))) {
          label.classList.add('show');
      }
      container.appendChild(label);
    }


    // 為游戲模式中的每個圖片容器添加點擊事件 (使用事件委派)
    leftImageContainer.addEventListener('click', function(e) {
      handleGameClick(e, this, false);
    });

    rightImageContainer.addEventListener('click', function(e) {
      handleGameClick(e, this, true);
    });

    function handleGameClick(e, container, isRight) {
      // 點擊的是圖片本身或容器，而不是點或標籤
      if (!e.target.matches('img') && e.target !== container) {
        return;
      }
      const level = gameLevels[currentLevel];
      if (!level || !level.differences || level.differences.length === 0) return; // 沒有點可以找

      // 計算點擊相對於圖片的位置
      const img = container.querySelector('img');
      const rect = img.getBoundingClientRect();
      const x = ((e.clientX - rect.left) / rect.width) * 100;
      const y = ((e.clientY - rect.top) / rect.height) * 100;
      console.log(`Click at (${x.toFixed(2)}%, ${y.toFixed(2)}%) on ${isRight ? 'right' : 'left'} image`);

      // 檢查是否點擊在差異點附近
      let found = false;
      for (let i = 0; i < level.differences.length; i++) {
        const diff = level.differences[i];
        // **** 修改: 從 diff.id 提取 dataId ****
        const diffIdMatch = String(diff.id).match(/\d+$/);
        if (!diffIdMatch) continue;
        const dataId = diffIdMatch[0]; // 獲取數字 ID (字符串形式)

        const dotElementId = `diff${dataId}${isRight ? '-right' : ''}`;
        const diffElement = document.getElementById(dotElementId);

        if (!diffElement) {
             console.warn(`Dot element not found for id: ${dotElementId}`);
             continue;
        }

        const diffX = parseFloat(diffElement.style.left);
        const diffY = parseFloat(diffElement.style.top);

        // 計算點擊點與差異點的距離 (使用視口百分比的簡單距離)
        // 注意：這不是最精確的方法，圓的大小是固定的像素
        const distance = Math.sqrt(Math.pow(x - diffX, 2) + Math.pow(y - diffY, 2));
        const clickRadius = 5; // 點擊半徑（百分比），可調整

        console.log(`Checking distance to diff ${dataId}: ${distance.toFixed(2)}% (Target: < ${clickRadius}%)`);

        if (distance < clickRadius) { // 調整點擊範圍
          if (!foundDifferences.has(dataId)) {
            console.log(`Found difference ${dataId}!`);
            foundDifferences.add(dataId);
            foundCount++;
            foundCountElement.textContent = `${foundCount}`;

            // 顯示左右兩邊的點和標籤
            document.querySelectorAll(`.dot[data-id="${dataId}"]`).forEach(dot => {
              dot.style.display = 'block';
              dot.classList.add('found');
            });
            document.querySelectorAll(`.label[data-id="${dataId}"]`).forEach(label => {
              label.classList.add('show');
            });

            messageElement.textContent = `找到了: ${diff.description}`;

            // 檢查是否找到所有差異點
            if (foundCount === level.differences.length) {
               console.log("All differences found for this level!");
               setTimeout(showCompletionMessage, 1000); // 延遲顯示過關信息
            }
          } else {
              console.log(`Difference ${dataId} already found.`);
              messageElement.textContent = `這個點已經找到了！`;
              setTimeout(() => { messageElement.textContent = ''; }, 1500);
          }
          found = true;
          break; // 找到一個就停止檢查
        }
      }

      // 如果點擊不在任何差異點附近
      if (!found && e.target.matches('img')) {
        console.log("Missed.");
        messageElement.textContent = '請再試一次';
        setTimeout(() => { messageElement.textContent = ''; }, 1000);
      }
    }

    // 提示按鈕功能
    hintButton.addEventListener('click', () => {
      const level = gameLevels[currentLevel];
      if (!level || !level.differences) return;

      if (foundCount >= level.differences.length) {
        messageElement.textContent = '你已經找到所有不同之處！';
        return;
      }

      // 找出尚未找到的差異點的 data-id
      const notFoundIds = level.differences
          .map(diff => {
              const match = String(diff.id).match(/\d+$/);
              return match ? match[0] : null;
          })
          .filter(id => id && !foundDifferences.has(id));

      if (notFoundIds.length > 0) {
        // 隨機選擇一個未找到的 data-id
        const randomIndex = Math.floor(Math.random() * notFoundIds.length);
        const hintDataId = notFoundIds[randomIndex];
        const hintDiff = level.differences.find(d => String(d.id).endsWith(hintDataId));

        console.log(`Hint for difference: ${hintDataId}`);

        // 顯示提示的點（閃爍效果）
        document.querySelectorAll(`.dot[data-id="${hintDataId}"]`).forEach(dot => {
            dot.style.display = 'block';
            dot.classList.add('hint');
            // 移除可能存在的 found 樣式，以顯示 hint 樣式
            dot.classList.remove('found');
        });

        messageElement.textContent = `提示：${hintDiff ? hintDiff.description : '一個未找到的點'}`;

        // 3秒後隱藏提示效果
        setTimeout(() => {
          if (!foundDifferences.has(hintDataId)) { // 確保在提示期間沒有被找到
             document.querySelectorAll(`.dot[data-id="${hintDataId}"]`).forEach(dot => {
                 dot.style.display = 'none'; // 隱藏回去
                 dot.classList.remove('hint');
             });
             messageElement.textContent = '';
          } else {
              // 如果在提示期間被找到了，只需移除 hint 樣式
              document.querySelectorAll(`.dot[data-id="${hintDataId}"]`).forEach(dot => {
                  dot.classList.remove('hint');
              });
          }
        }, 3000);
      }
    });

    // 顯示/隱藏所有答案
    showAnswersButton.addEventListener('click', () => {
      answersVisible = !answersVisible;
      const level = gameLevels[currentLevel];
      if (!level || !level.differences) return;

      level.differences.forEach(diff => {
          const match = String(diff.id).match(/\d+$/);
          if (!match) return;
          const dataId = match[0];

          const dots = document.querySelectorAll(`.dot[data-id="${dataId}"]`);
          const labels = document.querySelectorAll(`.label[data-id="${dataId}"]`);

          if (answersVisible) {
              dots.forEach(dot => {
                  dot.style.display = 'block';
                  if (!foundDifferences.has(dataId)) {
                      dot.classList.add('hint'); // 對未找到的用提示樣式
                      dot.classList.remove('found');
                  }
              });
              labels.forEach(label => label.classList.add('show'));
          } else {
              // 隱藏答案
              dots.forEach(dot => {
                  if (!foundDifferences.has(dataId)) {
                      dot.style.display = 'none'; // 隱藏未找到的
                      dot.classList.remove('hint');
                  } else {
                      dot.classList.remove('hint'); // 確保已找到的沒有 hint 樣式
                  }
              });
              labels.forEach(label => {
                  if (!foundDifferences.has(dataId)) {
                      label.classList.remove('show'); // 隱藏未找到的標籤
                  }
              });
          }
      });

      showAnswersButton.textContent = answersVisible ? '隱藏答案' : '顯示所有答案';
      messageElement.textContent = answersVisible ? '已顯示所有答案' : '';
    });


    // ----- 編輯器模式代碼 -----
    let editorDots = []; // { id: number, description: string, rightPosition: {top: string, left: string} }
    let dotCounter = 1; // 用於生成新的點 ID
    const output = document.getElementById('output');
    const editLeftContainer = document.getElementById('edit-left');
    const editRightContainer = document.getElementById('edit-right');
    const editLeftImg = document.getElementById('left-edit-img');
    const editRightImg = document.getElementById('right-edit-img');
    const clearEditorButton = document.getElementById('clear-editor');
    const saveEditorButton = document.getElementById('save-editor');
    const loadEditorButton = document.getElementById('load-editor');
    const levelSelector = document.getElementById('level-selector');


    // 更新HTML代碼輸出
    function updateOutput() {
      if (editorDots.length === 0) {
        output.value = '// 點擊右側修改版圖片添加差異點，代碼將顯示在這裡';
        return;
      }
      let code = `<!-- ${editorDots.length} 個差異點位置 (基於右圖) -->\n\n`;
      editorDots.sort((a, b) => a.id - b.id).forEach(dot => {
        const position = dot.rightPosition;
        const dataId = dot.id;
        const description = dot.description || `差異點 ${dataId}`;

        code += `<!-- ${description} -->\n`;
        // 左圖 (遊戲模式用)
        code += `<div class="dot" id="diff${dataId}" data-id="${dataId}" style="top: ${position.top}; left: ${position.left};"></div>\n`;
        code += `<div class="label" id="label${dataId}" style="top: ${position.top}; left: ${position.left};">${dataId}</div>\n`;
        // 右圖 (遊戲模式用)
        code += `<div class="dot" id="diff${dataId}-right" data-id="${dataId}" style="top: ${position.top}; left: ${position.left};"></div>\n`;
        code += `<div class="label" id="label${dataId}-right" style="top: ${position.top}; left: ${position.left};">${dataId}</div>\n\n`;
      });
      output.value = code;
    }

    // 填充編輯器關卡選擇下拉框
    function populateLevelSelector() {
        levelSelector.innerHTML = ''; // 清空現有選項
        allLevelsData.forEach(level => {
            const option = document.createElement('option');
            option.value = level.levelId; // 使用 levelId 作為 value
            option.textContent = `第 ${level.levelId} 張圖片`;
            levelSelector.appendChild(option);
        });
        // 觸發一次 change 事件以加載第一個關卡的圖片和數據
        levelSelector.dispatchEvent(new Event('change'));
    }

    // 編輯器關卡選擇變化事件
    levelSelector.addEventListener('change', function() {
      const selectedLevelId = parseInt(this.value);
      console.log(`選擇圖片: ${selectedLevelId}`);

      // 找到對應的關卡數據
      const selectedLevelData = allLevelsData.find(level => level.levelId === selectedLevelId);

      if (!selectedLevelData) {
          alert(`錯誤：找不到 ID 為 ${selectedLevelId} 的圖片！`);
          console.error(`Level data not found for ID: ${selectedLevelId}`);
          return;
      }

      // 清除編輯器現有點和狀態
      clearEditorDisplay();

      // 更新編輯器圖片
      editLeftImg.src = selectedLevelData.leftImage;
      editRightImg.src = selectedLevelData.rightImage;

      // 嘗試從 localStorage 載入該關卡的數據到編輯器
      loadEditorData(selectedLevelData.storageKey, selectedLevelId);
    });

    // 從 localStorage 加載數據到編輯器
    function loadEditorData(storageKey, levelId) {
        const savedData = localStorage.getItem(storageKey);
        if (!savedData) {
            console.log(`未找到 ${storageKey} 的編輯器數據，編輯器將為空。`);
            updateOutput(); // 確保輸出區域更新
            return; // 沒有數據可加載
        }

        try {
            const data = JSON.parse(savedData);
            // 確保 data.dots 存在且是一個陣列
            const dotsArray = data.dots && Array.isArray(data.dots) ? data.dots : [];

             if (dotsArray.length > 0) {
                 // 恢復點計數器 (找到最大 ID + 1)
                 const maxId = dotsArray.reduce((max, dot) => Math.max(max, parseInt(dot.id) || 0), 0);
                 dotCounter = maxId + 1;

                 // 重新創建編輯器中的點
                 dotsArray.forEach(dotData => {
                      if (dotData.id === undefined || !dotData.rightPosition) {
                          console.warn("從存儲載入的編輯器點數據格式不完整:", dotData);
                          return; // 跳過這個點
                      }
                      // 創建編輯器點 (參考點和可拖動點)
                      createEditorDotElements(dotData.id, dotData.rightPosition);
                 });

                 // 更新編輯器內部數據 editorDots
                 editorDots = dotsArray.map(d => ({
                     id: d.id,
                     description: data.differences?.find(df => String(df.id).endsWith(d.id))?.description || `差異點 ${d.id}`,
                     rightPosition: d.rightPosition,
                 }));

                 updateOutput(); // 更新代碼輸出
                 console.log(`成功從 ${storageKey} 載入 ${editorDots.length} 個點到編輯器`);
            } else {
                console.log(`${storageKey} 中找到數據，但 dots 陣列為空或無效。`);
                updateOutput();
            }
        } catch (error) {
            console.error(`從 ${storageKey} 載入編輯器數據錯誤:`, error);
            alert(`加載第 ${levelId} 張圖片編輯器數據時發生錯誤！`);
            clearEditorDisplay(); // 出錯時清空編輯器
        }
    }

    // Load 按鈕事件 (現在只是觸發 levelSelector 的 change 事件)
    loadEditorButton.addEventListener('click', function() {
        const selectedLevelId = parseInt(levelSelector.value);
        const storageKey = allLevelsData.find(l => l.levelId === selectedLevelId)?.storageKey;
        if (storageKey) {
            loadEditorData(storageKey, selectedLevelId);
            alert(`已嘗試從存儲加載第 ${selectedLevelId} 張圖片數據。`);
        } else {
            alert("無法確定要加載哪張圖片的數據。");
        }
    });


    // 清除編輯器顯示和狀態
    function clearEditorDisplay() {
        // 移除所有編輯器模式的點
        document.querySelectorAll('#editor-tab .editor-dot').forEach(dot => {
          dot.remove();
        });
        // 重置數據
        editorDots = [];
        dotCounter = 1; // 重置計數器
        updateOutput();
        console.log("Editor display cleared.");
    }

    // 清除編輯器按鈕事件
    clearEditorButton.addEventListener('click', clearEditorDisplay);


    // 為編輯器模式的右圖容器添加點擊事件 (添加新點)
    editRightContainer.addEventListener('click', function(e) {
      // 僅當點擊目標是圖片本身時才添加新點
      if (e.target === editRightImg) {
        addEditorDot(e);
      }
    });


    // 添加編輯器模式中的差異點
    function addEditorDot(e) {
      if (editorDots.length >= 5) {
        alert('最多只能添加5個差異點！');
        return;
      }

      // 計算點擊相對於圖片的位置
      const rect = editRightImg.getBoundingClientRect();
      const x = ((e.clientX - rect.left) / rect.width) * 100;
      const y = ((e.clientY - rect.top) / rect.height) * 100;
      const position = { top: y.toFixed(2) + '%', left: x.toFixed(2) + '%' };
      const newDotId = dotCounter;

      console.log(`Adding editor dot ${newDotId} at`, position);

      // 創建 DOM 元素 (參考點和可拖動點)
      createEditorDotElements(newDotId, position);

      // 更新內部數據
      editorDots.push({
        id: newDotId,
        description: `差異點 ${newDotId}`,
        rightPosition: position
      });
      dotCounter++; // 增加計數器

      // 更新輸出代碼
      updateOutput();
    }

    // 輔助函數: 創建編輯器點的 DOM 元素
    function createEditorDotElements(id, position) {
        // 在右圖創建可拖動點
        const rightDot = document.createElement('div');
        rightDot.className = 'editor-dot';
        rightDot.setAttribute('data-id', id);
        rightDot.style.top = position.top;
        rightDot.style.left = position.left;
        editRightContainer.appendChild(rightDot);
        makeDotDraggable(rightDot); // 使其可拖動

        // 在左圖創建對應的參考點
        const leftDot = document.createElement('div');
        leftDot.className = 'editor-dot reference'; // 參考點樣式
        leftDot.setAttribute('data-id', id); // 關聯 ID
        leftDot.style.top = position.top;
        leftDot.style.left = position.left;
        editLeftContainer.appendChild(leftDot);
    }


    // 讓編輯器點可拖曳
    function makeDotDraggable(element) {
      element.addEventListener('mousedown', startDragDot);
      element.addEventListener('touchstart', startDragDot, { passive: false }); // passive: false for preventDefault
    }

    function startDragDot(e) {
      // e.preventDefault(); // 阻止默認的拖動行為 (例如圖片拖動)
      e.stopPropagation(); // 阻止事件冒泡

      const dot = e.target;
      if (!dot.classList.contains('editor-dot') || dot.classList.contains('reference')) {
        return; // 確保是可拖動的點
      }

      const dotId = dot.getAttribute('data-id');
      // 找到對應的參考點
      const referenceDot = editLeftContainer.querySelector(`.editor-dot.reference[data-id="${dotId}"]`);
      const containerRect = editRightImg.getBoundingClientRect();

      function moveHandler(moveEvent) {
         // For touch events, prevent scrolling while dragging
         if (moveEvent.type === 'touchmove') {
            moveEvent.preventDefault();
         }

         let clientX, clientY;
         if (moveEvent.type === 'mousemove' || moveEvent.type === 'mousedown') {
           clientX = moveEvent.clientX;
           clientY = moveEvent.clientY;
         } else if (moveEvent.type === 'touchmove' || moveEvent.type === 'touchstart') {
           clientX = moveEvent.touches[0].clientX;
           clientY = moveEvent.touches[0].clientY;
         } else {
             return; // Unknown event type
         }

         // 計算新位置 (百分比)
         let x = ((clientX - containerRect.left) / containerRect.width) * 100;
         let y = ((clientY - containerRect.top) / containerRect.height) * 100;

         // 限制在圖片範圍內 (稍微留一點邊緣)
         x = Math.max(1, Math.min(99, x));
         y = Math.max(1, Math.min(99, y));
         const newPosition = { top: y.toFixed(2) + '%', left: x.toFixed(2) + '%' };

         // 更新點的位置
         dot.style.left = newPosition.left;
         dot.style.top = newPosition.top;

         // 同步更新參考點位置
         if (referenceDot) {
           referenceDot.style.left = newPosition.left;
           referenceDot.style.top = newPosition.top;
         }

         // 更新內部數據
         const dotData = editorDots.find(d => d.id == dotId);
         if (dotData) {
           dotData.rightPosition = newPosition;
           // 更新代碼輸出 (可以考慮在拖動結束時才更新，以提高性能)
           updateOutput();
         }
      }

      function endDragHandler() {
        document.removeEventListener('mousemove', moveHandler);
        document.removeEventListener('mouseup', endDragHandler);
        document.removeEventListener('touchmove', moveHandler);
        document.removeEventListener('touchend', endDragHandler);
        console.log(`Dot ${dotId} drag ended at`, dot.style.top, dot.style.left);
        // 可以在這裡觸發一次最終的 updateOutput()
      }

      // 添加事件監聽器到 document，這樣即使鼠標移出元素也能繼續拖動
      document.addEventListener('mousemove', moveHandler);
      document.addEventListener('mouseup', endDragHandler);
      document.addEventListener('touchmove', moveHandler, { passive: false });
      document.addEventListener('touchend', endDragHandler);
    }


    // 保存編輯器內容到本地存儲
    saveEditorButton.addEventListener('click', function() {
      if (editorDots.length === 0) {
        alert('沒有差異點可保存！');
        return;
      }

      // 獲取當前編輯的關卡 ID 和 storageKey
      const selectedLevelId = parseInt(levelSelector.value);
      const targetLevel = allLevelsData.find(level => level.levelId === selectedLevelId);

      if (!targetLevel) {
           alert('錯誤：無法確定要保存到哪張圖片！');
           console.error("Cannot find target level data for saving:", selectedLevelId);
           return;
      }
      const storageKey = targetLevel.storageKey;

      // 更新描述 (基於最終位置)
      editorDots.forEach((dot, index) => {
        const rightX = parseFloat(dot.rightPosition.left);
        const rightY = parseFloat(dot.rightPosition.top);
        let locationHint = '';
        if (rightX < 33) locationHint += '左側';
        else if (rightX < 66) locationHint += '中央';
        else locationHint += '右側';
        if (rightY < 33) locationHint += '上方';
        else if (rightY < 66) locationHint += '中部';
        else locationHint += '下方';
        dot.description = `差異點位於${locationHint}區域`;
        // 確保 id 是數字
        dot.id = parseInt(dot.id);
      });

      // 準備保存的數據 (符合遊戲模式加載的格式)
      const saveData = {
        differences: editorDots.map(dot => ({
          id: `diff${dot.id}`, // 遊戲模式需要 "diffX" 格式
          description: dot.description
          // 保存時不需要 position，因為會從 dots 讀取
        })).sort((a, b) => parseInt(a.id.match(/\d+/)[0]) - parseInt(b.id.match(/\d+/)[0])), // 按ID排序
        dots: editorDots.map(dot => ({ // 保存點的數字 id 和位置
            id: dot.id,
            rightPosition: dot.rightPosition
        })).sort((a, b) => a.id - b.id) // 按ID排序
      };

      try {
           localStorage.setItem(storageKey, JSON.stringify(saveData));
           alert(`已成功保存第 ${selectedLevelId} 張圖片數據到 ${storageKey}！`);
           console.log(`Saved data to ${storageKey}:`, saveData);

           // 可選：如果遊戲正在進行且剛好是這一關，可以嘗試更新遊戲狀態
           const gameLevelIndex = gameLevels.findIndex(gl => gl.levelId === selectedLevelId);
           if (gameLevelIndex !== -1 && gameLevelIndex === currentLevel) {
               console.log("Currently playing level was edited, reloading game mode points...");
               loadLevel(currentLevel); // 重新加載當前關卡數據和點
           } else if (gameLevelIndex !== -1) {
                // 如果編輯的不是當前關卡，只需更新 gameLevels 中的數據以備後用
                // loadLevelDataFromStorage 會修改 gameLevels[gameLevelIndex]
                loadLevelDataFromStorage(gameLevels[gameLevelIndex]);
                console.log(`Updated gameLevels data for image ${selectedLevelId} for future use.`);
           }

      } catch (error) {
           console.error(`保存到 ${storageKey} 失敗:`, error);
           alert(`保存第 ${selectedLevelId} 張圖片數據時出錯！請檢查瀏覽器控制台。`);
      }
    });


    // ----- 遊戲完成與過渡 -----

    // 取得關卡轉換文字
    function getLevelTransitionMessage() {
      // currentLevel 是 0-based index
      const nextLevelNum = currentLevel + 2; // 下一關的編號 (1-based)
      if (currentLevel < gameLevels.length - 1) {
        return `恭喜完成第 ${currentLevel + 1} 關！`;
      } else {
        // 這是最後一關了
        return "恭喜完成所有關卡！";
      }
    }

    // 顯示過關訊息
    function showCompletionMessage() {
      const level = gameLevels[currentLevel];
      // 基本的完成信息
      messageElement.textContent = `恭喜！你找到了第 ${currentLevel + 1} 關的所有 ${level.differences.length} 個不同之處！`;

      // 檢查是否還有下一關
      if (currentLevel < gameLevels.length - 1) {
        // 還有下一關
        pauseTimer(); // 暫停計時器，直到點擊下一關按鈕
        setTimeout(() => {
          // 更新過關訊息
          document.querySelector('#level-transition h2').textContent = getLevelTransitionMessage();
          document.querySelector('#level-transition p').textContent = `準備好挑戰第 ${currentLevel + 2} 關了嗎？`;
          document.getElementById('next-level-button').textContent = `開始第 ${currentLevel + 2} 關`;
          nextLevelButton.disabled = false; // 確保按鈕可用
          levelTransition.classList.add('show'); // 顯示過渡畫面
        }, 1500); // 延遲顯示過渡畫面
      } else {
        // 這是最後一關
        pauseTimer(); // 停止計時器
        messageElement.textContent = `太棒了！你完成了全部 ${gameLevels.length} 個關卡！總耗時： ${timerDisplay.textContent}`;
        // 顯示排行榜並讓玩家輸入名字
        setTimeout(() => {
          showLeaderboard(true);
        }, 1500);
      }
    }

    // 確保計時器啟動/停止/更新函數存在且正確
    function startTimer() {
        if (!timerRunning) {
            startTime = Date.now() - totalElapsedTime; // 使用 Date.now() 兼容性更好
            timerInterval = setInterval(updateTimer, 1000);
            timerRunning = true;
            console.log("Timer started.");
        }
    }
    function pauseTimer() {
        if (timerRunning) {
            clearInterval(timerInterval);
            timerRunning = false;
            // 確保 totalElapsedTime 保存目前為止的總時間
            totalElapsedTime = Date.now() - startTime;
            console.log("Timer paused. Total elapsed time:", totalElapsedTime);
        }
    }
    function updateTimer() {
        if (!timerRunning) return;
        const currentTime = Date.now();
        const elapsedTime = currentTime - startTime;
        const seconds = Math.floor((elapsedTime / 1000) % 60);
        const minutes = Math.floor((elapsedTime / (1000 * 60)) % 60);
        timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        // 將當前已過時間保存到 totalElapsedTime，以便在暫停時使用
        totalElapsedTime = elapsedTime;
    }

    // 排行榜相關函數
    const leaderboardContainer = document.getElementById('leaderboard-container');
    const leaderboardRows = document.getElementById('leaderboard-rows');
    const playerNameInput = document.getElementById('player-name');
    const submitScoreButton = document.getElementById('submit-score');
    const closeLeaderboardButton = document.getElementById('close-leaderboard');
    const restartGameButton = document.getElementById('restart-game');
    const nameEntryContainer = document.getElementById('name-entry-container');
    const finalTimeDisplay = document.getElementById('final-time-display');
    
    // 排行榜常數
    const LEADERBOARD_KEY = 'differentGameLeaderboard';
    const MAX_LEADERBOARD_ENTRIES = 50;
    
    // 加載排行榜數據
    function loadLeaderboardData() {
      const savedData = localStorage.getItem(LEADERBOARD_KEY);
      if (savedData) {
        try {
          return JSON.parse(savedData);
        } catch (error) {
          console.error('無法解析排行榜數據:', error);
          return [];
        }
      }
      return [];
    }
    
    // 保存排行榜數據
    function saveLeaderboardData(data) {
      try {
        localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(data));
        return true;
      } catch (error) {
        console.error('保存排行榜數據失敗:', error);
        return false;
      }
    }
    
    // 添加新的排行榜條目
    function addLeaderboardEntry(name, timeInSeconds, shouldSave = true) {
      const leaderboard = loadLeaderboardData();
      
      // 創建新條目
      const newEntry = {
        name: name.trim() || '匿名玩家',
        time: timeInSeconds,
        date: new Date().toISOString()
      };
      
      // 添加並排序
      leaderboard.push(newEntry);
      leaderboard.sort((a, b) => a.time - b.time);
      
      // 保留前 MAX_LEADERBOARD_ENTRIES 條
      const trimmedLeaderboard = leaderboard.slice(0, MAX_LEADERBOARD_ENTRIES);
      
      // 保存回 localStorage
      if (shouldSave) {
        saveLeaderboardData(trimmedLeaderboard);
      }
      
      return trimmedLeaderboard;
    }
    
    // 顯示排行榜
    function displayLeaderboard(playerTime = null) {
      const leaderboard = loadLeaderboardData();
      leaderboardRows.innerHTML = '';
      
      // 檢查玩家時間是否符合排名
      let playerRank = -1;
      if (playerTime !== null) {
        playerRank = leaderboard.findIndex(entry => entry.time === playerTime);
      }
      
      // 填充表格
      leaderboard.forEach((entry, index) => {
        const row = document.createElement('tr');
        if (playerRank === index) {
          row.style.backgroundColor = '#fffacd';
          row.style.fontWeight = 'bold';
        }
        
        // 格式化時間
        const minutes = Math.floor(entry.time / 60);
        const seconds = entry.time % 60;
        const formattedTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        
        // 格式化日期
        const date = new Date(entry.date);
        const formattedDate = `${date.getFullYear()}/${(date.getMonth() + 1).toString().padStart(2, '0')}/${date.getDate().toString().padStart(2, '0')}`;
        
        row.innerHTML = `
          <td>${index + 1}</td>
          <td>${entry.name}</td>
          <td>${formattedTime}</td>
          <td>${formattedDate}</td>
        `;
        leaderboardRows.appendChild(row);
      });
      
      // 如果排行榜為空，顯示提示訊息
      if (leaderboard.length === 0) {
        const emptyRow = document.createElement('tr');
        emptyRow.innerHTML = '<td colspan="4" style="text-align: center;">目前還沒有紀錄，成為第一名吧！</td>';
        leaderboardRows.appendChild(emptyRow);
      }
    }
    
    // 提交分數並顯示排行榜
    function submitScore() {
      const playerName = playerNameInput.value.trim() || '匿名玩家';
      const timeInSeconds = Math.floor(totalElapsedTime / 1000);
      
      // 添加到排行榜
      const updatedLeaderboard = addLeaderboardEntry(playerName, timeInSeconds);
      
      // 隱藏名字輸入框
      nameEntryContainer.style.display = 'none';
      
      // 顯示更新後的排行榜 (高亮玩家成績)
      displayLeaderboard(timeInSeconds);
    }
    
    // 初始化排行榜事件監聽器
    submitScoreButton.addEventListener('click', submitScore);
    
    closeLeaderboardButton.addEventListener('click', () => {
      leaderboardContainer.classList.remove('show');
    });
    
    restartGameButton.addEventListener('click', () => {
      leaderboardContainer.classList.remove('show');
      setupNewGame();
    });
    
    // 顯示排行榜視窗
    function showLeaderboard(showNameEntry = true) {
      // 設置名字輸入區域的可見性
      nameEntryContainer.style.display = showNameEntry ? 'block' : 'none';
      
      // 如果需要顯示名字輸入，填入最終時間
      if (showNameEntry) {
        finalTimeDisplay.textContent = timerDisplay.textContent;
      }
      
      // 顯示排行榜數據
      displayLeaderboard();
      
      // 顯示排行榜視窗
      leaderboardContainer.classList.add('show');
    }

  </script>
</body>
</html>