<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <!-- Viewport from bridge-game, crucial for interaction -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <!-- Title and Description from wheel-game, adapted -->
    <title>SunnyYummy 互動遊戲 - 玻璃橋挑戰</title>
    <meta name="description" content="SunnyYummy 互動遊戲 - 魷魚遊戲風格的玻璃橋接力挑戰。">
    <!-- Favicon and PWA icons (from wheel-game, assuming paths are correct) -->
    <link rel="icon" href="/images/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
    <!-- Fonts (from wheel-game) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Combined CSS -->
    <style>
        /* --- Styles from wheel-game.html (Header, Nav, Footer) --- */
        body {
            /* Base styles, adjusted for bridge game */
            font-family: 'Noto Sans TC', sans-serif;
            display: flex;
            flex-direction: column;
            background-color: #1a1a2e; /* Bridge game background */
            color: white; /* Bridge game default text color */
            padding: 0;
            margin: 0;
            min-height: 100vh;
            width: 100%;
            box-sizing: border-box;
            /* overflow: hidden; /* REMOVED from body initially */
        }

        /* Page Title Header */
        .page-title-header {
            background-color: #FFB74D; /* wheel-game style */
            padding: 1rem;
            text-align: center;
            width: 100%;
            flex-shrink: 0; /* Prevent header from shrinking */
        }

        .page-title {
            color: #424242; /* wheel-game style */
            margin: 0;
            font-size: 1.5em; /* Adjust size if needed */
        }

        /* Category Navigation */
        .category-nav {
            display: flex;
            justify-content: center;
            gap: 1rem;
            padding: 0.8rem 0; /* Slightly reduced padding */
            background-color: #f0f0f0; /* wheel-game style */
            width: 100%;
            flex-shrink: 0; /* Prevent nav from shrinking */
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }

        .category-nav a {
            text-decoration: none;
            color: #333; /* wheel-game style */
            padding: 0.4rem 0.8rem; /* Slightly reduced padding */
            border-radius: 4px;
            font-size: 0.9em; /* Adjust size if needed */
        }

        .category-nav a.active {
            background-color: #FFB74D; /* wheel-game style */
            color: white;
        }

        .category-nav a:hover:not(.active) {
            background-color: #e0e0e0; /* wheel-game style */
        }

        /* Games Navigation */
        .games-nav {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 1rem;
            padding: 0.8rem 0; /* Slightly reduced padding */
            background-color: #fff5e6; /* wheel-game style */
            width: 100%;
            border-bottom: 1px solid #ffe0b2; /* wheel-game style */
            flex-shrink: 0; /* Prevent nav from shrinking */
        }

        .games-nav a {
            text-decoration: none;
            color: #333; /* wheel-game style */
            padding: 0.4rem 1rem; /* Slightly reduced padding */
            border-radius: 20px;
            background-color: #ffecb3; /* wheel-game style */
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            font-size: 0.9em; /* Adjust size if needed */
        }

        .games-nav a.active {
            background-color: #FF9800; /* wheel-game style */
            color: white;
            box-shadow: 0 3px 8px rgba(255,152,0,0.3);
            transform: translateY(-2px);
        }

        .games-nav a:hover:not(.active) {
            background-color: #ffe082; /* wheel-game style */
            transform: translateY(-2px);
        }

        /* Footer Styles */
        footer {
            background-color: #333; /* wheel-game style */
            color: white;
            width: 100%;
            padding: 1.5rem 0; /* Slightly reduced padding */
            margin-top: auto; /* Pushes footer to bottom */
            flex-shrink: 0; /* Prevent footer from shrinking */
        }

        .footer-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        .footer-nav {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 1rem;
            flex-wrap: wrap; /* Allow wrapping */
        }

        .footer-nav a {
            color: white;
            text-decoration: none;
            font-size: 0.9em;
        }

        .footer-nav a.active {
            color: #FFB74D; /* wheel-game style */
        }

        .footer-copyright {
            text-align: center;
            font-size: 0.8em; /* Slightly reduced size */
        }

        /* Contribution Info (Optional, if you want to add it) */
        .contribution-info {
             background-color: rgba(15, 52, 96, 0.6); /* Adjusted background */
             padding: 10px;
             border-radius: 8px;
             margin: 15px auto; /* Spacing */
             max-width: 90%;
             width: 600px;
             text-align: center;
             font-size: 0.85em;
             color: #eee; /* Lighter text */
             box-sizing: border-box;
        }
         .contribution-info a {
             color: #FFB74D; /* Match theme */
             text-decoration: none;
         }
         .contribution-info a:hover {
             text-decoration: underline;
         }

        /* --- Styles specific to bridge-game.html --- */

        /* New Game Wrapper */
        .game-wrapper {
            flex-grow: 1; /* Takes available vertical space */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* Center game vertically */
            width: 100%;
            padding: 5px 0; /* Minimal padding */
            box-sizing: border-box;
            position: relative; /* Needed for absolute children like timer */
            overflow: hidden; /* VERY IMPORTANT: Prevents internal scrolling */
        }

        .game-container {
            position: relative;
            width: 100%; /* Take full width of wrapper */
            max-width: 500px; /* Limit max width for larger screens */
            height: 60vh; /* Keep the viewport height based size */
            perspective: 1000px;
            margin-bottom: 5px; /* Reduced margin */
            overflow: hidden; /* Clip bridge if needed */
            flex-shrink: 0; /* Don't shrink */
        }
        .bridge {
            position: absolute;
            width: 90%;
            height: 100%;
            left: 5%;
            transform-style: preserve-3d;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            transition: transform 0.8s ease;
        }
        .bridge-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px; /* Slightly reduced */
            width: 100%;
            perspective: 500px;
            transform: rotateX(60deg);
        }
        .glass-panel {
            width: 45%;
            height: 50px; /* Slightly reduced */
            background-color: rgba(167, 197, 235, 0.5);
            border: 1px solid white; /* Thinner border */
            display: flex;
            justify-content: center;
            align-items: center;
            transform-style: preserve-3d;
            transition: all 0.3s;
            position: relative;
            font-size: 16px; /* Slightly reduced */
            font-weight: bold;
        }
        /* Removed controls-and-players wrapper, elements styled directly */
        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 90%;
            max-width: 450px; /* Limit width */
            gap: 15px; /* Reduced gap */
            margin: 5px 0 10px 0; /* Adjusted margin */
            flex-shrink: 0;
        }
        .players-container {
            display: flex;
            justify-content: center; /* Center players */
            flex-wrap: wrap; /* Allow wrapping */
            gap: 8px; /* Space between players */
            width: 95%;
            max-width: 600px; /* Limit width */
            padding: 0 5px;
            margin: 5px 0; /* Adjusted margin */
            flex-shrink: 0;
        }
        .btn {
            padding: 15px 30px; /* Reduced padding */
            font-size: 20px; /* Reduced font size */
            background-color: #e94560;
            color: white;
            border: none;
            border-radius: 8px; /* Slightly smaller radius */
            cursor: pointer;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2); /* Adjusted shadow */
            transition: transform 0.1s, box-shadow 0.1s;
            width: 45%;
            max-width: 160px; /* Limit max width */
            flex-shrink: 0; /* Prevent shrinking */
        }
        .btn:active {
            transform: translateY(2px); /* Reduced active effect */
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        .btn:hover {
            background-color: #ff6b81;
        }
        .btn:disabled {
            background-color: #555;
            cursor: not-allowed;
            box-shadow: none;
        }
        .info-panel {
            width: 90%;
            max-width: 500px; /* Limit width */
            padding: 10px; /* Reduced padding */
            text-align: center;
            background-color: #0f3460;
            border-radius: 8px;
            margin: 5px 0; /* Adjusted margin */
            font-size: 14px; /* Reduced font size */
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
            flex-shrink: 0;
        }
        .timer {
            position: absolute; /* Relative to game-wrapper now */
            top: 10px; /* Position within wrapper */
            left: 50%;
            transform: translateX(-50%);
            background-color: #0f3460;
            padding: 8px 15px; /* Reduced padding */
            border-radius: 8px;
            font-size: 22px; /* Reduced font size */
            border: 2px solid #e94560;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
            z-index: 10;
        }
        .player {
            display: flex;
            align-items: center;
            gap: 8px; /* Reduced gap */
            background-color: rgba(15, 52, 96, 0.9);
            padding: 8px 12px; /* Reduced padding */
            border-radius: 15px; /* Adjusted radius */
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
            flex-shrink: 0; /* Prevent shrinking */
        }
        .player-figure {
            width: 25px; /* Reduced size */
            height: 38px; /* Reduced size */
            position: relative;
        }
        .player-body {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50% 50% 0 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .player-head {
            width: 55%; /* Adjusted ratio */
            height: 35%; /* Adjusted ratio */
            border-radius: 50%;
            position: relative;
        }
        .player-label {
            font-size: 14px; /* Reduced font size */
            font-weight: bold;
            white-space: nowrap; /* Prevent wrapping */
        }
        .progress {
            position: absolute; /* Relative to game-wrapper */
            top: 55px; /* Position below timer */
            left: 50%;
            transform: translateX(-50%);
            font-size: 18px; /* Reduced font size */
            color: #e94560;
            background-color: rgba(15, 52, 96, 0.7);
            padding: 6px 12px; /* Reduced padding */
            border-radius: 12px;
            z-index: 10;
        }
        .broken {
            background-color: rgba(233, 69, 96, 0.3);
            transform: scale(0.9);
        }
        .safe {
            background-color: rgba(66, 245, 179, 0.5);
        }
        .game-over {
            position: absolute; /* Covers game-wrapper */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 36px; /* Reduced font size */
            color: #e94560;
            z-index: 100;
            display: none;
            text-align: center;
            padding: 20px;
        }
        .restart-btn {
            margin-top: 25px; /* Reduced margin */
            padding: 12px 25px; /* Reduced padding */
            background-color: #e94560;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 20px; /* Reduced font size */
            cursor: pointer;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
        }
        .character {
            /* Position relative to game-container */
            position: absolute;
            width: 25px; /* Match player figure size */
            height: 38px; /* Match player figure size */
            z-index: 20;
            transition: all 0.5s ease;
            /* Initial positioning done by JS */
            bottom: 20px; /* Default bottom if JS fails */
            left: 50%;  /* Default left if JS fails */
            transform: translateX(-50%); /* Default transform */
        }
        .character-body {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50% 50% 0 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .character-head {
            width: 55%; /* Match player head ratio */
            height: 35%; /* Match player head ratio */
            border-radius: 50%;
            position: relative;
        }
        .character-legs {
            position: absolute;
            bottom: -8px; /* Adjusted leg position */
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
        }
        .character-leg {
            width: 30%;
            height: 10px; /* Reduced leg size */
        }
        /* Character Colors */
        .pink { background-color: #ff6b81; }
        .pink .character-head, .pink .player-head { background-color: #ffd166; }
        .yellow-pink { background-color: #ffd166; }
        .yellow-pink .character-head, .yellow-pink .player-head { background-color: #ff6b81; }
        .green-pink { background-color: #06d6a0; }
        .green-pink .character-head, .green-pink .player-head { background-color: #ff6b81; }
        .blue-pink { background-color: #4392f1; }
        .blue-pink .character-head, .blue-pink .player-head { background-color: #ff6b81; }
        .purple-pink { background-color: #8d7cba; }
        .purple-pink .character-head, .purple-pink .player-head { background-color: #ff6b81; }
        .orange-pink { background-color: #ff9a3c; }
        .orange-pink .character-head, .orange-pink .player-head { background-color: #ff6b81; }
        .cyan-pink { background-color: #4ec2c2; }
        .cyan-pink .character-head, .cyan-pink .player-head { background-color: #ff6b81; }
        .brown-pink { background-color: #a06235; }
        .brown-pink .character-head, .brown-pink .player-head { background-color: #ff6b81; }
        .blood {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: #e94560;
            opacity: 0;
            z-index: 5;
            transition: opacity 0.3s;
        }
        .fall-animation {
            animation: fall 1.5s forwards; /* Faster fall */
        }
        @keyframes fall {
            0% { transform: translateY(0) rotateZ(0deg) scale(1); }
            25% { transform: translateY(15px) rotateZ(30deg) scale(1.05); } /* Slightly smaller translate */
            100% { transform: translateY(400px) rotateZ(180deg) scale(0.5); opacity: 0; } /* Fall further, shrink */
        }
        .current-player-indicator {
            font-weight: bold;
            color: #e94560;
            margin-left: 5px; /* Reduced margin */
            font-size: 18px; /* Reduced size */
        }
        .player-count-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px; /* Reduced gap */
            margin: 8px 0; /* Reduced margin */
            background-color: #0f3460;
            padding: 10px 15px; /* Reduced padding */
            border-radius: 8px;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
            flex-shrink: 0;
        }
        .player-count-select {
            padding: 6px 10px; /* Reduced padding */
            font-size: 16px; /* Reduced font size */
            background-color: #1a1a2e;
            color: white;
            border: 1px solid #e94560; /* Thinner border */
            border-radius: 4px;
            cursor: pointer;
        }

        /* Media query for smaller screens if needed */
        @media (max-height: 700px) {
             /* Adjust sizes further if header/footer take too much space */
            .game-container { height: 55vh; }
            .btn { padding: 12px 25px; font-size: 18px; }
            .player-count-container { margin: 5px 0; padding: 8px 12px; }
            .info-panel { font-size: 13px; padding: 8px; }
            .players-container { margin: 3px 0; }
        }
         @media (max-width: 400px) {
             .category-nav a, .games-nav a { font-size: 0.8em; padding: 0.3rem 0.6rem; }
             .btn { padding: 10px 20px; font-size: 16px; }
             .player-label { font-size: 12px;}
             .player { padding: 6px 8px; gap: 5px;}
             .player-figure { width: 20px; height: 30px;}
             .timer { font-size: 18px; padding: 6px 10px; }
             .progress { font-size: 15px; top: 45px; padding: 5px 10px; }
         }

    </style>
</head>
<body>
    <!-- Header from wheel-game -->
    <header class="page-title-header">
        <h1 class="page-title">SunnyYummy 互動遊戲</h1>
    </header>

    <!-- Category Nav from wheel-game -->
    <nav class="category-nav">
        <a href="/">週邊商品</a>
        <a href="/music.html">音樂專輯</a>
        <a href="/news.html">最新消息</a>
        <a href="/scores.html">樂譜與舞蹈</a>
        <a href="/game/card-game.html" class="active">互動遊戲</a> <!-- Mark as active -->
        <a href="/guestbook.html">留言板</a>
    </nav>

    <!-- Games Nav from wheel-game -->
    <nav class="games-nav">
        <a href="/game/card-game.html">洞洞樂</a>
        <a href="/game/wheel-game.html">命運輪盤</a>
        <a href="/game/brige-game.html" class="active">玻璃橋</a> <!-- Added link for this game -->
    </nav>

    <!-- Main Game Wrapper -->
    <main class="game-wrapper">
        <div class="game-container">
            <div class="timer">02:00</div>
            <div class="progress">進度: 0/15</div>
            <div class="bridge" id="bridge"></div>
            <div id="character" class="character">
                <!-- Character body updated by JS -->
                <div class="character-body pink" id="characterBody">
                    <div class="character-head"></div>
                    <div class="character-legs">
                        <div class="character-leg pink"></div>
                        <div class="character-leg pink"></div>
                    </div>
                </div>
            </div>
             <!-- Game Over screen still targets game-container effectively due to absolute positioning -->
             <div class="game-over" id="gameOver">
                <div id="gameOverText">遊戲結束!</div>
                <button class="restart-btn" onclick="restartGame()">重新開始</button>
             </div>
        </div>

        <div class="players-container" id="players">
            <!-- Players generated by JS -->
        </div>

        <div class="controls">
            <button class="btn" id="leftBtn">左側</button>
            <button class="btn" id="rightBtn">右側</button>
        </div>

        <div class="info-panel">
            <p id="message">接力挑戰！選擇人數開始。當一位玩家失敗，下一位玩家將從該位置繼續！</p>
        </div>

        <div class="player-count-container">
            <label for="playerCount">遊戲人數：</label>
            <select id="playerCount" class="player-count-select">
                <option value="3" selected>3人</option>
                <option value="4">4人</option>
                <option value="5">5人</option>
                <option value="6">6人</option>
                <option value="7">7人</option>
                <option value="8">8人</option>
            </select>
        </div>
    </main>

    <!-- Optional: Contribution Info -->
     <div class="contribution-info">
         這是 SunnyYummy 提供的互動遊戲。魷魚遊戲玻璃橋挑戰改編。如有建議或想分享您的使用體驗，歡迎至<a href="/guestbook.html">留言板</a>留言或寄信至 <a href="mailto:paulaqueenatina@gmail.com">paulaqueenatina@gmail.com</a>。
     </div>

    <!-- Footer from wheel-game -->
    <footer>
        <div class="footer-container">
            <nav class="footer-nav">
                 <a href="/">週邊商品</a>
                 <a href="/music.html">音樂專輯</a>
                 <a href="/news.html">最新消息</a>
                 <a href="/scores.html">樂譜與舞蹈</a>
                 <a href="/game/card-game.html" class="active">互動遊戲</a> <!-- Mark as active -->
                 <a href="/guestbook.html">留言板</a>
            </nav>
            <div class="footer-copyright">
                <p>© 2024 SunnyYummy. All rights reserved.</p>
            </div>
        </div>
    </footer>

    <script>
        // --- Bridge Game JavaScript (No changes needed to the logic itself) ---
        let currentStep = 0;
        let totalSteps = 15;
        let time = 120; // 2 minutes in seconds
        let gameActive = true;
        let safePattern = [];
        let isMoving = false;
        let currentPlayerIndex = 0;
        let players = [];
        let playerCount = 3; // Default
        const playerColors = ['pink', 'yellow-pink', 'green-pink', 'blue-pink', 'purple-pink', 'orange-pink', 'cyan-pink', 'brown-pink'];
        const playerNames = ['小紅', '小黃', '小綠', '小藍', '小紫', '小橙', '小青', '小棕'];
        const playerCountSelect = document.getElementById('playerCount');
        let lastFailPosition = 0;
        let currentViewStage = 0; // Tracks the vertical scroll adjustment stage

        // DOM Elements
        const bridge = document.getElementById('bridge');
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const message = document.getElementById('message');
        const timerElement = document.querySelector('.timer');
        const progressElement = document.querySelector('.progress');
        const gameOverElement = document.getElementById('gameOver');
        const gameOverText = document.getElementById('gameOverText');
        const character = document.getElementById('character');
        const characterBody = document.getElementById('characterBody');
        const playersContainer = document.getElementById('players');
        const gameContainer = document.querySelector('.game-container'); // Get game container for positioning

        // Player Count Selection
        playerCountSelect.addEventListener('change', function() {
            playerCount = parseInt(this.value);
            restartGame();
        });

        function initPlayers() {
            players = [];
            for (let i = 0; i < playerCount; i++) {
                players.push({
                    name: playerNames[i % playerNames.length], // Use modulo for safety
                    color: playerColors[i % playerColors.length],
                    active: i === 0,
                    lastFailPosition: 0 // Tracks individual player's fail point if needed
                });
            }
        }

        function updatePlayersUI() {
            playersContainer.innerHTML = '';
            players.forEach((player, index) => {
                const playerElement = document.createElement('div');
                playerElement.className = 'player';
                playerElement.id = `player${index}`; // Use index directly

                const playerFigure = document.createElement('div');
                playerFigure.className = 'player-figure';

                const playerBodyDiv = document.createElement('div'); // Renamed variable
                playerBodyDiv.className = `player-body ${player.color}`;

                const playerHead = document.createElement('div');
                playerHead.className = 'player-head';

                playerBodyDiv.appendChild(playerHead);
                playerFigure.appendChild(playerBodyDiv);

                const playerLabel = document.createElement('div');
                playerLabel.className = 'player-label';
                // Use innerHTML carefully or create text nodes
                playerLabel.textContent = `${player.name} `; // Add space
                 const indicatorSpan = document.createElement('span');
                 indicatorSpan.className = 'current-player-indicator';
                 indicatorSpan.textContent = player.active ? '▶' : '';
                 playerLabel.appendChild(indicatorSpan);


                playerElement.appendChild(playerFigure);
                playerElement.appendChild(playerLabel);

                // Dim inactive players who have already failed
                if (!player.active && index < currentPlayerIndex) {
                   playerElement.style.opacity = '0.5';
                 } else {
                    playerElement.style.opacity = '1';
                 }

                playersContainer.appendChild(playerElement);
            });
        }

        function initGame() {
            safePattern = [];
            for (let i = 0; i < totalSteps; i++) {
                safePattern.push(Math.random() < 0.5 ? 'left' : 'right');
            }

            createBridge();
            initPlayers();
            currentPlayerIndex = 0;
            lastFailPosition = 0;
            currentViewStage = 0; // Reset view stage
            updatePlayersUI();

            // Reset Character
            character.classList.remove('fall-animation');
             character.style.opacity = 1; // Ensure visible
            positionCharacter(0); // Reset to start
            updateCharacterColor();

            updateProgress();
            message.innerText = `接力挑戰！${playerCount}位玩家輪流挑戰。點擊左右側玻璃！`;

            resetBridgePosition(); // Reset bridge scroll

            // Reset Timer & Game State
             time = 120;
             timerElement.innerText = `02:00`;
             gameActive = true;
             isMoving = false;
             gameOverElement.style.display = 'none';
             leftBtn.disabled = false;
             rightBtn.disabled = false;


            startTimer(); // Start timer last
        }

        function resetBridgePosition() {
            bridge.style.transition = 'transform 0s'; // No animation during reset
            bridge.style.transform = 'translateY(0)';
             setTimeout(() => {
                 bridge.style.transition = 'transform 0.8s ease'; // Restore animation
             }, 50);
        }

        function createBridge() {
            bridge.innerHTML = '';
            for (let i = 0; i < totalSteps; i++) {
                const row = document.createElement('div');
                row.className = 'bridge-row';
                row.setAttribute('data-index', i);
                // Opacity adjustment based on index (optional)
                 row.style.opacity = Math.max(0.3, 1 - (i * 0.05));

                const leftPanel = document.createElement('div');
                leftPanel.className = 'glass-panel';
                leftPanel.textContent = `L${i + 1}`; // Use textContent for safety

                const rightPanel = document.createElement('div');
                rightPanel.className = 'glass-panel';
                rightPanel.textContent = `R${i + 1}`; // Use textContent for safety

                // Add blood effect divs
                const leftBlood = document.createElement('div');
                leftBlood.className = 'blood';
                leftPanel.appendChild(leftBlood);

                const rightBlood = document.createElement('div');
                rightBlood.className = 'blood';
                rightPanel.appendChild(rightBlood);

                row.appendChild(leftPanel);
                row.appendChild(rightPanel);
                bridge.appendChild(row);
            }
        }

        // Position character relative to the gameContainer
         function positionCharacter(stepPosition) {
            const containerRect = gameContainer.getBoundingClientRect();

            if (stepPosition === 0) {
                character.style.bottom = '10px'; // Closer to bottom edge of container
                character.style.left = '50%';
                character.style.top = ''; // Remove top positioning
                character.style.transform = 'translateX(-50%)'; // Reset transform
             } else {
                 const rows = bridge.querySelectorAll('.bridge-row');
                 const rowIndex = totalSteps - stepPosition; // Index from the bottom up

                 if (rowIndex >= 0 && rowIndex < rows.length) {
                     const targetRow = rows[rowIndex];
                     if (targetRow) {
                         const rowRect = targetRow.getBoundingClientRect();
                         // Calculate position relative to gameContainer top
                         const topOffset = rowRect.top - containerRect.top + (rowRect.height / 2) - (character.offsetHeight / 2) ;
                        const leftOffset = (containerRect.width / 2) - (character.offsetWidth / 2); // Center horizontally within container

                        character.style.top = `${topOffset}px`;
                        character.style.left = `${leftOffset}px`;
                         character.style.bottom = ''; // Remove bottom positioning
                        character.style.transform = 'rotateX(0deg)'; // Adjust transform if needed, maybe remove rotation
                     } else {
                         console.warn("Target row not found for positioning:", rowIndex);
                     }
                 } else {
                      console.warn("Invalid row index for positioning:", rowIndex);
                      // Fallback: position near last known good spot or start
                      positionCharacter(stepPosition - 1 >= 0 ? stepPosition - 1 : 0);
                 }
             }
             // Ensure character is visible and not falling
             character.classList.remove('fall-animation');
             character.style.opacity = 1;
         }


        function updateCharacterColor() {
            if (currentPlayerIndex >= 0 && currentPlayerIndex < players.length) {
                const colorClass = players[currentPlayerIndex].color;
                characterBody.className = `character-body ${colorClass}`; // Update body class

                // Update legs
                const legs = characterBody.querySelectorAll('.character-leg');
                legs.forEach(leg => {
                    // Remove old color classes before adding new one
                     leg.className = 'character-leg'; // Reset classes
                     leg.classList.add(colorClass);
                });
            } else {
                 console.error("Invalid currentPlayerIndex for color update:", currentPlayerIndex);
                 // Default color if error
                 characterBody.className = 'character-body pink';
                 const legs = characterBody.querySelectorAll('.character-leg');
                 legs.forEach(leg => { leg.className = 'character-leg pink'; });
             }
        }

        let timerInterval = null; // Store interval ID
        function startTimer() {
             clearInterval(timerInterval); // Clear existing timer first
            timerInterval = setInterval(() => {
                if (!gameActive) {
                    clearInterval(timerInterval);
                    return;
                }

                time--;
                const minutes = Math.floor(time / 60);
                const seconds = time % 60;
                timerElement.innerText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

                if (time <= 0) {
                     clearInterval(timerInterval); // Stop timer first
                    endGame(false, "時間到！");
                }
            }, 1000);
        }

        function switchToNextPlayer() {
            if (currentPlayerIndex >= 0 && currentPlayerIndex < players.length) {
                players[currentPlayerIndex].active = false;
                // Optional: Record where this player failed if needed later
                // players[currentPlayerIndex].lastFailPosition = lastFailPosition;
            }

            let nextPlayerFound = false;
            // Start searching from the player *after* the current one
            for (let i = 1; i < players.length; i++) {
                let checkIndex = (currentPlayerIndex + i) % players.length;
                 // Check if this player hasn't already been marked inactive (e.g., by failing)
                 // This simple logic assumes players only become inactive upon failing
                 // A more robust system might track player state (active, failed, succeeded)
                if (players[checkIndex].active !== false) { // Check if not explicitly failed? This logic might need refinement.
                                                            // Let's assume for now that if active isn't false, they can play.
                     // Mark previous player inactive in UI if needed
                     const prevPlayerUI = document.getElementById(`player${currentPlayerIndex}`);
                     if (prevPlayerUI) prevPlayerUI.style.opacity = '0.5';


                    currentPlayerIndex = checkIndex;
                    players[currentPlayerIndex].active = true;
                    nextPlayerFound = true;
                    break;
                }
            }


            if (nextPlayerFound) {
                updatePlayersUI();
                updateCharacterColor();
                positionCharacter(lastFailPosition); // Move new player to the fail spot
                adjustBridgeViewByPosition(lastFailPosition); // Adjust view for the new player
                message.innerText = `${players[currentPlayerIndex].name} 接力! 從第 ${lastFailPosition + 1} 步開始`;

                // Short delay before enabling controls for the new player
                setTimeout(() => {
                    isMoving = false;
                    if (gameActive) { // Only enable if game is still active
                        leftBtn.disabled = false;
                        rightBtn.disabled = false;
                    }
                }, 500); // Delay allows character repositioning visually
            } else {
                // No more players left
                endGame(false, "所有玩家都失敗了！");
            }
        }


        function getCurrentRow() {
             // Use lastFailPosition as the starting point if接力
            const stepToFind = Math.max(currentStep, lastFailPosition);
            if (stepToFind >= totalSteps) return null;

            const rows = bridge.querySelectorAll('.bridge-row');
            // Rows are ordered top-to-bottom in HTML, so index is totalSteps - 1 - step
            const rowIndex = totalSteps - 1 - stepToFind;

            if (rowIndex >= 0 && rowIndex < rows.length) {
                return rows[rowIndex];
            }
             console.error("Could not find row for step:", stepToFind, "Calculated index:", rowIndex);
            return null;
        }

        // Adjusts the vertical position of the bridge
         function adjustBridgeViewByPosition(position) {
             const stepsPerStage = 3; // Adjust how many steps trigger a view shift
             const targetStage = Math.floor(position / stepsPerStage);

             if (targetStage !== currentViewStage) {
                 currentViewStage = targetStage;
                 const bridgeHeight = bridge.offsetHeight; // Use offsetHeight
                 // Calculate shift amount - move up more significantly per stage
                 const stageShiftPercentage = 0.20; // Move 20% of bridge height per stage
                 const moveAmount = bridgeHeight * stageShiftPercentage * currentViewStage;

                 // Apply translateY to move the bridge UP (negative value)
                 bridge.style.transform = `translateY(-${moveAmount}px)`;

                 // Reposition character smoothly after bridge moves
                  setTimeout(() => {
                     positionCharacter(position);
                  }, 300); // Delay to allow bridge move animation
             } else if (position === 0) {
                 // Ensure reset if back to step 0
                 resetBridgePosition();
             }
         }


        function jump(side) {
            if (!gameActive || isMoving) return;

            isMoving = true;
            leftBtn.disabled = true;
            rightBtn.disabled = true;

            const stepForLogic = Math.max(currentStep, lastFailPosition); // Step to check against safePattern
             if (stepForLogic >= totalSteps) {
                 console.warn("Jump attempted at or beyond final step.");
                 isMoving = false; // Re-enable buttons maybe? Or should be win state.
                 // endGame(true, "Already finished!"); // Or similar logic
                 return;
             }

            const currentRow = getCurrentRow(); // Get row based on stepForLogic
            if (!currentRow) {
                console.error("Cannot jump, current row not found for step:", stepForLogic);
                isMoving = false;
                 leftBtn.disabled = false; // Allow retry?
                 rightBtn.disabled = false;
                return;
            }

            const leftPanel = currentRow.children[0];
            const rightPanel = currentRow.children[1];
             const targetPanel = side === 'left' ? leftPanel : rightPanel;

            if (!targetPanel) {
                 console.error("Target panel not found for side:", side);
                 isMoving = false; leftBtn.disabled = false; rightBtn.disabled = false;
                 return;
             }

            const isSafe = (side === safePattern[stepForLogic]);

            // --- Character Movement ---
            const targetRect = targetPanel.getBoundingClientRect();
             const containerRect = gameContainer.getBoundingClientRect();

             // Calculate target position relative to gameContainer
             const targetTop = targetRect.top - containerRect.top + (targetRect.height / 2) - (character.offsetHeight / 2);
             const targetLeft = targetRect.left - containerRect.left + (targetRect.width / 2) - (character.offsetWidth / 2);

             // Apply new position
             character.style.top = `${targetTop}px`;
             character.style.left = `${targetLeft}px`;
             character.style.bottom = '';
             character.style.transform = ''; // Clear transform if needed


            // Delay the outcome logic slightly for visual effect
            setTimeout(() => {
                if (isSafe) {
                    targetPanel.classList.add('safe');
                     // Reveal the other panel as safe too if needed? Or keep it hidden?
                    // For this version, just mark the chosen one.

                    // Update currentStep correctly whether starting fresh or relaying
                    currentStep = stepForLogic + 1; // Move to the *next* step number

                    lastFailPosition = currentStep; // Successful step becomes the new 'last position'

                    updateProgress();
                    message.innerText = `${players[currentPlayerIndex].name} 安全! 前往第 ${currentStep + 1} 步`;

                    // Adjust view for the *next* step
                    adjustBridgeViewByPosition(currentStep);

                    // Check for win
                    if (currentStep >= totalSteps) {
                         clearInterval(timerInterval); // Stop timer on win
                        endGame(true, `恭喜! ${players[currentPlayerIndex].name} 成功穿過了玻璃橋!`);
                    } else {
                        // Re-enable buttons after a short delay
                        setTimeout(() => {
                            isMoving = false;
                            if (gameActive) {
                                leftBtn.disabled = false;
                                rightBtn.disabled = false;
                            }
                        }, 300); // Shorter delay after success
                    }
                } else {
                    // Failure
                    targetPanel.classList.add('broken');
                    const blood = targetPanel.querySelector('.blood');
                    if (blood) blood.style.opacity = '0.7';

                    character.classList.add('fall-animation');

                    // lastFailPosition remains where they failed (stepForLogic)
                    // Mark current player as inactive/failed
                     players[currentPlayerIndex].active = false;
                     // Update UI immediately to show failure
                     const failedPlayerUI = document.getElementById(`player${currentPlayerIndex}`);
                     if (failedPlayerUI) { failedPlayerUI.style.opacity = '0.5'; } // Dim immediately

                     message.innerText = `${players[currentPlayerIndex].name} 失敗了!`;

                    // Wait for fall animation, then switch player
                    setTimeout(() => {
                         character.style.opacity = 0; // Hide fallen character
                        switchToNextPlayer();
                    }, 1500); // Match fall animation duration
                }
            }, 400); // Delay after character moves onto panel
        }


        function updateProgress() {
            // Display based on currentStep, which reflects successful steps completed
            progressElement.innerText = `進度: ${currentStep}/${totalSteps}`;
        }

        function endGame(isWin, msg) {
            gameActive = false;
             clearInterval(timerInterval); // Ensure timer stops
            gameOverText.innerText = msg;
            gameOverElement.style.display = 'flex'; // Show overlay
            gameOverElement.style.backgroundColor = isWin ? 'rgba(66, 245, 179, 0.8)' : 'rgba(233, 69, 96, 0.8)'; // Adjusted colors
            gameOverText.style.color = isWin ? '#0f3460' : 'white'; // Contrasting text color
            leftBtn.disabled = true;
            rightBtn.disabled = true;
        }

        // Restart Game Function (called by button)
        function restartGame() {
            initGame(); // Re-initialize everything
        }

        // Button Event Listeners
        leftBtn.addEventListener('click', () => jump('left'));
        rightBtn.addEventListener('click', () => jump('right'));

        // Touch Events (Important for mobile)
         // Use touchend to prevent issues with accidental moves during scroll/pan attempt
         leftBtn.addEventListener('touchend', (e) => {
            e.preventDefault(); // Prevent click event from firing too
            jump('left');
         });
         rightBtn.addEventListener('touchend', (e) => {
             e.preventDefault();
             jump('right');
         });


        // Initial Game Load
        document.addEventListener('DOMContentLoaded', initGame);

    </script>
</body>
</html>