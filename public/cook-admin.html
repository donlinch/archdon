<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>料理急先鋒 - 遊戲資料管理</title>
    <style>
        /* 引入簡潔的管理後台 CSS 樣式 */
        body { font-family: sans-serif; background-color: #f4f4f9; color: #333; margin: 20px; }
        .container { max-width: 1200px; margin: auto; }
        .section { background: #fff; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1, h2 { color: #32a852; }
        table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #e8f5e9; }
        .code-block { background-color: #2d2d2d; color: #f0f0f0; padding: 15px; border-radius: 5px; white-space: pre; overflow-x: auto; font-family: monospace; }
        .export-btn { background-color: #FF9800; color: white; padding: 10px 15px; border: none; border-radius: 5px; cursor: pointer; font-size: 1em; }
    </style>
</head>
<body>
    <div class="container">
        <h1>料理急先鋒 - 遊戲資料管理</h1>

        <!-- 物品管理區塊 -->
        <div class="section">
            <h2>物品列表 (cook_items)</h2>
            <p>這裡管理遊戲中所有的基礎食材、半成品和最終料理。</p>
            <table id="itemsTable">
                <thead>
                    <tr>
                        <th>ID</th>
                        <th>物品 ID (item_id)</th>
                        <th>名稱 (item_name)</th>
                        <th>類型 (item_type)</th>
                        <th>基礎分數 (base_points)</th>
                        <th>是否為訂單 (is_dish)</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- JS 動態填充 -->
                </tbody>
            </table>
        </div>

        <!-- 食譜管理區塊 -->
        <div class="section">
            <h2>食譜列表 (cook_recipes_v2 & requirements)</h2>
            <p>這裡管理所有的烹飪和組合配方。</p>
            <table id="recipesTable">
                <thead>
                    <tr>
                        <th>食譜 ID (recipe_id)</th>
                        <th>類型 (station_type)</th>
                        <th>產出物 (Output)</th>
                        <th>所需原料 (Requirements)</th>
                        <th>烹飪時間 (Cook Time)</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- JS 動態填充 -->
                </tbody>
            </table>
        </div>

        <!-- 資料導出區塊 -->
        <div class="section">
            <h2>資料導出</h2>
            <p>點擊按鈕以 SQL 格式導出所有遊戲核心資料，方便備份或遷移。</p>
            <button id="exportSqlBtn" class="export-btn">導出 SQL 資料</button>
            <div class="code-block" id="sqlOutput">
                -- 點擊導出按鈕後，這裡會顯示 SQL 指令...
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const itemsTableBody = document.querySelector('#itemsTable tbody');
            const recipesTableBody = document.querySelector('#recipesTable tbody');
            const exportSqlBtn = document.getElementById('exportSqlBtn');
            const sqlOutput = document.getElementById('sqlOutput');

            let allItems = [];
            let allRecipes = [];

            // 獲取所有物品資料
            async function fetchItems() {
                try {
                    const token = localStorage.getItem('token');
                    if (!token) {
                        alert('請先登入');
                        sqlOutput.textContent = '錯誤：未找到認證令牌，請以管理員身份登入。';
                        return;
                    }

                    const response = await fetch('/cook-api/admin/all-items', {
                        headers: {
                            'Authorization': `Bearer ${token}`
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`獲取物品失敗: ${response.statusText}`);
                    }
                    
                    allItems = await response.json();
                    
                    itemsTableBody.innerHTML = '';
                    allItems.forEach(item => {
                        itemsTableBody.innerHTML += `
                            <tr>
                                <td>${item.id}</td>
                                <td>${item.item_id}</td>
                                <td>${item.item_name}</td>
                                <td>${item.item_type}</td>
                                <td>${item.base_points}</td>
                                <td>${item.is_dish}</td>
                            </tr>
                        `;
                    });

                } catch (error) {
                    console.error('Fetch items error:', error);
                    sqlOutput.textContent = `載入物品時發生錯誤: ${error.message}`;
                }
            }

            // 獲取所有食譜資料
            async function fetchRecipes() {
                try {
                    const token = localStorage.getItem('token');
                     if (!token) {
                        // fetchItems 已經檢查過，這裡可以省略
                        return;
                    }

                    const response = await fetch('/cook-api/admin/all-recipes', {
                         headers: {
                            'Authorization': `Bearer ${token}`
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`獲取食譜失敗: ${response.statusText}`);
                    }

                    allRecipes = await response.json();
                    
                    recipesTableBody.innerHTML = '';
                    allRecipes.forEach(recipe => {
                        // 從 API 回應中直接取得 output_item_name
                        const outputItemName = recipe.output_item_name || '未知物品';
                        
                        const requirements = recipe.requirements.map(req => {
                             // 從 API 回應中直接取得 required_item_name
                            return `${req.item_name} x ${req.quantity}`;
                        }).join(', ');

                        recipesTableBody.innerHTML += `
                            <tr>
                                <td>${recipe.recipe_id}</td>
                                <td>${recipe.station_type}</td>
                                <td>${outputItemName}</td>
                                <td>${requirements}</td>
                                <td>${recipe.cook_time_seconds || 'N/A'}</td>
                            </tr>
                        `;
                    });
                } catch (error) {
                    console.error('Fetch recipes error:', error);
                    sqlOutput.textContent = `載入食譜時發生錯誤: ${error.message}`;
                }
            }

            // 導出 SQL
            function exportSql() {
                if(allItems.length === 0 || allRecipes.length === 0) {
                    sqlOutput.textContent = '資料尚未載入或載入失敗，無法導出。';
                    return;
                }

                let sql = '-- ========= COOK ITEMS =========\n';
                sql += 'INSERT INTO cook_items (id, item_id, item_name, item_type, base_points, is_dish) VALUES\n';
                const itemValues = allItems.map(i => 
                    `(${i.id}, '${i.item_id}', '${i.item_name}', '${i.item_type}', ${i.base_points}, ${i.is_dish})`
                ).join(',\n');
                sql += itemValues + ' ON CONFLICT (id) DO UPDATE SET item_id = EXCLUDED.item_id, item_name = EXCLUDED.item_name, item_type = EXCLUDED.item_type, base_points = EXCLUDED.base_points, is_dish = EXCLUDED.is_dish;\n\n';

                sql += '-- ========= COOK RECIPES V2 =========\n';
                sql += 'INSERT INTO cook_recipes_v2 (recipe_id, recipe_name, station_type, output_item_id, cook_time_seconds, is_orderable, difficulty) VALUES\n';
                const recipeValues = allRecipes.map(r => {
                    const outputItem = allItems.find(i => i.id === r.output_item_id);
                    // 注意：此處的 recipe_name 只是示意
                    const recipeName = `${r.output_item_name}食譜`;
                    // 假設 is_orderable 和 difficulty
                    const isOrderable = outputItem ? outputItem.is_dish : false;
                    const difficulty = 1; 
                    return `('${r.recipe_id}', '${recipeName}', '${r.station_type}', ${r.output_item_id}, ${r.cook_time_seconds || 'NULL'}, ${isOrderable}, ${difficulty})`;
                }).join(',\n');
                sql += recipeValues + ' ON CONFLICT (recipe_id) DO UPDATE SET recipe_name = EXCLUDED.recipe_name, station_type = EXCLUDED.station_type, output_item_id = EXCLUDED.output_item_id, cook_time_seconds = EXCLUDED.cook_time_seconds, is_orderable = EXCLUDED.is_orderable, difficulty = EXCLUDED.difficulty;\n\n';
                
                sql += '-- ========= COOK RECIPE REQUIREMENTS V2 =========\n';
                sql += '-- 注意：由於 recipe_id 在資料庫中是 foreign key to an auto-incrementing id, 直接重建這部分 SQL 較為複雜。\n';
                sql += '-- 以下指令假設您會先清空 requirements 表，並搭配上面的 recipe 表一起重新插入。\n';
                sql += 'DELETE FROM cook_recipe_requirements_v2;\n';
                sql += 'INSERT INTO cook_recipe_requirements_v2 (recipe_id, required_item_id, quantity) VALUES\n';
                
                let reqValues = [];
                allRecipes.forEach(r => {
                    // 這裡需要一個方法從 recipe_id (string) 映射到資料庫的 recipe.id (integer)
                    // 為了簡化，我們先假設一個查詢邏輯
                    const recipeDbId = `(SELECT id FROM cook_recipes_v2 WHERE recipe_id = '${r.recipe_id}')`;
                    r.requirements.forEach(req => {
                        reqValues.push(`(${recipeDbId}, ${req.item_id}, ${req.quantity})`);
                    });
                });
                sql += reqValues.join(',\n') + ';\n\n';

                sqlOutput.textContent = sql;
            }

            // 初始化
            async function initialize() {
                await fetchItems();
                // 只有在 fetchItems 成功後才 fetchRecipes
                if (allItems.length > 0) {
                    await fetchRecipes();
                }
            }

            initialize();
            exportSqlBtn.addEventListener('click', exportSql);
        });
    </script>
</body>
</html>
