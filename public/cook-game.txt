# 料理急先鋒 - 項目執行說明

## 項目安裝與執行

### 1. 系統需求
- Node.js 14.0 或以上
- PostgreSQL 12.0 或以上
- 支援現代化瀏覽器 (Chrome, Firefox, Safari, Edge)

### 2. 系統架構說明

此專案已整合成一個單一的Node.js應用程式，由 `server.js` 作為主入口點。它同時管理主網站和「料理急先鋒」遊戲的後端服務。

- **主伺服器 (`server.js`)**:
  - 統一處理所有HTTP請求和WebSocket連接
  - 監聽單一端口 (例如 3000)
  - 處理用戶認證和會話管理

- **整合的服務**:
  - **主網站API**: 處理會員、文章等核心功能
  - **遊戲API (`/cook-api`)**: 由 `cook-kitchen-rush.js` 模組提供，處理所有遊戲相關的HTTP請求
  - **WebSocket服務**:
    - `/ws`: 主網站的WebSocket連接
    - `/cook-ws`: 料理急先鋒遊戲的專用WebSocket連接，處理即時遊戲狀態更新和玩家互動
  - 兩個WebSocket路徑由同一個WebSocket伺服器實例根據連接路徑進行路由

### 3. 遊戲核心功能

#### 3.1 即時互動系統
- **WebSocket通訊協議**:
  - `auth_success`: 玩家認證成功
  - `game_start`: 遊戲開始
  - `game_state_update`: 遊戲狀態更新
  - `new_order`: 新訂單到達
  - `order_complete`: 訂單完成
  - `inventory_update`: 庫存更新
  - `station_interaction`: 工作站互動
  - `level_up`: 玩家升級
  - `game_over`: 遊戲結束

#### 3.2 遊戲狀態管理
- **玩家狀態**:
  - 即時更新的庫存系統
  - 動態工作站互動
  - 個人分數追蹤
  - 等級和經驗值系統

- **遊戲機制**:
  - 即時訂單系統
  - 動態難度調整
  - 多人協作機制
  - 即時視覺反饋

#### 3.3 使用者介面特性
- **動態反饋**:
  - 工作站操作動畫
  - 烹飪進度指示器
  - 即時狀態更新
  - 錯誤提示動畫

- **移動裝置優化**:
  - 觸控友善界面
  - 自適應佈局
  - 垂直螢幕優化
  - 手勢操作支援

### 4. 環境配置

```env
# 共用資料庫配置
DB_USER=postgres
DB_HOST=localhost
DB_NAME=sunnyyummy_db
DB_PASSWORD=your_password
DB_PORT=5432

# 主系統配置
PORT=3000
JWT_SECRET=your_main_jwt_secret

# 料理急先鋒配置
COOK_JWT_SECRET=your_cook_game_jwt_secret
```

### 5. 資料庫設定

```sql
# 建立/更新主網站資料庫並應用所有 schema
psql -U postgres
CREATE DATABASE sunnyyummy_db; # 如果已存在會跳過
\c sunnyyummy_db; # 連接到資料庫
\i db_schema_main.sql # 應用主網站 schema (包含 box_users)
\i db_schema.sql # 應用料理急先鋒 schema
\q
```

### 6. 啟動服務

```bash
# 安裝依賴
npm install

# 啟動服務
npm start
```

### 7. 訪問應用
- 主網站：http://localhost:3000
- 料理急先鋒遊戲：http://localhost:3000/cook-login.html

## 技術特性

### 1. 前端架構
- **動態UI更新**:
  - 使用原生JavaScript實現即時DOM更新
  - 模組化的遊戲狀態管理
  - 響應式設計適配多種螢幕尺寸

- **動畫系統**:
  - CSS動畫效果
  - JavaScript控制的狀態轉換
  - 工作站互動視覺反饋

### 2. 後端架構
- **WebSocket管理**:
  - 自動重連機制
  - 心跳檢測
  - 錯誤處理和恢復
  - 狀態同步

- **遊戲邏輯**:
  - 訂單生成系統
  - 計分機制
  - 多人同步
  - 狀態持久化

### 3. 安全性
- **認證系統**:
  - JWT令牌驗證
  - WebSocket安全連接
  - 狀態驗證
  - 防作弊機制

## 開發指南

### 1. 代碼結構
```
sunnyyummy-app/
├── server.js               # 主網站服務器
├── cook-kitchen-rush.js    # 料理急先鋒遊戲服務器
├── public/
│   ├── cook-login.html     # 遊戲登入頁面
│   ├── cook-lobby.html     # 遊戲大廳
│   ├── cook-game.html      # 遊戲主頁面
│   ├── cook-result.html    # 遊戲結果頁面
│   └── assets/            # 遊戲資源文件
└── db/
    ├── schema.sql         # 資料庫結構
    └── migrations/        # 資料庫更新腳本
```

### 2. 開發工具
- VS Code 或其他現代編輯器
- PostgreSQL管理工具
- WebSocket測試工具
- 瀏覽器開發者工具

### 3. 調試技巧
- 使用瀏覽器控制台監控WebSocket通訊
- 檢查遊戲狀態變化
- 監控性能指標
- 測試多人互動場景

## 遊戲機制

### 1. 玩家互動
- **工作站操作**:
  - 點擊互動
  - 拖放操作
  - 即時反饋
  - 動畫效果

- **庫存管理**:
  - 物品欄系統
  - 容量限制
  - 物品組合
  - 即時更新

### 2. 多人協作
- **角色分工**:
  - 工作站分配
  - 任務協調
  - 資源共享
  - 團隊配合

- **即時通訊**:
  - 狀態同步
  - 操作廣播
  - 成就通知
  - 錯誤提示

### 3. 遊戲進程
- **關卡系統**:
  - 動態難度
  - 訂單生成
  - 時間限制
  - 分數計算

- **獎勵機制**:
  - 經驗值獲取
  - 等級提升
  - 成就解鎖
  - 特殊獎勵

## 維護指南

### 1. 常見問題
- WebSocket連接斷開處理
- 遊戲狀態不同步解決
- 性能優化建議
- 錯誤處理策略

### 2. 監控方案
- 服務器負載監控
- 玩家行為分析
- 錯誤日誌記錄
- 性能指標追蹤

### 3. 更新流程
- 代碼版本控制
- 資料庫遷移步驟
- 測試流程說明
- 部署檢查清單
```

</rewritten_file>













# 15. 前後端分離與API設計

## 15.1 RESTful API 端點設計

| 端點 | 方法 | 描述 | 權限需求 |
|:----------------------------|:-------|:-------------------------------|:---------------|
| /api/auth/login | POST | 會員登入 | 公開 |
| /api/auth/refresh | POST | 更新JWT令牌 | 已登入用戶 |
| /api/users/profile | GET | 獲取會員資料 | 已登入用戶 |
| /api/users/achievements | GET | 獲取會員成就 | 已登入用戶 |
| /api/games/rooms | GET | 獲取房間列表 | 已登入用戶 |
| /api/games/rooms | POST | 建立新遊戲房間 | 高級會員 |
| /api/games/rooms/:id/join | POST | 加入遊戲房間 | 已登入用戶 |
| /api/games/:id/history | GET | 獲取遊戲歷史 | 遊戲參與者 |
| /api/recipes | GET | 獲取食譜列表 (**從 `cook_recipes_v2` 獲取**)| 已登入用戶 |
| /api/items | GET | 獲取物品列表 (**從 `cook_items` 獲取**)| 已登入用戶 |
| /api/leaderboard | GET | 獲取排行榜 | 公開 |
| /api/ai/generate-level | POST | 生成AI關卡 (**可能包含新的 `cook_items` 和 `cook_recipes_v2` 數據**)| 管理員 |
| /api/admin/stats | GET | 獲取系統統計 | 管理員 |

## 15.2 WebSocket 事件規範

| 事件類型 | 方向 | 資料結構 | 描述 |
|:-------------------|:-----|:-------------------------------------------------|:---------------------------|
| `authenticate` | C → S | `{ "type": "authenticate", "token": "..." }` | 使用JWT進行WebSocket連接認證 |
| `auth_success` | S → C | `{ "type": "auth_success" }` | 認證成功 |
| `join_room` | C → S | `{ "type": "join_room", "roomId": "..." }` | 玩家請求加入房間 |
| `leave_room` | C → S | `{ "type": "leave_room", "roomId": "..." }` | 玩家請求離開房間 |
| `player_ready` | C → S | `{ "type": "player_ready" }` | 玩家設定為準備狀態 |
| `player_unready` | C → S | `{ "type": "player_unready" }` | 玩家取消準備狀態 |
| `start_game` | C → S | `{ "type": "start_game" }` | 房主請求開始遊戲 |
| `chat_message` | C → S | `{ "text": "..." }` | 發送聊天訊息 |
| `player_action` | C → S | `{ "action": "...", "data": {} }` | 執行遊戲中的核心操作 (底層邏輯已資料庫驅動化) |
| ` ` - `pick_ingredient` | | `data: {"ingredientId": "...", "slotIndex": ...}` | 從食材站拿取食材 |
| ` ` - `cook_item` | | `data: {"slotIndex": ..., "stationType": "..."}` | 在烹飪站烹飪物品 (依賴 `cook_recipes_v2`) |
| ` ` - `assemble_items`| | `data: {"itemIds": [...], "targetSlot": ...}` | 在組裝站組合料理 (依賴 `cook_recipes_v2`) |
| ` ` - `serve_dish` | | `data: {"dishId": "..."}` | 在上菜站上菜 (依賴 `cook_items.base_points`) |
| ` ` - `transfer_item`| | `data: {"fromSlot": ..., "toPlayerId": ..., "toSlot": ...}` | 將物品傳給其他玩家 |
| ` ` - `select_slot` | | `data: {"slotIndex": ...}` | 選擇庫存中的作用中物品 |
| `room_info` | S → C | `{ "room": { ... } }` | 伺服器發送房間詳細資訊 |
| `player_list` | S → C | `{ "players": [ ... ] }` | 廣播更新後的玩家列表 |
| `player_joined` | S → C | `{ "playerName": "..." }` | 廣播有新玩家加入 |
| `player_left` | S → C | `{ "playerName": "...", "newCreator": "..." }` | 廣播有玩家離開，可能含新房主 |
| `chat_message` | S → C | `{ "sender": "...", "text": "...", "avatar": "..." }` | 廣播聊天訊息 |
| `game_starting` | S → C | `{ "countdown": 3 }` | 廣播遊戲開始倒數 |
| `game_started` | S → C | `{ "gameState": { ... } }` | 廣播遊戲正式開始及初始狀態 |
| `game_state` | S → C | `{ "gameState": { ... } }` | (重連時)發送完整遊戲狀態 |
| `order_completed` | S → C | `{ "orderId": ..., "points": ..., "newScore": ... }` | 廣播訂單完成 |
| `new_order` | S → C | `{ "order": { ... } }` | 廣播新訂單生成 |
| `player_action` | S → C | `{ "playerId": ..., "action": ..., "data": {} }` | 廣播其他玩家的動作 |
| `dish_served` | S → C | `{ "success": true, "orderId": ..., "newScore": ... }` | (對操作者)確認上菜成功 |
| `error` | S → C | `{ "message": "..." }` | 發送錯誤訊息 |
| `game_over` | S → C | `{ "results": {}, "rewards": {} }` | 遊戲結束結算 |

# 16. 部署與發布策略

## 16.1 部署架構
系統部署在像Render這樣的雲端平台上，作為一個單一的Node.js服務實例。
-   **入口點**: 所有來自使用者的流量，無論是HTTP還是WebSocket，都首先由負載均衡器（如Cloudflare）接收，然後轉發到單一的伺服器應用。
-   **整合服務**: 伺服器內部：
    -   **Express.js** 處理所有HTTP請求，根據URL路徑將請求分發給靜態文件服務、主系統API或遊戲API (`/cook-api`)。
    -   **WebSocket.Server** 實例監聽所有WebSocket升級請求。它檢查請求的URL路徑 (`/ws` 或 `/cook-ws`)，並將連接交給相應的邏輯模組處理。
-   **後端依賴**: 應用程式連接到PostgreSQL資料庫進行數據持久化，並可能使用Redis進行會話緩存和排行榜等即時功能。

```
           [使用者]
              |
          [Cloudflare]  <-- CDN與DDoS防護
              |
              |
        [整合式服務器]  <-- 單一應用部署
        /     |     \
       /      |      \
 [靜態資源] [主系統API] [遊戲API]
       \      |      /
        \     |     /
      [WebSocket服務]
       /           \
      /             \
[/ws路徑]       [/cook-ws路徑]
      \             /
       \           /
        [Redis叢集]  <-- 狀態管理
              |
        [PostgreSQL]  <-- 關聯式資料庫
```

## 16.2 CI/CD 流程
1.  **代碼提交**: 開發人員提交至版本控制
2.  **自動測試**: 執行單元與整合測試
3.  **構建階段**: 打包前端資源, 構建後端映像
4.  **預發布**: 部署至測試環境進行驗證
5.  **自動部署**: 通過檢查後部署至生產環境
6.  **部署監控**: 監控新版本性能與穩定性

## 16.3 版本發布策略
-   **藍綠部署**: 維持兩套環境無縫切換
-   **金絲雀發布**: 向小部分用戶推出新功能
-   **功能開關**: 可遠程控制功能啟用/關閉
-   **回滾機制**: 問題發生時快速回復舊版本

# 17. 項目時間表與里程碑

## 17.1 開發階段與時間表

| 階段 | 時間範圍 | 主要目標 | 交付物 |
|:-------------------|:---------------|:-------------------------------|:-----------------------------|
| 需求分析與設計 | 第1-2週 | 完成需求收集與系統設計 | 需求文檔, 系統架構圖 |
| 核心功能開發 | 第3-6週 | 實現基本遊戲機制與界面 | 可運行原型, API基礎實現 |
| 會員系統整合 | 第7-8週 | 與主系統會員體系整合 | 完整登入流程, 會員數據同步 |
| 內容製作 (**資料庫化**) | 第9-12週 | 建立 `cook_items` 與 `cook_recipes_v2` 資料，並更新遊戲邏輯以從資料庫讀取 | 完整的遊戲物品與食譜數據 |
| Google AI 整合 | 第13-14週 | 實現AI關卡生成系統 | AI關卡生成功能, 模板庫 |
| 測試與優化 | 第15-16週 | 全面測試與效能優化 | 測試報告, 優化清單 |
| 發布準備 | 第17-18週 | 最終調整與部署準備 | 發布版本, 部署文檔 |

# 18. 未來擴展與維護計劃

## 18.1 計劃功能擴展
-   **跨平台原生應用**: 開發iOS/Android原生應用
-   **高級社交功能**: 好友系統, 戰隊對戰, 錦標賽
-   **自定義廚房**: 可自由布置的個人廚房空間
-   **創意工作坊**: 會員可創建並分享自己的料理配方 (利用 AI 和資料庫機制)
-   **高級AI整合**: 更深入的AI互動與程序化內容生成

## 18.2 長期維護策略
-   **每週小更新**: 修復問題, 調整平衡性
-   **月度內容更新**: 新食材, 新配方, 新挑戰 (透過資料庫更新)
-   **季度主題更新**: 大型內容包, 新功能, 新主題
-   **年度大型更新**: 系統性重大更新, 新玩法

## 18.3 社群與用戶反饋體系
-   **官方論壇**: 建立專屬社區討論區
-   **內遊戲反饋**: 遊戲內直接提交意見功能
-   **Beta測試計劃**: 邀請活躍會員參與新功能測試
-   **數據分析**: 建立用戶行為分析系統, 指導開發決策

# 19. 近期修復與調整紀錄

### 19.1 使用者介面 (UI) 修正

-   **統一的使用者狀態欄**: 在所有遊戲相關頁面 (`cook-lobby.html`, `cook-game-room.html`, `cook-game.html`, `cook-result.html`, `cook-help.html`) 的左上角新增並統一了使用者狀態顯示。此組件顯示玩家頭像和名稱，並採用了適合深色主題的樣式。
-   **修正大廳頁面樣式**: 解決了 `cook-lobby.html` 中使用者狀態顯示異常（顯示為大圖）的問題，確保其樣式與其他頁面一致。

### 19.2 核心功能與流程修復

-   **遊戲房間載入問題**: 解決了 `cook-game-room.html` 頁面卡在「載入中」的問題。修復方式為在客戶端發送 `join_room` WebSocket 事件時，明確包含 `userId`，確保伺服器能正確識別玩家身份並回傳房間資料。
-   **房間建立與加入流程**: 修正了 `cook-lobby.html` 中「創建房間」按鈕無響應的問題，並完善了加入房間的流程。

### 19.3 後端與網路通訊

-   **WebSocket 連線問題**: 修正了先前 WebSocket 連線端點錯誤的問題，確保所有遊戲頁面都連接到正確的 `/cook-ws` 路徑，並在 `cook-game-room.html` 中完善了重連與錯誤處理機制。
-   **身份驗證流程**: 改善了橫跨主站與遊戲的 `token` 處理邏輯，減少因 `token` 失效或遺失導致的非預期頁面跳轉。

### 19.4 遊戲房間穩定性與後端邏輯重構

-   **後端 WebSocket 邏輯重構**:
    -   全面重寫了 `handleAuthenticatedMessage` 函數，為 `join_room`, `leave_room`, `player_ready`, `chat_message`, `start_game` 等核心房間操作提供了穩定且完整的業務邏輯。
    -   新增 `broadcastToRoom` 輔助函數，標準化了向房間內所有玩家廣播訊息的流程。
    -   新增 `handlePlayerLeave` 輔助函數，完整處理玩家離開或斷線時的場景，包括房主轉移和房間狀態更新。
    -   確保了玩家的 WebSocket 連接實例 (`ws`) 與其在房間內的 `player` 物件正確綁定，解決了之前無法對特定玩家發送訊息的問題。

-   **修正房間創建邏輯**:
    -   修復了創建房間 API 中房主 ID 不正確的問題 (將 `req.user.id` 修正為 `req.user.userId`)。
    -   擴充了房間物件的結構，明確加入 `creatorId` 和 `creator` 欄位，使房主資訊更清晰。

-   **客戶端-伺服器通訊修正**:
    -   解決了遊戲房間頁面因 WebSocket 連線後立即中斷而無限循環載入的問題。
    -   透過對後端邏輯的重構和修正前端 `join_room` 事件的發送格式，確保了客戶端加入房間的流程穩定可靠。

### 19.5 資料庫整合與用戶資料處理

-   **用戶資料整合**: 修正了 `/users/profile` API 的查詢邏輯，使其正確從 `cook_players` 表中獲取遊戲相關資料，包括 `level`, `points`, `achievements` 和 `last_login` 等欄位。
-   **資料欄位映射**: 調整了資料欄位的映射方式，確保前端接收到的資料格式一致，並為遊戲特有欄位添加了 `player_` 前綴以避免與主系統欄位衝突。
-   **預設值處理**: 為首次遊玩的用戶提供了合理的預設值，如 `player_level: 1` 和 `player_points: 0`，確保新玩家體驗的順暢。

### 19.6 WebSocket 連接管理

-   **活躍連接追蹤**: 實現了 `activeConnections` Map 來追蹤用戶 ID 與其 WebSocket 連接的對應關係，便於精確定向發送消息。
-   **心跳機制優化**: 完善了 WebSocket 的心跳檢測機制，及時清理斷開的連接，減少服務器資源佔用。
-   **錯誤處理增強**: 為 WebSocket 連接添加了更完善的錯誤處理和日誌記錄，便於問題排查。

### 19.7 下一步優化計劃 (此處與後續第20節內容可能重疊，以第20節為最終、詳細的重構說明)

-   **遊戲核心邏輯實現**: 完成遊戲開始後的核心玩法邏輯，包括食材處理、烹飪流程和玩家協作機制。
-   **關卡生成系統**: 實現基於 Google AI API 的動態關卡生成系統，提供無限遊戲內容。
-   **性能監控**: 添加系統性能監控，及時發現並解決可能的瓶頸問題。
-   **用戶體驗優化**: 基於初期用戶反饋，進一步優化遊戲界面和操作流程。

### 19.8 完整遊戲循環與核心機制實現

-   **後端核心邏輯 (Backend Core Logic)**:
    -   **玩家動作實現**: 在 `cook-kitchen-rush.js` 中實現了完整的玩家動作處理，包括 `pick_ingredient`, `cook_item`, `assemble_items`, `serve_dish`, 和 `transfer_item`。所有動作都與資料庫中的 `game_state` 進行事務性同步，確保資料一致性。
    -   **訂單與計分系統**: 開發了 `generateOrder` 函數，可根據預設權重隨機生成不同難度的訂單。同時，`calculateOrderPoints` 函數根據訂單完成速度和料理複雜度計算分數。
    -   **食譜邏輯**: 實現了 `canAssembleRecipe` 函數，用於檢查玩家庫存並判斷可組裝的料理。目前食譜（如基本漢堡、起司漢堡、豪華漢堡）為硬編碼實現，為未來資料庫驅動的食譜系統奠定基礎。
    -   **遊戲狀態管理**: 遊戲開始後，所有遊戲進程（如計時、分數、訂單、玩家庫存）都集中在 `cook_game_rooms` 表的 `game_state` 欄位中進行管理。

-   **前端互動流程 (Frontend Interaction Flow)**:
    -   **工作站互動**: 前端 UI (`cook-game.html`) 現已支持與各個工作站（食材站、烹飪站、組裝站、上菜站）的互動，玩家操作會觸發對應的 WebSocket `player_action` 事件。
    -   **即時狀態更新**: 前端能接收並處理來自後端的各種狀態更新，如 `order_completed`, `new_order`, `player_list` 等，並即時呈現在介面上。
    -   **動態提示系統**: 增強了任務提示功能，能根據玩家當前庫存和訂單需求，提供更精準的操作指引。

-   **連線穩定性增強**:
    -   **斷線重連機制**: 實作了斷線緩衝機制。玩家短時間內斷線後（10秒內）可重新連線回到遊戲中，不會立刻被踢出房間，提升了在不穩定網路環境下的遊戲體驗。

### 19.9 重大UI/UX重構與操作流程優化

-   **手機優先佈局 (Mobile-First Layout)**:
    -   `cook-game.html` 的整體佈局已完全重構，以一個置中的、垂直滾動的「手機模擬器」視窗呈現。這確保了所有玩家（無論使用桌面或行動裝置）都能獲得一致且最佳化的遊戲體驗。
    -   遊戲元素被重新組織：頂部是狀態欄（計時器、分數），中間是可滾動的訂單列表和主要的廚房工作區，底部是固定的玩家物品欄。

-   **UI元素重新設計 (UI Element Redesign)**:
    -   **訂單列表 (Orders)**: 廢除了原先佔用大量空間的彩色長條圖設計，改為緊湊、清晰的卡片式列表。每張卡片直接顯示料理名稱和所需的食材圖示，更直觀易讀。
    -   **工作站 (Stations)**: 從水平滾動改為固定的兩列網格佈局，所有工作站一目了然，無需滾動即可訪問。

-   **操作流程優化 (Gameplay Flow Optimization)**:
    -   **自動選擇空槽**: 解決了玩家只能使用第一個物品槽的關鍵問題。現在，每當玩家成功拾取一個物品後，系統會**自動選擇下一個可用的空槽位**作為新的活動槽。這使得玩家可以連續、流暢地拾取多個物品，極大地提升了遊戲的可玩性和節奏感。

## 更新日誌

### 2024年3月更新
1.  **庫存系統優化**
    -   將玩家庫存槽位從5個增加到8個
    -   新的4x2網格佈局，更適合複雜食譜的製作
    -   特別優化了需要多種預處理食材的豪華漢堡製作流程

2.  **手機版面統一化**
    -   重新設計遊戲界面，採用固定寬度的垂直佈局
    -   最大寬度限制在480px，確保在所有設備上保持一致的體驗
    -   優化觸控區域大小，提升操作體驗
    -   改進視覺層級，使用深色主題提升可讀性

# 20. 後端核心邏輯重構與資料庫驅動化

## 總覽 (Overview)

本次重構的核心目標是將 `cook-kitchen-rush.js` 中的遊戲核心邏輯從**硬編碼 (Hardcoded)**規則轉變為**資料庫驅動 (Database-Driven)**。這使得遊戲內容（如食譜、物品、分數）的擴展和調整無需修改後端程式碼，僅需更新資料庫即可，大幅提高了可維護性和擴展性。

所有遊戲狀態的核心真理來源 (source of truth) 是 `cook_game_rooms` 資料表中的 `game_state` (JSONB) 欄位。所有玩家動作都會讀取、修改此狀態，然後寫回資料庫。

---

## 主要變更 (Major Changes)

### 1. 資料庫驅動的遊戲規則

移除了所有寫死在程式碼中的食譜、烹飪規則和上菜邏輯，改為由以下三個新的異步輔助函數從資料庫中查詢：

*   `getItemData(itemId)`
    *   **功能**: 從 `cook_items` 資料表查詢指定 ID 的物品資訊。
    *   **用途**: 用於獲取物品的基礎屬性，例如上菜時的分數 (`base_points`)。

*   `findCookingRecipe(rawItemId, stationType)`
    *   **功能**: 根據玩家使用的「生食材 ID」和「工作站類型」，從 `cook_recipes_v2` 查找對應的烹飪食譜。
    *   **用途**: 在 `cook_item` 動作中使用，以決定烹飪的結果、所需時間等。

*   `findAssemblyRecipe(ingredientItemTypes)`
    *   **功能**: 根據玩家提供的「食材類型陣列」，從 `cook_recipes_v2` 查找匹配的組合食譜。此函數會校驗食材的種類與數量是否完全匹配。
    *   **用途**: 在 `assemble_items` 動作中使用，以決定組合的結果。

### 2. 遊戲動作 (Player Actions) 邏輯重構

WebSocket `player_action` 的處理邏輯已全面更新，以使用上述新的資料庫輔助函數。

*   **`cook_item` (烹飪物品)**
    1.  調用 `findCookingRecipe` 查找食譜。
    2.  如果找到食譜，則更新玩家在 `game_state` 中的 `cooking` 狀態 (包含開始時間、所需時間、產出物品等)。
    3.  遊戲計時器 (`game_tick`) 會持續檢查並在烹飪完成後更新玩家庫存。

*   **`assemble_items` (組合物品)**
    1.  接收玩家選擇用於組合的多個物品。
    2.  提取這些物品的類型 (Item Type)。
    3.  調用 `findAssemblyRecipe` 查找匹配的食譜。
    4.  如果找到食譜，則從玩家庫存中移除消耗的食材，並將組合完成的料理加入庫存。

*   **`serve_dish` (上菜)**
    1.  驗證玩家提交的物品是否為一個有效的訂單。
    2.  調用 `getItemData` 獲取該料理的 `base_points` (基礎分數)。
    3.  **計分邏輯**: 直接在此動作中計算最終得分。分數 = `base_points` + `時間獎勵` (根據訂單剩餘時間給予加成)。
    4.  更新團隊總分和玩家個人貢獻分數。

### 3. 動態訂單與計分

*   **`generateOrder` (生成新訂單)**
    *   此函數現在會從 `cook_recipes_v2` 中查詢 `recipe_type = 'assembly'` 的所有食譜，並隨機選擇一個作為新訂單。這意味著所有可組合的料理都有可能成為遊戲中的訂單。

*   **計分邏輯遷移**
    *   原有的 `calculateOrderPoints` 函數已被完全移除。
    *   計分邏輯已整合至 `serve_dish` 動作處理器中，分數來源於資料庫中的 `cook_items.base_points`，使分數體系更易於管理。

### 4. 程式碼清理 (Code Cleanup)

以下硬編碼的輔助函數已被成功移除，使程式碼更簡潔：

*   `isCookable`
*   `getCookedType`
*   `isCompleteDish`
*   `canAssembleRecipe`
*   `calculateOrderPoints`

---

## 資料庫結構依賴 (Database Schema)

重構後的邏輯高度依賴以下兩個資料表：

*   `cook_items`
    *   **作用**: 定義遊戲中所有物品。
    *   **重要欄位**: `item_id`, `item_type`, `item_name`, `base_points`。

*   `cook_recipes_v2`
    *   **作用**: 定義所有製造食譜 (烹飪與組合)。
    *   **重要欄位**: `recipe_id`, `recipe_type` ('cooking' 或 'assembly'), `ingredients` (JSONB), `result_item_id`, `cook_station`, `cook_time_seconds`。
```

</rewritten_file>













# 15. 前後端分離與API設計

## 15.1 RESTful API 端點設計

| 端點 | 方法 | 描述 | 權限需求 |
|:----------------------------|:-------|:-------------------------------|:---------------|
| /api/auth/login | POST | 會員登入 | 公開 |
| /api/auth/refresh | POST | 更新JWT令牌 | 已登入用戶 |
| /api/users/profile | GET | 獲取會員資料 | 已登入用戶 |
| /api/users/achievements | GET | 獲取會員成就 | 已登入用戶 |
| /api/games/rooms | GET | 獲取房間列表 | 已登入用戶 |
| /api/games/rooms | POST | 建立新遊戲房間 | 高級會員 |
| /api/games/rooms/:id/join | POST | 加入遊戲房間 | 已登入用戶 |
| /api/games/:id/history | GET | 獲取遊戲歷史 | 遊戲參與者 |
| /api/recipes | GET | 獲取食譜列表 (**從 `cook_recipes_v2` 獲取**)| 已登入用戶 |
| /api/items | GET | 獲取物品列表 (**從 `cook_items` 獲取**)| 已登入用戶 |
| /api/leaderboard | GET | 獲取排行榜 | 公開 |
| /api/ai/generate-level | POST | 生成AI關卡 (**可能包含新的 `cook_items` 和 `cook_recipes_v2` 數據**)| 管理員 |
| /api/admin/stats | GET | 獲取系統統計 | 管理員 |

## 15.2 WebSocket 事件規範

| 事件類型 | 方向 | 資料結構 | 描述 |
|:-------------------|:-----|:-------------------------------------------------|:---------------------------|
| `authenticate` | C → S | `{ "type": "authenticate", "token": "..." }` | 使用JWT進行WebSocket連接認證 |
| `auth_success` | S → C | `{ "type": "auth_success" }` | 認證成功 |
| `join_room` | C → S | `{ "type": "join_room", "roomId": "..." }` | 玩家請求加入房間 |
| `leave_room` | C → S | `{ "type": "leave_room", "roomId": "..." }` | 玩家請求離開房間 |
| `player_ready` | C → S | `{ "type": "player_ready" }` | 玩家設定為準備狀態 |
| `player_unready` | C → S | `{ "type": "player_unready" }` | 玩家取消準備狀態 |
| `start_game` | C → S | `{ "type": "start_game" }` | 房主請求開始遊戲 |
| `chat_message` | C → S | `{ "text": "..." }` | 發送聊天訊息 |
| `player_action` | C → S | `{ "action": "...", "data": {} }` | 執行遊戲中的核心操作 (底層邏輯已資料庫驅動化) |
| ` ` - `pick_ingredient` | | `data: {"ingredientId": "...", "slotIndex": ...}` | 從食材站拿取食材 |
| ` ` - `cook_item` | | `data: {"slotIndex": ..., "stationType": "..."}` | 在烹飪站烹飪物品 (依賴 `cook_recipes_v2`) |
| ` ` - `assemble_items`| | `data: {"itemIds": [...], "targetSlot": ...}` | 在組裝站組合料理 (依賴 `cook_recipes_v2`) |
| ` ` - `serve_dish` | | `data: {"dishId": "..."}` | 在上菜站上菜 (依賴 `cook_items.base_points`) |
| ` ` - `transfer_item`| | `data: {"fromSlot": ..., "toPlayerId": ..., "toSlot": ...}` | 將物品傳給其他玩家 |
| ` ` - `select_slot` | | `data: {"slotIndex": ...}` | 選擇庫存中的作用中物品 |
| `room_info` | S → C | `{ "room": { ... } }` | 伺服器發送房間詳細資訊 |
| `player_list` | S → C | `{ "players": [ ... ] }` | 廣播更新後的玩家列表 |
| `player_joined` | S → C | `{ "playerName": "..." }` | 廣播有新玩家加入 |
| `player_left` | S → C | `{ "playerName": "...", "newCreator": "..." }` | 廣播有玩家離開，可能含新房主 |
| `chat_message` | S → C | `{ "sender": "...", "text": "...", "avatar": "..." }` | 廣播聊天訊息 |
| `game_starting` | S → C | `{ "countdown": 3 }` | 廣播遊戲開始倒數 |
| `game_started` | S → C | `{ "gameState": { ... } }` | 廣播遊戲正式開始及初始狀態 |
| `game_state` | S → C | `{ "gameState": { ... } }` | (重連時)發送完整遊戲狀態 |
| `order_completed` | S → C | `{ "orderId": ..., "points": ..., "newScore": ... }` | 廣播訂單完成 |
| `new_order` | S → C | `{ "order": { ... } }` | 廣播新訂單生成 |
| `player_action` | S → C | `{ "playerId": ..., "action": ..., "data": {} }` | 廣播其他玩家的動作 |
| `dish_served` | S → C | `{ "success": true, "orderId": ..., "newScore": ... }` | (對操作者)確認上菜成功 |
| `error` | S → C | `{ "message": "..." }` | 發送錯誤訊息 |
| `game_over` | S → C | `{ "results": {}, "rewards": {} }` | 遊戲結束結算 |

# 16. 部署與發布策略

## 16.1 部署架構
系統部署在像Render這樣的雲端平台上，作為一個單一的Node.js服務實例。
-   **入口點**: 所有來自使用者的流量，無論是HTTP還是WebSocket，都首先由負載均衡器（如Cloudflare）接收，然後轉發到單一的伺服器應用。
-   **整合服務**: 伺服器內部：
    -   **Express.js** 處理所有HTTP請求，根據URL路徑將請求分發給靜態文件服務、主系統API或遊戲API (`/cook-api`)。
    -   **WebSocket.Server** 實例監聽所有WebSocket升級請求。它檢查請求的URL路徑 (`/ws` 或 `/cook-ws`)，並將連接交給相應的邏輯模組處理。
-   **後端依賴**: 應用程式連接到PostgreSQL資料庫進行數據持久化，並可能使用Redis進行會話緩存和排行榜等即時功能。

```
           [使用者]
              |
          [Cloudflare]  <-- CDN與DDoS防護
              |
              |
        [整合式服務器]  <-- 單一應用部署
        /     |     \
       /      |      \
 [靜態資源] [主系統API] [遊戲API]
       \      |      /
        \     |     /
      [WebSocket服務]
       /           \
      /             \
[/ws路徑]       [/cook-ws路徑]
      \             /
       \           /
        [Redis叢集]  <-- 狀態管理
              |
        [PostgreSQL]  <-- 關聯式資料庫
```

## 16.2 CI/CD 流程
1.  **代碼提交**: 開發人員提交至版本控制
2.  **自動測試**: 執行單元與整合測試
3.  **構建階段**: 打包前端資源, 構建後端映像
4.  **預發布**: 部署至測試環境進行驗證
5.  **自動部署**: 通過檢查後部署至生產環境
6.  **部署監控**: 監控新版本性能與穩定性

## 16.3 版本發布策略
-   **藍綠部署**: 維持兩套環境無縫切換
-   **金絲雀發布**: 向小部分用戶推出新功能
-   **功能開關**: 可遠程控制功能啟用/關閉
-   **回滾機制**: 問題發生時快速回復舊版本

# 17. 項目時間表與里程碑

## 17.1 開發階段與時間表

| 階段 | 時間範圍 | 主要目標 | 交付物 |
|:-------------------|:---------------|:-------------------------------|:-----------------------------|
| 需求分析與設計 | 第1-2週 | 完成需求收集與系統設計 | 需求文檔, 系統架構圖 |
| 核心功能開發 | 第3-6週 | 實現基本遊戲機制與界面 | 可運行原型, API基礎實現 |
| 會員系統整合 | 第7-8週 | 與主系統會員體系整合 | 完整登入流程, 會員數據同步 |
| 內容製作 (**資料庫化**) | 第9-12週 | 建立 `cook_items` 與 `cook_recipes_v2` 資料，並更新遊戲邏輯以從資料庫讀取 | 完整的遊戲物品與食譜數據 |
| Google AI 整合 | 第13-14週 | 實現AI關卡生成系統 | AI關卡生成功能, 模板庫 |
| 測試與優化 | 第15-16週 | 全面測試與效能優化 | 測試報告, 優化清單 |
| 發布準備 | 第17-18週 | 最終調整與部署準備 | 發布版本, 部署文檔 |

# 18. 未來擴展與維護計劃

## 18.1 計劃功能擴展
-   **跨平台原生應用**: 開發iOS/Android原生應用
-   **高級社交功能**: 好友系統, 戰隊對戰, 錦標賽
-   **自定義廚房**: 可自由布置的個人廚房空間
-   **創意工作坊**: 會員可創建並分享自己的料理配方 (利用 AI 和資料庫機制)
-   **高級AI整合**: 更深入的AI互動與程序化內容生成

## 18.2 長期維護策略
-   **每週小更新**: 修復問題, 調整平衡性
-   **月度內容更新**: 新食材, 新配方, 新挑戰 (透過資料庫更新)
-   **季度主題更新**: 大型內容包, 新功能, 新主題
-   **年度大型更新**: 系統性重大更新, 新玩法

## 18.3 社群與用戶反饋體系
-   **官方論壇**: 建立專屬社區討論區
-   **內遊戲反饋**: 遊戲內直接提交意見功能
-   **Beta測試計劃**: 邀請活躍會員參與新功能測試
-   **數據分析**: 建立用戶行為分析系統, 指導開發決策

# 19. 近期修復與調整紀錄

### 19.1 使用者介面 (UI) 修正

-   **統一的使用者狀態欄**: 在所有遊戲相關頁面 (`cook-lobby.html`, `cook-game-room.html`, `cook-game.html`, `cook-result.html`, `cook-help.html`) 的左上角新增並統一了使用者狀態顯示。此組件顯示玩家頭像和名稱，並採用了適合深色主題的樣式。
-   **修正大廳頁面樣式**: 解決了 `cook-lobby.html` 中使用者狀態顯示異常（顯示為大圖）的問題，確保其樣式與其他頁面一致。

### 19.2 核心功能與流程修復

-   **遊戲房間載入問題**: 解決了 `cook-game-room.html` 頁面卡在「載入中」的問題。修復方式為在客戶端發送 `join_room` WebSocket 事件時，明確包含 `userId`，確保伺服器能正確識別玩家身份並回傳房間資料。
-   **房間建立與加入流程**: 修正了 `cook-lobby.html` 中「創建房間」按鈕無響應的問題，並完善了加入房間的流程。

### 19.3 後端與網路通訊

-   **WebSocket 連線問題**: 修正了先前 WebSocket 連線端點錯誤的問題，確保所有遊戲頁面都連接到正確的 `/cook-ws` 路徑，並在 `cook-game-room.html` 中完善了重連與錯誤處理機制。
-   **身份驗證流程**: 改善了橫跨主站與遊戲的 `token` 處理邏輯，減少因 `token` 失效或遺失導致的非預期頁面跳轉。

### 19.4 遊戲房間穩定性與後端邏輯重構

-   **後端 WebSocket 邏輯重構**:
    -   全面重寫了 `handleAuthenticatedMessage` 函數，為 `join_room`, `leave_room`, `player_ready`, `chat_message`, `start_game` 等核心房間操作提供了穩定且完整的業務邏輯。
    -   新增 `broadcastToRoom` 輔助函數，標準化了向房間內所有玩家廣播訊息的流程。
    -   新增 `handlePlayerLeave` 輔助函數，完整處理玩家離開或斷線時的場景，包括房主轉移和房間狀態更新。
    -   確保了玩家的 WebSocket 連接實例 (`ws`) 與其在房間內的 `player` 物件正確綁定，解決了之前無法對特定玩家發送訊息的問題。

-   **修正房間創建邏輯**:
    -   修復了創建房間 API 中房主 ID 不正確的問題 (將 `req.user.id` 修正為 `req.user.userId`)。
    -   擴充了房間物件的結構，明確加入 `creatorId` 和 `creator` 欄位，使房主資訊更清晰。

-   **客戶端-伺服器通訊修正**:
    -   解決了遊戲房間頁面因 WebSocket 連線後立即中斷而無限循環載入的問題。
    -   透過對後端邏輯的重構和修正前端 `join_room` 事件的發送格式，確保了客戶端加入房間的流程穩定可靠。

### 19.5 資料庫整合與用戶資料處理

-   **用戶資料整合**: 修正了 `/users/profile` API 的查詢邏輯，使其正確從 `cook_players` 表中獲取遊戲相關資料，包括 `level`, `points`, `achievements` 和 `last_login` 等欄位。
-   **資料欄位映射**: 調整了資料欄位的映射方式，確保前端接收到的資料格式一致，並為遊戲特有欄位添加了 `player_` 前綴以避免與主系統欄位衝突。
-   **預設值處理**: 為首次遊玩的用戶提供了合理的預設值，如 `player_level: 1` 和 `player_points: 0`，確保新玩家體驗的順暢。

### 19.6 WebSocket 連接管理

-   **活躍連接追蹤**: 實現了 `activeConnections` Map 來追蹤用戶 ID 與其 WebSocket 連接的對應關係，便於精確定向發送消息。
-   **心跳機制優化**: 完善了 WebSocket 的心跳檢測機制，及時清理斷開的連接，減少服務器資源佔用。
-   **錯誤處理增強**: 為 WebSocket 連接添加了更完善的錯誤處理和日誌記錄，便於問題排查。

### 19.7 下一步優化計劃 (此處與後續第20節內容可能重疊，以第20節為最終、詳細的重構說明)

-   **遊戲核心邏輯實現**: 完成遊戲開始後的核心玩法邏輯，包括食材處理、烹飪流程和玩家協作機制。
-   **關卡生成系統**: 實現基於 Google AI API 的動態關卡生成系統，提供無限遊戲內容。
-   **性能監控**: 添加系統性能監控，及時發現並解決可能的瓶頸問題。
-   **用戶體驗優化**: 基於初期用戶反饋，進一步優化遊戲界面和操作流程。

### 19.8 完整遊戲循環與核心機制實現

-   **後端核心邏輯 (Backend Core Logic)**:
    -   **玩家動作實現**: 在 `cook-kitchen-rush.js` 中實現了完整的玩家動作處理，包括 `pick_ingredient`, `cook_item`, `assemble_items`, `serve_dish`, 和 `transfer_item`。所有動作都與資料庫中的 `game_state` 進行事務性同步，確保資料一致性。
    -   **訂單與計分系統**: 開發了 `generateOrder` 函數，可根據預設權重隨機生成不同難度的訂單。同時，`calculateOrderPoints` 函數根據訂單完成速度和料理複雜度計算分數。
    -   **食譜邏輯**: 實現了 `canAssembleRecipe` 函數，用於檢查玩家庫存並判斷可組裝的料理。目前食譜（如基本漢堡、起司漢堡、豪華漢堡）為硬編碼實現，為未來資料庫驅動的食譜系統奠定基礎。
    -   **遊戲狀態管理**: 遊戲開始後，所有遊戲進程（如計時、分數、訂單、玩家庫存）都集中在 `cook_game_rooms` 表的 `game_state` 欄位中進行管理。

-   **前端互動流程 (Frontend Interaction Flow)**:
    -   **工作站互動**: 前端 UI (`cook-game.html`) 現已支持與各個工作站（食材站、烹飪站、組裝站、上菜站）的互動，玩家操作會觸發對應的 WebSocket `player_action` 事件。
    -   **即時狀態更新**: 前端能接收並處理來自後端的各種狀態更新，如 `order_completed`, `new_order`, `player_list` 等，並即時呈現在介面上。
    -   **動態提示系統**: 增強了任務提示功能，能根據玩家當前庫存和訂單需求，提供更精準的操作指引。

-   **連線穩定性增強**:
    -   **斷線重連機制**: 實作了斷線緩衝機制。玩家短時間內斷線後（10秒內）可重新連線回到遊戲中，不會立刻被踢出房間，提升了在不穩定網路環境下的遊戲體驗。

### 19.9 重大UI/UX重構與操作流程優化

-   **手機優先佈局 (Mobile-First Layout)**:
    -   `cook-game.html` 的整體佈局已完全重構，以一個置中的、垂直滾動的「手機模擬器」視窗呈現。這確保了所有玩家（無論使用桌面或行動裝置）都能獲得一致且最佳化的遊戲體驗。
    -   遊戲元素被重新組織：頂部是狀態欄（計時器、分數），中間是可滾動的訂單列表和主要的廚房工作區，底部是固定的玩家物品欄。

-   **UI元素重新設計 (UI Element Redesign)**:
    -   **訂單列表 (Orders)**: 廢除了原先佔用大量空間的彩色長條圖設計，改為緊湊、清晰的卡片式列表。每張卡片直接顯示料理名稱和所需的食材圖示，更直觀易讀。
    -   **工作站 (Stations)**: 從水平滾動改為固定的兩列網格佈局，所有工作站一目了然，無需滾動即可訪問。

-   **操作流程優化 (Gameplay Flow Optimization)**:
    -   **自動選擇空槽**: 解決了玩家只能使用第一個物品槽的關鍵問題。現在，每當玩家成功拾取一個物品後，系統會**自動選擇下一個可用的空槽位**作為新的活動槽。這使得玩家可以連續、流暢地拾取多個物品，極大地提升了遊戲的可玩性和節奏感。

## 更新日誌

### 2024年3月更新
1.  **庫存系統優化**
    -   將玩家庫存槽位從5個增加到8個
    -   新的4x2網格佈局，更適合複雜食譜的製作
    -   特別優化了需要多種預處理食材的豪華漢堡製作流程

2.  **手機版面統一化**
    -   重新設計遊戲界面，採用固定寬度的垂直佈局
    -   最大寬度限制在480px，確保在所有設備上保持一致的體驗
    -   優化觸控區域大小，提升操作體驗
    -   改進視覺層級，使用深色主題提升可讀性

# 20. 後端核心邏輯重構與資料庫驅動化

## 總覽 (Overview)

本次重構的核心目標是將 `cook-kitchen-rush.js` 中的遊戲核心邏輯從**硬編碼 (Hardcoded)**規則轉變為**資料庫驅動 (Database-Driven)**。這使得遊戲內容（如食譜、物品、分數）的擴展和調整無需修改後端程式碼，僅需更新資料庫即可，大幅提高了可維護性和擴展性。

所有遊戲狀態的核心真理來源 (source of truth) 是 `cook_game_rooms` 資料表中的 `game_state` (JSONB) 欄位。所有玩家動作都會讀取、修改此狀態，然後寫回資料庫。

---

## 主要變更 (Major Changes)

### 1. 資料庫驅動的遊戲規則

移除了所有寫死在程式碼中的食譜、烹飪規則和上菜邏輯，改為由以下三個新的異步輔助函數從資料庫中查詢：

*   `getItemData(itemId)`
    *   **功能**: 從 `cook_items` 資料表查詢指定 ID 的物品資訊。
    *   **用途**: 用於獲取物品的基礎屬性，例如上菜時的分數 (`base_points`)。

*   `findCookingRecipe(rawItemId, stationType)`
    *   **功能**: 根據玩家使用的「生食材 ID」和「工作站類型」，從 `cook_recipes_v2` 查找對應的烹飪食譜。
    *   **用途**: 在 `cook_item` 動作中使用，以決定烹飪的結果、所需時間等。

*   `findAssemblyRecipe(ingredientItemTypes)`
    *   **功能**: 根據玩家提供的「食材類型陣列」，從 `cook_recipes_v2` 查找匹配的組合食譜。此函數會校驗食材的種類與數量是否完全匹配。
    *   **用途**: 在 `assemble_items` 動作中使用，以決定組合的結果。

### 2. 遊戲動作 (Player Actions) 邏輯重構

WebSocket `player_action` 的處理邏輯已全面更新，以使用上述新的資料庫輔助函數。

*   **`cook_item` (烹飪物品)**
    1.  調用 `findCookingRecipe` 查找食譜。
    2.  如果找到食譜，則更新玩家在 `game_state` 中的 `cooking` 狀態 (包含開始時間、所需時間、產出物品等)。
    3.  遊戲計時器 (`game_tick`) 會持續檢查並在烹飪完成後更新玩家庫存。

*   **`assemble_items` (組合物品)**
    1.  接收玩家選擇用於組合的多個物品。
    2.  提取這些物品的類型 (Item Type)。
    3.  調用 `findAssemblyRecipe` 查找匹配的食譜。
    4.  如果找到食譜，則從玩家庫存中移除消耗的食材，並將組合完成的料理加入庫存。

*   **`serve_dish` (上菜)**
    1.  驗證玩家提交的物品是否為一個有效的訂單。
    2.  調用 `getItemData` 獲取該料理的 `base_points` (基礎分數)。
    3.  **計分邏輯**: 直接在此動作中計算最終得分。分數 = `base_points` + `時間獎勵` (根據訂單剩餘時間給予加成)。
    4.  更新團隊總分和玩家個人貢獻分數。

### 3. 動態訂單與計分

*   **`generateOrder` (生成新訂單)**
    *   此函數現在會從 `cook_recipes_v2` 中查詢 `recipe_type = 'assembly'` 的所有食譜，並隨機選擇一個作為新訂單。這意味著所有可組合的料理都有可能成為遊戲中的訂單。

*   **計分邏輯遷移**
    *   原有的 `calculateOrderPoints` 函數已被完全移除。
    *   計分邏輯已整合至 `serve_dish` 動作處理器中，分數來源於資料庫中的 `cook_items.base_points`，使分數體系更易於管理。

### 4. 程式碼清理 (Code Cleanup)

以下硬編碼的輔助函數已被成功移除，使程式碼更簡潔：

*   `isCookable`
*   `getCookedType`
*   `isCompleteDish`
*   `canAssembleRecipe`
*   `calculateOrderPoints`

---

## 資料庫結構依賴 (Database Schema)

重構後的邏輯高度依賴以下兩個資料表：

*   `cook_items`
    *   **作用**: 定義遊戲中所有物品。
    *   **重要欄位**: `item_id`, `item_type`, `item_name`, `base_points`。

*   `cook_recipes_v2`
    *   **作用**: 定義所有製造食譜 (烹飪與組合)。
    *   **重要欄位**: `recipe_id`, `recipe_type` ('cooking' 或 'assembly'), `ingredients` (JSONB), `result_item_id`, `cook_station`, `cook_time_seconds`。
```

</rewritten_file>