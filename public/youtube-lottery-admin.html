<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube 直播抽獎管理後台</title>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
    <style>
        :root {
            --bg-color: #1a1a2e;
            --primary-color: #16213e;
            --secondary-color: #0f3460;
            --accent-color: #e94560;
            --text-color: #dcdcdc;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --border-radius: 8px;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            display: grid;
            grid-template-columns: 280px 1fr 350px;
            grid-template-rows: auto 1fr auto;
            grid-template-areas:
                "header header header"
                "settings-panel animation-panel participants-panel"
                "footer footer footer";
            gap: 20px;
            width: 100%;
            max-width: 1600px;
            height: 90vh;
        }

        .panel {
            background-color: var(--primary-color);
            border-radius: var(--border-radius);
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
        }

        h1, h2 {
            color: var(--accent-color);
            text-align: center;
            margin-top: 0;
        }

        #header { grid-area: header; text-align: center; padding-bottom: 10px; }
        #settings-panel { grid-area: settings-panel; }
        #animation-panel { grid-area: animation-panel; justify-content: center; align-items: center; position: relative; overflow: hidden; }
        #participants-panel { grid-area: participants-panel; }
        #footer { grid-area: footer; }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        input[type="text"], input[type="number"], select {
            width: 100%;
            padding: 10px;
            background-color: var(--bg-color);
            border: 1px solid var(--secondary-color);
            border-radius: 5px;
            color: var(--text-color);
            box-sizing: border-box;
        }

        button {
            width: 100%;
            padding: 12px;
            background-color: var(--accent-color);
            border: none;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        button:hover {
            background-color: #f06a81;
        }
        
        button.secondary {
             background-color: var(--secondary-color);
        }
        button.secondary:hover {
            background-color: #1a4a8a;
        }


        #participants-list {
            flex-grow: 1;
            overflow-y: auto;
            padding-right: 10px;
        }

        .participant {
            display: flex;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid var(--secondary-color);
            cursor: pointer;
            position: relative;
        }
        
        .participant:hover {
            background-color: var(--secondary-color);
        }

        .participant.selected {
            background-color: rgba(233, 69, 96, 0.2);
        }

        .participant .delete-btn {
            position: absolute;
            right: 10px;
            padding: 5px 10px;
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            display: none;
        }

        .participant.selected .delete-btn {
            display: block;
        }

        .participant .delete-btn:hover {
            background-color: #d63031;
        }

        .participant img {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            margin-right: 12px;
        }
        
        #participants-count {
            margin-top: 15px;
            text-align: center;
            font-size: 1.2em;
        }
        
        #status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--secondary-color);
            padding: 10px 20px;
            border-radius: var(--border-radius);
            margin-top: 10px;
        }
        
        #ws-status {
            font-weight: bold;
        }
        .status-connected { color: #50fa7b; }
        .status-disconnected { color: #ff5555; }

        /* Animation Styles */
        #winner-display {
            display: none !important; /* 根據要求，不再使用彈出式卡片 */
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background: rgba(255, 255, 255, 0.95);
            padding: 20px 40px;
            border-radius: 10px;
            box-shadow: 0 5px 25px rgba(0,0,0,0.3);
            text-align: center;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: none;
        }

        #winner-display.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            pointer-events: auto;
        }

        #winner-display img {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            margin-bottom: 10px;
        }

        #winner-display h2 {
            margin: 10px 0;
            color: #ff4757;
        }

        #winner-display h3 {
            font-size: 1.5em;
            color: #333;
        }

        .close-winner {
            position: absolute;
            top: 10px;
            right: 10px;
            cursor: pointer;
            font-size: 20px;
            color: #666;
        }

        #confetti-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #draw-animation-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2em;
        }

        @keyframes fadeIn {
          from { opacity: 0; transform: scale(0.8); }
          to { opacity: 1; transform: scale(1); }
        }

        #animation-container {
            width: 100%;
            height: 500px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
        }

        #wheel-canvas {
            margin: 0 auto;
            display: block;
            background: white;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }

        #pointer-animation {
            width: 100%;
            height: 150px;
            position: relative;
            overflow: hidden;
            border: 2px solid var(--secondary-color);
            border-radius: var(--border-radius);
            background: var(--bg-color);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #pointer-winner-display {
            position: absolute;
            color: white;
            font-size: 3em;
            font-weight: bold;
            text-shadow: 0 0 15px var(--accent-color), 0 0 10px rgba(0,0,0,0.8);
            z-index: 5;
            text-align: center;
            animation: fadeIn 0.5s ease;
        }

        #pointer {
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-top: 20px solid var(--accent-color);
            z-index: 3;
            filter: drop-shadow(0px 2px 3px rgba(0,0,0,0.5));
        }

        #participants-reel {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            display: flex;
            will-change: transform;
        }

        .reel-participant-card {
            width: 120px;
            height: 120px;
            margin: 15px 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: var(--secondary-color);
            border-radius: var(--border-radius);
            text-align: center;
            flex-shrink: 0;
            padding: 5px;
            box-sizing: border-box;
            color: var(--text-color);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .reel-participant-card img {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin-bottom: 8px;
        }

        .reel-participant-card span {
            font-size: 0.9em;
            font-weight: bold;
            word-break: break-all;
        }

        #default-animation {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        #participants-list {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 400px;
            overflow-y: auto;
        }

        #participants-list li {
            display: flex;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .participant-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .winner-highlight {
            color: #ff4757;
            font-weight: bold;
            font-size: 1.2em;
            text-shadow: 0 0 5px rgba(255,71,87,0.3);
            background: rgba(255,71,87,0.1);
        }

        /* Remove animation duration input */
        #animation-duration {
            display: none;
        }

        /* Animated Button from Uiverse.io by gharsh11032000 - Adapted for this project */
        .animated-button {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 16px 36px;
            border: 2px solid var(--accent-color);
            border-radius: 100px;
            font-weight: 600;
            color: var(--accent-color);
            background-color: transparent;
            cursor: pointer;
            overflow: hidden;
            transition: all 0.6s cubic-bezier(0.23, 1, 0.32, 1);
            width: 100%;
            box-sizing: border-box;
            margin-top: 10px;
        }

        .animated-button svg {
            position: absolute;
            width: 24px;
            fill: var(--accent-color);
            z-index: 9;
            transition: all 0.8s cubic-bezier(0.23, 1, 0.32, 1);
        }

        .animated-button .arr-1 {
            right: 16px;
        }

        .animated-button .arr-2 {
            left: -25%;
        }

        .animated-button .circle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            background-color: var(--accent-color);
            border-radius: 50%;
            opacity: 0;
            transition: all 0.8s cubic-bezier(0.23, 1, 0.32, 1);
        }

        .animated-button .text {
            position: relative;
            z-index: 1;
            transform: translateX(0px); /* Adjusted for better centering */
            transition: all 0.8s cubic-bezier(0.23, 1, 0.32, 1);
        }

        .animated-button:hover {
            box-shadow: 0 0 0 4px rgba(0, 0, 0, 0.2);
            color: var(--bg-color);
            border-radius: 12px;
        }

        .animated-button:hover .arr-1 {
            right: -25%;
        }

        .animated-button:hover .arr-2 {
            left: 16px;
        }

        .animated-button:hover .text {
            transform: translateX(0px); /* Adjusted for better centering */
        }

        .animated-button:hover svg {
            fill: var(--bg-color);
        }

        .animated-button:active {
            scale: 0.95;
            box-shadow: 0 0 0 4px var(--accent-color);
        }

        .animated-button:hover .circle {
            width: 220px;
            height: 220px;
            opacity: 1;
        }

        /* Punch-hole (洞洞樂) animation styles */
        #punch-hole-animation {
            width: 100%;
            height: 500px;
            position: relative;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 15px;
            padding: 20px;
            box-sizing: border-box;
            perspective: 1000px;
            overflow: hidden;
        }

        .punch-card {
            width: 120px;
            height: 150px;
            position: relative;
            transition: all 0.6s ease;
            transform-style: preserve-3d;
            cursor: pointer;
            margin: 5px;
            justify-self: center;
        }

        .punch-card.shuffling {
            position: absolute;
            transition: all 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .punch-card.face-down {
            transform: rotateY(180deg);
        }

        .punch-card.selected {
            transform: rotateY(0deg);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            cursor: default;
            z-index: 10;
        }

        .punch-card.winner {
            box-shadow: 0 0 25px gold;
            animation: winner-pulse 1s infinite alternate;
        }

        .punch-card-front, .punch-card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .punch-card-front {
            background: var(--accent-color);
            padding: 10px;
            text-align: center;
        }

        .punch-card-back {
            background: linear-gradient(135deg, var(--secondary-color), var(--primary-color));
            border: 2px solid var(--accent-color);
            transform: rotateY(180deg);
        }

        .punch-card-front img {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid white;
            margin-bottom: 8px;
        }

        .punch-card-front span {
            font-size: 14px;
            font-weight: bold;
            color: white;
            word-break: break-word;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .punch-card-back::before {
            content: "";
            background-image: url('/android-chrome-192x192.png');
            background-size: 80px 80px;
            background-position: center;
            background-repeat: no-repeat;
            width: 100%;
            height: 100%;
            display: block;
        }

        @keyframes winner-pulse {
            from { box-shadow: 0 0 15px rgba(255, 215, 0, 0.5); }
            to { box-shadow: 0 0 25px rgba(255, 215, 0, 0.8); }
        }

        #punch-hole-winner-display {
            position: absolute;
            top: 10px;
            left: 0;
            right: 0;
            text-align: center;
            color: white;
            font-size: 2em;
            font-weight: bold;
            text-shadow: 0 0 10px var(--accent-color);
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.5s ease;
            z-index: 10;
        }

        #punch-hole-winner-display.show {
            opacity: 1;
            transform: translateY(0);
        }

        .punch-instruction {
            position: absolute;
            bottom: 10px;
            left: 0;
            right: 0;
            text-align: center;
            color: var(--text-color);
            font-size: 1.2em;
            opacity: 0.8;
        }

        /* Toggle Switch from Uiverse.io by teymr */
        #checkbox {
            display: none;
        }

        .switch {
            position: relative;
            width: 70px;
            height: 70px;
            background-color: rgb(99, 99, 99);
            border-radius: 50%;
            z-index: 1;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid rgb(126, 126, 126);
            box-shadow: 0px 0px 3px rgb(2, 2, 2) inset;
            transition: 0.5s;
        }

        .switch svg {
            width: 1.2em;
        }

        .switch svg path {
            fill: rgb(48, 48, 48);
        }

        #checkbox:checked + .switch {
            box-shadow:
                0px 0px 1px rgb(151, 243, 255) inset,
                0px 0px 2px rgb(151, 243, 255) inset,
                0px 0px 10px rgb(151, 243, 255) inset,
                0px 0px 40px rgb(151, 243, 255),
                0px 0px 100px rgb(151, 243, 255),
                0px 0px 5px rgb(151, 243, 255);
            border: 2px solid rgb(255, 255, 255);
            background-color: rgb(146, 180, 184);
        }

        #checkbox:checked + .switch svg {
            filter: drop-shadow(0px 0px 5px rgb(151, 243, 255));
        }

        #checkbox:checked + .switch svg path {
            fill: rgb(255, 255, 255);
        }

        #checkbox:active + .switch {
            transform: translate(0em, 0.1em);
            box-shadow:
                0px 0px 0.1px rgb(151, 243, 255) inset,
                0px 0px 0.2px rgb(151, 243, 255) inset,
                0px 0px 1px rgb(151, 243, 255) inset,
                0px 0px 10px rgb(151, 243, 255),
                0px 0px 50px rgb(151, 243, 255);
            border: 2px solid rgb(255, 255, 255);
            background-color: rgb(146, 180, 184);
        }

        #checkbox:active + .switch svg path {
            box-shadow: 0.2em 0.2em 0.3em rgba(0, 0, 0, 0.3);
            transform: translate(0em, 0.1em);
        }

        .toggle-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px 0;
        }

        .toggle-label {
            margin-top: 10px;
            font-size: 0.9em;
            color: var(--text-color);
            text-align: center;
        }

        .toggle-status {
            margin-bottom: 10px;
            font-weight: bold;
            color: var(--accent-color);
        }
    </style>
</head>
<body>

   

    <div class="container">
        <div id="settings-panel" class="panel">
            <h2>系統設定</h2>
            <div class="form-group">
                <label for="video-id">YouTube Video ID</label>
                <input type="text" id="video-id" placeholder="例如：dQw4w9WgXcQ">
            </div>
            <div class="form-group">
                <label for="lottery-keyword">抽獎關鍵字</label>
                <input type="text" id="lottery-keyword" placeholder="例如：我要抽獎">
            </div>
            <div class="form-group">
                <label for="api-rate-limit">API 請求間隔 (秒)</label>
                <select id="api-rate-limit">
                    <option value="5">5秒</option>
                    <option value="10" selected>10秒</option>
                    <option value="20">20秒</option>
                </select>
            </div>
            <div class="toggle-container">
                <div class="toggle-status">系統狀態: 停止中</div>
                <input type="checkbox" id="checkbox">
                <label class="switch" for="checkbox">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
                        <path d="M288 256C288 273.7 273.7 288 256 288C238.3 288 224 273.7 224 256C224 238.3 238.3 224 256 224C273.7 224 288 238.3 288 256zM0 256C0 114.6 114.6 0 256 0C397.4 0 512 114.6 512 256C512 397.4 397.4 512 256 512C114.6 512 0 397.4 0 256zM256 464C370.9 464 464 370.9 464 256C464 141.1 370.9 48 256 48C141.1 48 48 141.1 48 256C48 370.9 141.1 464 256 464z"></path>
                    </svg>
                </label>
                <div class="toggle-label">點擊開關以開始/停止監控</div>
            </div>
            <hr style="border-color: var(--secondary-color); margin: 20px 0;">
             <h2>抽獎控制</h2>
            <div class="form-group">
                <label for="animation-mode">抽獎動畫</label>
                 <select id="animation-mode">
                    <option value="turntable" selected>轉盤式</option>
                    <option value="pointer">指針式</option>
                    <option value="punch-hole">洞洞樂</option>
                </select>
            </div>
            <div class="form-group">
                <label for="animation-duration">動畫時長 (分鐘)</label>
                <input type="number" id="animation-duration" value="0" min="0">
            </div>
             <button id="draw-winner-btn" class="animated-button">
                <svg viewBox="0 0 24 24" class="arr-2" xmlns="http://www.w3.org/2000/svg">
                    <path d="M16.1716 10.9999L10.8076 5.63589L12.2218 4.22168L20 11.9999L12.2218 19.778L10.8076 18.3638L16.1716 12.9999H4V10.9999H16.1716Z"></path>
                </svg>
                <span class="text">立即抽獎</span>
                <span class="circle"></span>
                <svg viewBox="0 0 24 24" class="arr-1" xmlns="http://www.w3.org/2000/svg">
                    <path d="M16.1716 10.9999L10.8076 5.63589L12.2218 4.22168L20 11.9999L12.2218 19.778L10.8076 18.3638L16.1716 12.9999H4V10.9999H16.1716Z"></path>
                </svg>
            </button>
        </div>

        <div id="animation-panel" class="panel">
            <canvas id="confetti-canvas"></canvas>
            <div id="animation-container">
                <canvas id="wheel-canvas" width="500" height="500" style="display: none;"></canvas>
                <div id="pointer-animation" style="display: none;">
                    <div id="pointer-winner-display" style="display: none;"></div>
                    <div id="pointer"></div>
                    <div id="participants-reel"></div>
                </div>
                <div id="punch-hole-animation" style="display: none;">
                    <div id="punch-hole-winner-display"></div>
                    <div class="punch-instruction">請點擊「打亂卡片」開始抽獎</div>
                </div>
                <div id="default-animation" style="text-align: center; padding: 20px;">
                    請先設定直播並開始監控
                </div>
            </div>
            <div id="winner-display">
                <span class="close-winner">&times;</span>
                <img id="winner-avatar" alt="Winner Avatar">
                <h2>🎉 恭喜中獎 🎉</h2>
                <h3 id="winner-name"></h3>
            </div>
        </div>

        <div id="participants-panel" class="panel">
            <h2>參與者名單</h2>
            <button id="refresh-participants-btn" class="secondary" style="margin-bottom: 10px;">手動更新名單</button>
            <div id="participants-list">
                <!-- Participants will be dynamically added here -->
            </div>
            <div id="participants-count">
                目前參與人數：0 人
            </div>
        </div>

        <div id="footer" class="panel">
             <div id="status-bar">
                <div id="current-video">當前監控 Video ID: 無</div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const videoIdEl = document.getElementById('video-id');
            const keywordEl = document.getElementById('lottery-keyword');
            const apiRateInput = document.getElementById('api-rate-limit');
            const setVideoBtn = null; // 原按鈕已移除
            const stopMonitoringBtn = null; // 原按鈕已移除
            const currentVideoEl = document.getElementById('current-video');
            const participantsListEl = document.getElementById('participants-list');
            const participantsCountEl = document.getElementById('participants-count');
            const drawWinnerBtn = document.getElementById('draw-winner-btn');
            const animationModeEl = document.getElementById('animation-mode');
            const durationEl = document.getElementById('animation-duration');
            const animationContainer = document.getElementById('animation-container');
            const defaultAnimation = document.getElementById('default-animation');
            const winnerDisplayEl = document.getElementById('winner-display');
            const winnerAvatarEl = document.getElementById('winner-avatar');
            const winnerNameEl = document.getElementById('winner-name');
            const confettiCanvas = document.getElementById('confetti-canvas');
            const refreshParticipantsBtn = document.getElementById('refresh-participants-btn');
            const wheelCanvas = document.getElementById('wheel-canvas');
            const wheelCtx = wheelCanvas.getContext('2d');
            const pointerAnimationEl = document.getElementById('pointer-animation');
            const participantsReelEl = document.getElementById('participants-reel');
            const punchHoleAnimationEl = document.getElementById('punch-hole-animation');
            const punchHoleWinnerDisplayEl = document.getElementById('punch-hole-winner-display');
            const monitoringToggle = document.getElementById('checkbox');
            const toggleStatusEl = document.querySelector('.toggle-status');

            const myConfetti = confetti.create(confettiCanvas, {
                resize: true,
                useWorker: true
            });

            let currentRotation = 0;
            let isSpinning = false;
            let angularVelocity = 0;
            const FRICTION = 0.995; // 摩擦力係數，確保輪盤最終會停下
            let selectedWinner = null;
            let updateTimer = null;
            let participants = []; // 在記憶體中保存參與者列表，避免重複讀取
            let winnerText = ''; // 用於在畫布中心顯示中獎者名字

            // Pointer animation state
            let isReelSpinning = false;
            let reelVelocity = 0;
            let reelPosition = 0;
            let reelAnimationId = null;
            const REEL_FRICTION = 0.988; // 摩擦力, 數值越小停越快
            const IDLE_SPEED = 60; // 待機時的滾動速度 (已提高)
            let idleAnimationId = null;
            let pointerWinnerDecided = false;
            let punchHoleReady = false;
            let punchHoleWinnerSelected = false;
            let punchHoleWinner = null;
            let isPunchHoleShuffled = false;

            function drawWheel() {
                if (!wheelCanvas || !defaultAnimation) return;

                const totalParticipants = participants.length;
                    
                if (totalParticipants === 0) {
                    wheelCanvas.style.display = 'none';
                    defaultAnimation.style.display = 'block';
                    defaultAnimation.textContent = '監控中...等待參與者加入';
                    return;
                }

                wheelCanvas.style.display = 'block';
                defaultAnimation.style.display = 'none';

                const centerX = wheelCanvas.width / 2;
                const centerY = wheelCanvas.height / 2;
                const radius = Math.min(centerX, centerY) - 20;

                wheelCtx.clearRect(0, 0, wheelCanvas.width, wheelCanvas.height);

                wheelCtx.save();
                wheelCtx.translate(centerX, centerY);
                
                // 為了簡化角度計算，我們讓指針指向 3 點鐘方向，並旋轉輪盤
                wheelCtx.rotate(currentRotation);

                const sliceAngle = (2 * Math.PI) / totalParticipants;
                participants.forEach((p, index) => {
                    const startAngle = index * sliceAngle;
                    const endAngle = startAngle + sliceAngle;

                    // Draw slice
                    wheelCtx.beginPath();
                    wheelCtx.moveTo(0, 0);
                    wheelCtx.arc(0, 0, radius, startAngle, endAngle);
                    wheelCtx.closePath();
                    wheelCtx.fillStyle = `hsl(${(360 / totalParticipants) * index}, 70%, 60%)`;
                    wheelCtx.fill();
                    wheelCtx.stroke();

                    // Draw text
                    wheelCtx.save();
                    wheelCtx.rotate(startAngle + sliceAngle / 2);
                    wheelCtx.textAlign = 'right';
                    wheelCtx.fillStyle = 'white';
                    wheelCtx.font = '14px Arial';
                    const displayName = p.displayName.length > 10 ? p.displayName.substring(0, 10) + '...' : p.displayName;
                    wheelCtx.fillText(displayName, radius - 10, 5);
                    wheelCtx.restore();
                });

                wheelCtx.restore();

                // 將指針畫在 12 點鐘方向（頂部），保持靜止
                wheelCtx.save();
                wheelCtx.translate(centerX, centerY - radius - 20); // 移到輪盤正上方
                wheelCtx.fillStyle = '#ff4757';
                
                wheelCtx.beginPath();
                wheelCtx.moveTo(0, 20); // 指針尖端指向輪盤邊緣
                wheelCtx.lineTo(-10, 0);
                wheelCtx.lineTo(10, 0);
                wheelCtx.closePath();
                wheelCtx.fill();
                wheelCtx.restore();

                // 如果輪盤已停止且有中獎者，在中間顯示名字
                if (!isSpinning && winnerText) {
                    wheelCtx.save();
                    wheelCtx.font = 'bold 40px ' + getComputedStyle(document.body).fontFamily;
                    wheelCtx.fillStyle = 'rgba(255, 255, 255, 1)';
                    wheelCtx.textAlign = 'center';
                    wheelCtx.textBaseline = 'middle';
                    wheelCtx.shadowColor = 'black';
                    wheelCtx.shadowBlur = 10;
                    wheelCtx.shadowOffsetX = 2;
                    wheelCtx.shadowOffsetY = 2;
                    const displayName = winnerText.length > 10 ? winnerText.substring(0, 10) + '...' : winnerText;
                    wheelCtx.fillText(displayName, centerX, centerY);
                    wheelCtx.restore();
                }
            }
            
            function startSpin() {
                if (isSpinning) return;
                if (participants.length < 2) {
                    alert('需要至少兩位參與者才能開始轉盤抽獎！');
                    return;
                }
                winnerText = ''; // 清除上一位中獎者名字
                isSpinning = true;
                // 給予一個隨機的初始速度 (弧度/幀)
                angularVelocity = (Math.random() * 0.2) + 0.4;
                requestAnimationFrame(animate);
            }

            function animate() {
                if (!isSpinning) return;

                currentRotation += angularVelocity;
                angularVelocity *= FRICTION; // 應用摩擦力使其減速

                drawWheel();

                // 當速度小於一個閾值時，停止動畫
                if (angularVelocity < 0.001) {
                    isSpinning = false;
                    angularVelocity = 0;
                    drawWheel(); // 畫最後一幀確保位置精確
                    determineWinnerFromAngle();
                } else {
                    requestAnimationFrame(animate);
                }
            }
            
            function determineWinnerFromAngle() {
                const totalParticipants = participants.length;
                if (totalParticipants === 0) return;

                const sliceAngle = (2 * Math.PI) / totalParticipants;
                
                // 指針在 12 點鐘方向 (3*PI/2)，我們以此為基準計算
                const pointerAngle = 3 * Math.PI / 2;
                const finalAngle = currentRotation % (2 * Math.PI);
                const targetAngle = (2 * Math.PI - finalAngle + pointerAngle) % (2 * Math.PI);
                const winnerIndex = Math.floor(targetAngle / sliceAngle);

                const winner = participants[winnerIndex];
                if (winner) {
                    selectedWinner = winner;
                    winnerText = winner.displayName; // 設定要顯示的文字
                    highlightWinner(winner);
                    // showWinner(winner); // 不再彈出卡片
                    myConfetti({
                        particleCount: 150,
                        spread: 90,
                        origin: { y: 0.6 }
                    });
                    drawWheel(); // 重新繪製以立即顯示名字
                }
            }

            function highlightWinner(winner) {
                const participantsList = participantsListEl.querySelectorAll('li');
                participantsList.forEach(li => {
                    li.classList.remove('winner-highlight');
                    if (li.querySelector('span').textContent.includes(winner.displayName)) {
                        li.classList.add('winner-highlight');
                        li.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                });
            }

            function buildParticipantsReel() {
                if (!participantsReelEl) return;
                participantsReelEl.innerHTML = '';
                participantsReelEl.style.transition = 'none';
                participantsReelEl.style.transform = 'translateX(0px)';

                if (participants.length === 0) {
                    stopReelIdleAnimation();
                    return;
                }

                // 為了製造無限滾動的感覺，我們複製參與者列表
                const reelParticipants = [];
                const repeatCount = Math.max(5, Math.ceil(40 / participants.length));
                for(let i = 0; i < repeatCount; i++) {
                    reelParticipants.push(...participants);
                }
                
                reelParticipants.forEach(p => {
                    const card = document.createElement('div');
                    card.className = 'reel-participant-card';
                    card.dataset.channelId = p.channelId;
                    card.innerHTML = `
                        <img src="${p.profileImageUrl}" alt="${p.displayName}">
                        <span>${p.displayName.substring(0, 12)}</span>
                    `;
                    participantsReelEl.appendChild(card);
                });

                startReelIdleAnimation();
            }

            function startReelIdleAnimation() {
                stopReelIdleAnimation(); // 確保只有一個動畫在跑

                let lastTime = null;
                function idleAnimate(time) {
                    if (!lastTime) {
                        lastTime = time;
                        idleAnimationId = requestAnimationFrame(idleAnimate);
                        return;
                    }
                    const deltaTime = time - lastTime;
                    lastTime = time;

                    reelPosition -= IDLE_SPEED * (deltaTime / 16); // 標準化到 60fps
                    
                    const cardWidth = 120 + 20; // card width + margin
                    const loopWidth = cardWidth * participants.length;
                    if (reelPosition < -loopWidth) {
                        reelPosition += loopWidth;
                    }
                    participantsReelEl.style.transform = `translateX(${reelPosition}px)`;

                    idleAnimationId = requestAnimationFrame(idleAnimate);
                }
                idleAnimationId = requestAnimationFrame(idleAnimate);
            }

            function stopReelIdleAnimation() {
                if (idleAnimationId) {
                    cancelAnimationFrame(idleAnimationId);
                    idleAnimationId = null;
                }
            }

            function startPointerLottery() {
                if (isReelSpinning) return;
                if (participants.length < 2) {
                    alert('需要至少兩位參與者才能開始抽獎！');
                    return;
                }
                stopReelIdleAnimation();
                isReelSpinning = true;
                // 給予一個隨機的初始速度 (像素/幀)，增加速度以獲得拉霸機的感覺
                reelVelocity = (Math.random() * 20) + 55;
                
                if (reelAnimationId) {
                    cancelAnimationFrame(reelAnimationId);
                }
                animateReel();
            }

            function animateReel() {
                reelPosition -= reelVelocity;
                reelVelocity *= REEL_FRICTION; // 應用摩擦力

                const cardWidth = 120 + 20;
                const totalReelWidth = cardWidth * participants.length * Math.floor(participantsReelEl.children.length / participants.length);
                const loopWidth = cardWidth * participants.length;

                // 為了循環效果，重置位置
                if(reelPosition < -loopWidth * 2) {
                    reelPosition += loopWidth;
                }

                participantsReelEl.style.transform = `translateX(${reelPosition}px)`;

                if (reelVelocity < 0.05) {
                    isReelSpinning = false;
                    cancelAnimationFrame(reelAnimationId);
                    reelAnimationId = null;
                    determinePointerWinner();
                } else {
                    reelAnimationId = requestAnimationFrame(animateReel);
                }
            }
            
            function determinePointerWinner() {
                const pointerLine = pointerAnimationEl.getBoundingClientRect().left + (pointerAnimationEl.offsetWidth / 2);
                const cards = participantsReelEl.querySelectorAll('.reel-participant-card');
                
                let winnerCard = null;
                let minDistance = Infinity;

                cards.forEach(card => {
                    const cardRect = card.getBoundingClientRect();
                    const cardCenter = cardRect.left + (cardRect.width / 2);
                    const distance = Math.abs(pointerLine - cardCenter);
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        winnerCard = card;
                    }
                });

                if (winnerCard) {
                    const winnerChannelId = winnerCard.dataset.channelId;
                    const winner = participants.find(p => p.channelId === winnerChannelId);
                    if(winner){
                        pointerWinnerDecided = true;
                        selectedWinner = winner;
                        highlightWinner(winner);
                        myConfetti({ particleCount: 150, spread: 90, origin: { y: 0.6 }});
                        
                        // 平滑地將中獎者卡片對齊到指針
                        const cardRect = winnerCard.getBoundingClientRect();
                        const cardCenter = cardRect.left + (cardRect.width / 2);
                        const offset = pointerLine - cardCenter;
                        
                        const currentTransform = new DOMMatrix(getComputedStyle(participantsReelEl).transform);
                        const currentX = currentTransform.m41;
                        
                        participantsReelEl.style.transition = 'transform 0.6s cubic-bezier(0.25, 1, 0.5, 1)';
                        participantsReelEl.style.transform = `translateX(${currentX + offset}px)`;

                        // 在中間顯示中獎者名字
                        const winnerDisplay = document.getElementById('pointer-winner-display');
                        if (winnerDisplay) {
                            winnerDisplay.textContent = winner.displayName;
                            winnerDisplay.style.display = 'block';
                        }
                        
                        // 更改按鈕文字，提示可以重設
                        const buttonText = drawWinnerBtn.querySelector('.text');
                        if (buttonText) buttonText.textContent = '重設/再抽一次';

                    } else {
                         startReelIdleAnimation();
                    }
                } else {
                    startReelIdleAnimation();
                }
            }

            function resetPointerAnimation() {
                pointerWinnerDecided = false;
                
                const winnerDisplay = document.getElementById('pointer-winner-display');
                if (winnerDisplay) {
                    winnerDisplay.style.display = 'none';
                }

                const buttonText = drawWinnerBtn.querySelector('.text');
                if (buttonText) buttonText.textContent = '立即抽獎';

                const participantsList = participantsListEl.querySelectorAll('li');
                participantsList.forEach(li => {
                    li.classList.remove('winner-highlight');
                });
                
                // 重設捲軸的 transform transition
                participantsReelEl.style.transition = 'none';

                startReelIdleAnimation();
            }

            async function fetchParticipants() {
                try {
                    const response = await fetch('/api/admin/lottery/participants');
                    const data = await response.json();
                    
                    if (!response.ok) {
                        throw new Error(data.error || '無法獲取參與者');
                    }
                    
                    if (data.participants) {
                        updateParticipantsList(data.participants);
                        if (data.participants.length === 0) {
                            if (defaultAnimation) {
                                defaultAnimation.textContent = '監控中...等待參與者加入';
                            }
                        }
                    } else {
                        throw new Error('參與者資料格式錯誤');
                    }
                } catch (error) {
                    console.error('Error fetching participants:', error);
                    if (defaultAnimation) {
                        defaultAnimation.textContent = '更新參與者名單失敗';
                    }
                }
            }

            function startAutoUpdate() {
                if (updateTimer) {
                    clearInterval(updateTimer);
                }
                
                fetchParticipants();
                
                const interval = parseInt(apiRateInput.value, 10) * 1000;
                updateTimer = setInterval(fetchParticipants, interval);

                // 更新狀態顯示
                toggleStatusEl.textContent = '系統狀態: 監控中';
                toggleStatusEl.style.color = '#50fa7b'; // 綠色
            }

            function stopAutoUpdate() {
                if (updateTimer) {
                    clearInterval(updateTimer);
                    updateTimer = null;
                }

                // 更新狀態顯示
                toggleStatusEl.textContent = '系統狀態: 停止中';
                toggleStatusEl.style.color = '#ff5555'; // 紅色
            }

            function updateParticipantsList(participantsData) {
                if (!participantsListEl || !participantsCountEl) return;

                participants = participantsData; // 更新全局參與者陣列
                participantsListEl.innerHTML = '';
                participantsCountEl.textContent = `目前參與人數：${participants.length} 人`;

                participants.forEach((participant, index) => {
                    const li = document.createElement('li');
                    li.className = 'participant';
                    // 將 channelId 存儲在 data 屬性中
                    li.dataset.channelId = participant.channelId;
                    li.innerHTML = `
                        <img src="${participant.profileImageUrl}" alt="${participant.displayName}" class="participant-avatar">
                        <span>${participant.displayName}</span>
                        <button class="delete-btn">刪除</button>
                    `;

                    // 點擊參與者列表項目時的處理
                    li.addEventListener('click', (e) => {
                        // 如果點擊的是刪除按鈕，不切換選中狀態
                        if (e.target.classList.contains('delete-btn')) {
                            return;
                        }
                        li.classList.toggle('selected');
                    });

                    // 刪除按鈕的點擊處理
                    const deleteBtn = li.querySelector('.delete-btn');
                    deleteBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        if (confirm(`確定要刪除參與者 "${participant.displayName}" 嗎？`)) {
                            try {
                                // 使用 data-channel-id 來獲取正確的 channelId
                                const channelId = li.dataset.channelId;
                                const response = await fetch('/api/admin/lottery/remove-participant', {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json'
                                    },
                                    body: JSON.stringify({ channelId })
                                });

                                const result = await response.json();
                                if (!response.ok) throw new Error(result.error || '刪除失敗');

                                // 刪除成功後，重新從伺服器獲取最新的參與者列表
                                // 這樣可以確保前後端狀態一致，並自動更新UI和轉盤
                                fetchParticipants();
                                alert(`參與者 "${participant.displayName}" 已成功刪除。`);
                            } catch (error) {
                                console.error('Error removing participant:', error);
                                alert(`刪除失敗: ${error.message}`);
                            }
                        }
                    });

                    participantsListEl.appendChild(li);
                });
                
                // 更新動畫視圖
                setupAnimationView(animationModeEl.value);
            }
            
            function setupAnimationView(mode) {
                if (participants.length === 0) {
                    wheelCanvas.style.display = 'none';
                    pointerAnimationEl.style.display = 'none';
                    punchHoleAnimationEl.style.display = 'none';
                    defaultAnimation.style.display = 'block';
                    defaultAnimation.textContent = '監控中...等待參與者加入';
                    stopReelIdleAnimation();
                    return;
                }
                
                defaultAnimation.style.display = 'none';

                if (mode === 'turntable') {
                    wheelCanvas.style.display = 'block';
                    pointerAnimationEl.style.display = 'none';
                    punchHoleAnimationEl.style.display = 'none';
                    stopReelIdleAnimation();
                    drawWheel();
                } else if (mode === 'pointer') {
                    wheelCanvas.style.display = 'none';
                    pointerAnimationEl.style.display = 'block';
                    punchHoleAnimationEl.style.display = 'none';
                    buildParticipantsReel();
                } else if (mode === 'punch-hole') {
                    wheelCanvas.style.display = 'none';
                    pointerAnimationEl.style.display = 'none';
                    punchHoleAnimationEl.style.display = 'block';
                    setupPunchHoleCards();
                } else {
                    // 未來其他模式的處理
                    wheelCanvas.style.display = 'none';
                    pointerAnimationEl.style.display = 'none';
                    punchHoleAnimationEl.style.display = 'none';
                    stopReelIdleAnimation();
                }
            }
            
            function setupPunchHoleCards() {
                if (!punchHoleAnimationEl) return;
                
                punchHoleAnimationEl.querySelectorAll('.punch-card').forEach(card => card.remove());
                punchHoleWinnerDisplayEl.textContent = '';
                punchHoleWinnerDisplayEl.classList.remove('show');
                
                if (participants.length === 0) {
                    return;
                }
                
                // 重置狀態
                punchHoleReady = true;
                punchHoleWinnerSelected = false;
                punchHoleWinner = null;
                isPunchHoleShuffled = false;
                
                // 將容器從絕對定位的排列改為網格排列
                punchHoleAnimationEl.style.display = 'grid';
                
                // 創建卡片 - 初始時正面朝上，排列成磚牆
                participants.forEach((participant, index) => {
                    const card = document.createElement('div');
                    card.className = 'punch-card';
                    card.dataset.channelId = participant.channelId;
                    card.dataset.index = index;
                    
                    card.innerHTML = `
                        <div class="punch-card-front">
                            <img src="${participant.profileImageUrl}" alt="${participant.displayName}">
                            <span>${participant.displayName}</span>
                        </div>
                        <div class="punch-card-back"></div>
                    `;
                    
                    punchHoleAnimationEl.appendChild(card);
                });
                
                // 更新按鈕文字和指示
                const buttonText = drawWinnerBtn.querySelector('.text');
                if (buttonText) buttonText.textContent = '打亂卡片';
                
                document.querySelector('.punch-instruction').textContent = '請點擊「打亂卡片」開始抽獎';
            }
            
            function shufflePunchHoleCards() {
                if (!punchHoleReady || punchHoleWinnerSelected || isPunchHoleShuffled) return;
                
                // 禁用按鈕防止重複點擊
                drawWinnerBtn.disabled = true;
                
                // 取得所有卡片
                const cards = punchHoleAnimationEl.querySelectorAll('.punch-card');
                const containerWidth = punchHoleAnimationEl.clientWidth;
                const containerHeight = punchHoleAnimationEl.clientHeight;
                
                // 改變容器為絕對定位布局
                punchHoleAnimationEl.style.display = 'block';
                
                // 隨機打亂卡片順序
                const cardsArray = Array.from(cards);
                const parentNode = punchHoleAnimationEl;
                
                // 先將所有卡片變為絕對定位，準備動畫
                cardsArray.forEach(card => {
                    // 記錄卡片當前位置
                    const rect = card.getBoundingClientRect();
                    const parentRect = parentNode.getBoundingClientRect();
                    
                    // 設置初始絕對位置，使其看起來沒有變化
                    card.style.position = 'absolute';
                    card.style.top = `${rect.top - parentRect.top}px`;
                    card.style.left = `${rect.left - parentRect.left}px`;
                    card.classList.add('shuffling');
                });
                
                // 第一階段：先翻面（背面朝上）
                // 使用更長的延遲確保翻面動畫完成
                setTimeout(() => {
                    cardsArray.forEach(card => {
                        card.classList.add('face-down');
                    });
                    
                    // 確保卡片完全翻到背面後再開始散開
                    setTimeout(() => {
                        // 第二階段：散開卡片
                        cardsArray.forEach(card => {
                            // 確保卡片仍然是背面朝上
                            if (!card.classList.contains('face-down')) {
                                card.classList.add('face-down');
                            }
                            
                            // 隨機散開到容器四周
                            const randomAngle = Math.random() * 360;
                            const distance = 100 + Math.random() * 200; // 散開的距離
                            const centerX = containerWidth / 2;
                            const centerY = containerHeight / 2;
                            
                            // 計算目標位置
                            const radians = randomAngle * (Math.PI / 180);
                            const targetX = centerX + Math.cos(radians) * distance - 60; // 60是卡片寬度的一半
                            const targetY = centerY + Math.sin(radians) * distance - 75; // 75是卡片高度的一半
                            
                            // 設置旋轉和位置，保持背面朝上
                            card.style.transform = `translate(${targetX - card.offsetLeft}px, ${targetY - card.offsetTop}px) rotate(${Math.random() * 40 - 20}deg) rotateY(180deg)`;
                        });
                        
                        // 第三階段：重新排列成網格
                        setTimeout(() => {
                            // 重新排列之前，先打亂順序
                            for (let i = cardsArray.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [cardsArray[i], cardsArray[j]] = [cardsArray[j], cardsArray[i]];
                            }
                            
                            // 計算網格排列
                            const cardWidth = 130; // 包含margin
                            const cardHeight = 160; // 包含margin
                            const cardsPerRow = Math.floor(containerWidth / cardWidth);
                            
                            // 排列到網格位置
                            cardsArray.forEach((card, index) => {
                                const row = Math.floor(index / cardsPerRow);
                                const col = index % cardsPerRow;
                                
                                const left = (col * cardWidth) + (containerWidth - cardsPerRow * cardWidth) / 2;
                                const top = (row * cardHeight) + 20; // 頂部留出20px空間
                                
                                // 保持卡片背面朝上，但位置和旋轉角度恢復正常
                                card.style.transform = `translate(${left - card.offsetLeft}px, ${top - card.offsetTop}px) rotate(0deg) rotateY(180deg)`;
                            });
                            
                            // 為所有卡片添加點擊事件，確保每張卡片仍然為翻面狀態
                            setTimeout(() => {
                                cardsArray.forEach(card => {
                                    // 確保卡片仍然是背面朝上
                                    if (!card.classList.contains('face-down')) {
                                        card.classList.add('face-down');
                                    }
                                    card.addEventListener('click', handlePunchCardClick);
                                });
                                
                                // 更新狀態和提示
                                isPunchHoleShuffled = true;
                                document.querySelector('.punch-instruction').textContent = '請選擇一張卡片揭曉中獎者';
                                
                                // 更新按鈕文字
                                const buttonText = drawWinnerBtn.querySelector('.text');
                                if (buttonText) buttonText.textContent = '重新發牌';
                                
                                // 重新啟用按鈕
                                drawWinnerBtn.disabled = false;
                            }, 800);
                        }, 1200);
                    }, 200); // 添加小延遲確保翻面完成
                }, 50);
            }
            
            function handlePunchCardClick(e) {
                if (!punchHoleReady || punchHoleWinnerSelected || !isPunchHoleShuffled) return;
                
                const card = e.currentTarget;
                if (card.classList.contains('selected')) return;
                
                // 選擇了這張卡片作為中獎者
                card.classList.add('selected');
                card.classList.remove('face-down');
                
                punchHoleWinnerSelected = true;
                
                // 獲取中獎者資訊
                const channelId = card.dataset.channelId;
                const winner = participants.find(p => p.channelId === channelId);
                
                if (winner) {
                    punchHoleWinner = winner;
                    selectedWinner = winner;
                    highlightWinner(winner);
                    
                    // 標記卡片為中獎
                    card.classList.add('winner');
                    
                    // 顯示中獎提示
                    punchHoleWinnerDisplayEl.textContent = `🎉 恭喜 ${winner.displayName} 中獎！`;
                    punchHoleWinnerDisplayEl.classList.add('show');
                    
                    // 更新指示文字
                    document.querySelector('.punch-instruction').textContent = '已選出中獎者，點擊「重新發牌」開始新一輪抽獎';
                    
                    // 播放慶祝特效
                    myConfetti({
                        particleCount: 150,
                        spread: 90,
                        origin: { y: 0.6 }
                    });
                }
                
                // 防止繼續點擊其他卡片
                punchHoleAnimationEl.querySelectorAll('.punch-card:not(.selected)').forEach(otherCard => {
                    otherCard.removeEventListener('click', handlePunchCardClick);
                    otherCard.style.opacity = '0.5';
                    otherCard.style.cursor = 'default';
                });
            }
            
            function resetPunchHoleAnimation() {
                punchHoleReady = false;
                punchHoleWinnerSelected = false;
                punchHoleWinner = null;
                isPunchHoleShuffled = false;
                
                // 清除高亮
                const participantsList = participantsListEl.querySelectorAll('li');
                participantsList.forEach(li => {
                    li.classList.remove('winner-highlight');
                });
                
                // 重新設置
                setupPunchHoleCards();
            }

            function showTemporaryAnimation(participants, callback) {
                animationContainer.style.display = 'block';
                winnerDisplayEl.style.display = 'none';
                
                if (participants.length === 0) {
                    animationContainer.textContent = '沒有參與者!';
                    return;
                }
                
                let animationInterval = setInterval(() => {
                    const randomParticipant = participants[Math.floor(Math.random() * participants.length)];
                    animationContainer.innerHTML = `
                        <img src="${randomParticipant.profileImageUrl}" style="width: 80px; height: 80px; border-radius: 50%; margin-right: 20px;">
                        <span>${randomParticipant.displayName}</span>
                    `;
                }, 100);

                setTimeout(() => {
                    clearInterval(animationInterval);
                    callback();
                }, 5000);
            }

            function showWinner(winner) {
                const winnerDisplay = document.getElementById('winner-display');
                const winnerAvatar = document.getElementById('winner-avatar');
                const winnerName = document.getElementById('winner-name');
                
                winnerAvatar.src = winner.profileImageUrl;
                winnerName.textContent = winner.displayName;
                winnerDisplay.classList.add('show');

                const closeBtn = winnerDisplay.querySelector('.close-winner');
                if (closeBtn) {
                    closeBtn.onclick = () => {
                        winnerDisplay.classList.remove('show');
                    };
                }

                setTimeout(() => {
                    winnerDisplay.classList.remove('show');
                }, 10000); // 延長顯示時間
            }

            drawWinnerBtn.addEventListener('click', async () => {
                const animationMode = animationModeEl.value;
                
                if (animationMode === 'turntable') {
                    startSpin();
                } else if (animationMode === 'pointer') {
                    if (pointerWinnerDecided) {
                        resetPointerAnimation();
                    } else {
                        startPointerLottery();
                    }
                } else if (animationMode === 'punch-hole') {
                    // 洞洞樂模式
                    if (isPunchHoleShuffled) {
                        // 如果已經打亂，就重新發牌
                        resetPunchHoleAnimation();
                    } else {
                        // 如果還沒打亂，就打亂卡片
                        shufflePunchHoleCards();
                    }
                } else {
                    // 對於其他模式，維持原樣，先從後端獲取結果
                    try {
                        const response = await fetch('/api/admin/lottery/draw', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ 
                                animationMode,
                                duration: 0 
                            })
                        });

                        const result = await response.json();
                        if (!response.ok) throw new Error(result.error || '抽獎失敗');
                        if (!result.winner) throw new Error('未能獲取中獎者資訊');

                        const winner = result.winner;
                        selectedWinner = winner;
                        highlightWinner(winner);
                        showWinner(winner);
                        myConfetti({ particleCount: 150, spread: 90, origin: { y: 0.6 }});
                    } catch (error) {
                        console.error('抽獎出錯:', error);
                        alert(`抽獎失敗: ${error.message}`);
                    }
                }
            });
            
            refreshParticipantsBtn.addEventListener('click', fetchParticipants);
            
            animationModeEl.addEventListener('change', () => {
                if(isReelSpinning || isSpinning) {
                    alert('請等待目前抽獎動畫結束！');
                    animationModeEl.value = isSpinning ? 'turntable' : 'pointer';
                    return;
                }
                if (pointerWinnerDecided) {
                    alert('請先重設指針抽獎，才能切換模式！');
                    animationModeEl.value = 'pointer';
                    return;
                }
                if (punchHoleWinnerSelected) {
                    alert('請先重新發牌，才能切換模式！');
                    animationModeEl.value = 'punch-hole';
                    return;
                }
                setupAnimationView(animationModeEl.value);
            });

            // 監控開關的事件處理
            monitoringToggle.addEventListener('change', async function() {
                if (this.checked) {
                    // 開始監控
                    const videoId = videoIdEl.value.trim();
                    const keyword = keywordEl.value.trim();
                    const apiRateLimit = parseInt(apiRateInput.value, 10);

                    if (!videoId || !keyword) {
                        alert('請填寫 Video ID 和關鍵字！');
                        this.checked = false;
                        return;
                    }

                    try {
                        const response = await fetch('/api/admin/lottery/set-video', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                videoId,
                                keyword,
                                apiRateLimit
                            })
                        });

                        const result = await response.json();
                        if (!response.ok) throw new Error(result.error || '設置失敗');

                        currentVideoEl.textContent = `當前監控 Video ID: ${videoId}`;
                        startAutoUpdate();
                    } catch (error) {
                        console.error('Error setting video:', error);
                        alert(`設置失敗: ${error.message}`);
                        this.checked = false;
                    }
                } else {
                    // 停止監控
                    try {
                        const response = await fetch('/api/admin/lottery/stop-monitoring', {
                            method: 'POST'
                        });
                        const result = await response.json();
                        
                        if (response.ok && result.success) {
                            stopAutoUpdate();
                            currentVideoEl.textContent = '當前監控 Video ID: 無';
                            defaultAnimation.textContent = '已停止監控';
                        } else {
                            throw new Error(result.error || '停止監控失敗');
                        }
                    } catch (error) {
                        console.error('Error stopping monitoring:', error);
                        alert(`停止監控失敗: ${error.message}`);
                        this.checked = true;
                    }
                }
            });

            // Initial setup
            setupAnimationView(animationModeEl.value);
        });
    </script>
</body>
</html> 