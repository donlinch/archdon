<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube 直播抽獎管理後台</title>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
    <style>
        :root {
            --bg-color: #1a1a2e;
            --primary-color: #16213e;
            --secondary-color: #0f3460;
            --accent-color: #e94560;
            --text-color: #dcdcdc;
            --font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --border-radius: 8px;
        }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            display: grid;
            grid-template-columns: 280px 1fr 350px;
            grid-template-rows: auto 1fr auto;
            grid-template-areas:
                "header header header"
                "settings-panel animation-panel participants-panel"
                "footer footer footer";
            gap: 20px;
            width: 100%;
            max-width: 1600px;
            height: 90vh;
        }

        .panel {
            background-color: var(--primary-color);
            border-radius: var(--border-radius);
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
        }

        h1, h2 {
            color: var(--accent-color);
            text-align: center;
            margin-top: 0;
        }

        #header { grid-area: header; text-align: center; padding-bottom: 10px; }
        #settings-panel { grid-area: settings-panel; }
        #animation-panel { grid-area: animation-panel; justify-content: center; align-items: center; position: relative; overflow: hidden; }
        #participants-panel { grid-area: participants-panel; }
        #footer { grid-area: footer; }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        input[type="text"], input[type="number"], select {
            width: 100%;
            padding: 10px;
            background-color: var(--bg-color);
            border: 1px solid var(--secondary-color);
            border-radius: 5px;
            color: var(--text-color);
            box-sizing: border-box;
        }

        button {
            width: 100%;
            padding: 12px;
            background-color: var(--accent-color);
            border: none;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        button:hover {
            background-color: #f06a81;
        }
        
        button.secondary {
             background-color: var(--secondary-color);
        }
        button.secondary:hover {
            background-color: #1a4a8a;
        }


        #participants-list {
            flex-grow: 1;
            overflow-y: auto;
            padding-right: 10px;
        }

        .participant {
            display: flex;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid var(--secondary-color);
            cursor: pointer;
            position: relative;
        }
        
        .participant:hover {
            background-color: var(--secondary-color);
        }

        .participant.selected {
            background-color: rgba(233, 69, 96, 0.2);
        }

        .participant .delete-btn {
            position: absolute;
            right: 10px;
            padding: 5px 10px;
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            display: none;
        }

        .participant.selected .delete-btn {
            display: block;
        }

        .participant .delete-btn:hover {
            background-color: #d63031;
        }

        .participant img {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            margin-right: 12px;
        }
        
        #participants-count {
            margin-top: 15px;
            text-align: center;
            font-size: 1.2em;
        }
        
        #status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--secondary-color);
            padding: 10px 20px;
            border-radius: var(--border-radius);
            margin-top: 10px;
        }
        
        #ws-status {
            font-weight: bold;
        }
        .status-connected { color: #50fa7b; }
        .status-disconnected { color: #ff5555; }

        /* --- User Status Indicator (adapted for dark theme) --- */
        .user-status {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1001;
            display: flex;
            align-items: center;
            background-color: rgba(30, 41, 59, 0.9); /* A slightly lighter shade from the theme */
            padding: 5px 10px;
            border-radius: 20px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
            cursor: pointer;
            border: 1px solid var(--secondary-color);
        }

        .user-status:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            background-color: var(--secondary-color);
        }

        .user-status img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid var(--accent-color);
            object-fit: cover;
        }

        .user-status .username {
            margin-left: 8px;
            font-weight: 600;
            color: var(--text-color);
            max-width: 120px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        @media (max-width: 767px) {
            .user-status {
                padding: 3px;
            }
            
            .user-status .username {
                display: none;
            }
        }

        /* Animation Styles */
        #winner-display {
            display: none !important; /* 根據要求，不再使用彈出式卡片 */
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background: rgba(255, 255, 255, 0.95);
            padding: 20px 40px;
            border-radius: 10px;
            box-shadow: 0 5px 25px rgba(0,0,0,0.3);
            text-align: center;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: none;
        }

        #winner-display.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            pointer-events: auto;
        }

        #winner-display img {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            margin-bottom: 10px;
        }

        #winner-display h2 {
            margin: 10px 0;
            color: #ff4757;
        }

        #winner-display h3 {
            font-size: 1.5em;
            color: #333;
        }

        .close-winner {
            position: absolute;
            top: 10px;
            right: 10px;
            cursor: pointer;
            font-size: 20px;
            color: #666;
        }

        #confetti-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #draw-animation-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2em;
        }

        @keyframes fadeIn {
          from { opacity: 0; transform: scale(0.8); }
          to { opacity: 1; transform: scale(1); }
        }

        #animation-container {
            width: 100%;
            height: 500px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
        }

        #wheel-canvas {
            margin: 0 auto;
            display: block;
            background: white;
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }

        #pointer-animation {
            width: 100%;
            height: 150px;
            position: relative;
            overflow: hidden;
            border: 2px solid var(--secondary-color);
            border-radius: var(--border-radius);
            background: var(--bg-color);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #pointer-winner-display {
            position: absolute;
            color: white;
            font-size: 3em;
            font-weight: bold;
            text-shadow: 0 0 15px var(--accent-color), 0 0 10px rgba(0,0,0,0.8);
            z-index: 5;
            text-align: center;
            animation: fadeIn 0.5s ease;
        }

        #pointer {
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-top: 20px solid var(--accent-color);
            z-index: 3;
            filter: drop-shadow(0px 2px 3px rgba(0,0,0,0.5));
        }

        #participants-reel {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            display: flex;
            will-change: transform;
        }

        .reel-participant-card {
            width: 120px;
            height: 120px;
            margin: 15px 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: var(--secondary-color);
            border-radius: var(--border-radius);
            text-align: center;
            flex-shrink: 0;
            padding: 5px;
            box-sizing: border-box;
            color: var(--text-color);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .reel-participant-card img {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin-bottom: 8px;
        }

        .reel-participant-card span {
            font-size: 0.9em;
            font-weight: bold;
            word-break: break-all;
        }

        #default-animation {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        #participants-list {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 400px;
            overflow-y: auto;
        }

        #participants-list li {
            display: flex;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .participant-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .winner-highlight {
            color: #ff4757;
            font-weight: bold;
            font-size: 1.2em;
            text-shadow: 0 0 5px rgba(255,71,87,0.3);
            background: rgba(255,71,87,0.1);
        }

        /* Remove animation duration input */
        #animation-duration {
            display: none;
        }

        /* Animated Button from Uiverse.io by gharsh11032000 - Adapted for this project */
        .animated-button {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 16px 36px;
            border: 2px solid var(--accent-color);
            border-radius: 100px;
            font-weight: 600;
            color: var(--accent-color);
            background-color: transparent;
            cursor: pointer;
            overflow: hidden;
            transition: all 0.6s cubic-bezier(0.23, 1, 0.32, 1);
            width: 100%;
            box-sizing: border-box;
            margin-top: 10px;
        }

        .animated-button svg {
            position: absolute;
            width: 24px;
            fill: var(--accent-color);
            z-index: 9;
            transition: all 0.8s cubic-bezier(0.23, 1, 0.32, 1);
        }

        .animated-button .arr-1 {
            right: 16px;
        }

        .animated-button .arr-2 {
            left: -25%;
        }

        .animated-button .circle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            background-color: var(--accent-color);
            border-radius: 50%;
            opacity: 0;
            transition: all 0.8s cubic-bezier(0.23, 1, 0.32, 1);
        }

        .animated-button .text {
            position: relative;
            z-index: 1;
            transform: translateX(0px); /* Adjusted for better centering */
            transition: all 0.8s cubic-bezier(0.23, 1, 0.32, 1);
        }

        .animated-button:hover {
            box-shadow: 0 0 0 4px rgba(0, 0, 0, 0.2);
            color: var(--bg-color);
            border-radius: 12px;
        }

        .animated-button:hover .arr-1 {
            right: -25%;
        }

        .animated-button:hover .arr-2 {
            left: 16px;
        }

        .animated-button:hover .text {
            transform: translateX(0px); /* Adjusted for better centering */
        }

        .animated-button:hover svg {
            fill: var(--bg-color);
        }

        .animated-button:active {
            scale: 0.95;
            box-shadow: 0 0 0 4px var(--accent-color);
        }

        .animated-button:hover .circle {
            width: 220px;
            height: 220px;
            opacity: 1;
        }

        /* Punch-hole (洞洞樂) animation styles */
        #punch-hole-animation {
            width: 100%;
            height: 500px;
            position: relative;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 15px;
            padding: 20px;
            box-sizing: border-box;
            perspective: 1000px;
            overflow: hidden;
        }

        .punch-card {
            width: 120px;
            height: 150px;
            position: relative;
            transition: all 0.6s ease;
            transform-style: preserve-3d;
            cursor: pointer;
            margin: 5px;
            justify-self: center;
        }

        .punch-card.shuffling {
            position: absolute;
            transition: all 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .punch-card.face-down {
            transform: rotateY(180deg);
        }

        .punch-card.selected {
            transform: rotateY(0deg) !important;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            cursor: default;
            z-index: 10;
            transition: all 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .punch-card.winner {
            box-shadow: 0 0 25px gold;
            animation: winner-pulse 1s infinite alternate;
            transform: rotateY(0deg) scale(1.5) !important;
            z-index: 20;
        }

        .punch-card-front, .punch-card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .punch-card-front {
            background: var(--accent-color);
            padding: 10px;
            text-align: center;
            transform: rotateY(0deg);
        }

        .punch-card-back {
            background: linear-gradient(135deg, var(--secondary-color), var(--primary-color));
            border: 2px solid var(--accent-color);
            transform: rotateY(180deg);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        .punch-card-front img {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid white;
            margin-bottom: 8px;
        }

        .punch-card-front span {
            font-size: 14px;
            font-weight: bold;
            color: white;
            word-break: break-word;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }

        .punch-card-back::before {
            content: "";
            background-image: url('/images/android-chrome-192x192.png');
            background-size: 80px 80px;
            background-position: center;
            background-repeat: no-repeat;
            width: 100%;
            height: 100%;
            display: block;
            position: absolute;
            z-index: 1;
            opacity: 0.4; /* 調暗Logo，讓數字更清晰 */
        }

        .card-number {
            position: relative;
            z-index: 2;
            font-size: 3.5em;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 0 12px rgba(0, 0, 0, 0.75);
            opacity: 0;
            transform: scale(0.5);
            transition: opacity 0.4s ease-out, transform 0.4s ease-out;
        }

        .punch-card.face-down .card-number {
            opacity: 1;
            transform: scale(1);
            transition-delay: 0.4s; /* 延遲出現，等待翻牌動畫 */
        }

        @keyframes winner-pulse {
            from { box-shadow: 0 0 15px rgba(255, 215, 0, 0.5); }
            to { box-shadow: 0 0 25px rgba(255, 215, 0, 0.8); }
        }

        #punch-hole-winner-display {
            position: absolute;
            top: 10px;
            left: 0;
            right: 0;
            text-align: center;
            color: white;
            font-size: 2em;
            font-weight: bold;
            text-shadow: 0 0 10px var(--accent-color);
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.5s ease;
            z-index: 10;
        }

        #punch-hole-winner-display.show {
            opacity: 1;
            transform: translateY(0);
        }

        .punch-instruction {
            position: absolute;
            bottom: 10px;
            left: 0;
            right: 0;
            text-align: center;
            color: var(--text-color);
            font-size: 1.2em;
            opacity: 0.8;
        }

        /* Toggle Switch from Uiverse.io by teymr */
        #checkbox {
            display: none;
        }

        .switch {
            position: relative;
            width: 70px;
            height: 70px;
            background-color: rgb(99, 99, 99);
            border-radius: 50%;
            z-index: 1;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid rgb(126, 126, 126);
            box-shadow: 0px 0px 3px rgb(2, 2, 2) inset;
            transition: 0.5s;
        }

        .switch svg {
            width: 1.2em;
        }

        .switch svg path {
            fill: rgb(48, 48, 48);
        }

        #checkbox:checked + .switch {
            box-shadow:
                0px 0px 1px rgb(151, 243, 255) inset,
                0px 0px 2px rgb(151, 243, 255) inset,
                0px 0px 10px rgb(151, 243, 255) inset,
                0px 0px 40px rgb(151, 243, 255),
                0px 0px 100px rgb(151, 243, 255),
                0px 0px 5px rgb(151, 243, 255);
            border: 2px solid rgb(255, 255, 255);
            background-color: rgb(146, 180, 184);
        }

        #checkbox:checked + .switch svg {
            filter: drop-shadow(0px 0px 5px rgb(151, 243, 255));
        }

        #checkbox:checked + .switch svg path {
            fill: rgb(255, 255, 255);
        }

        #checkbox:active + .switch {
            transform: translate(0em, 0.1em);
            box-shadow:
                0px 0px 0.1px rgb(151, 243, 255) inset,
                0px 0px 0.2px rgb(151, 243, 255) inset,
                0px 0px 1px rgb(151, 243, 255) inset,
                0px 0px 10px rgb(151, 243, 255),
                0px 0px 50px rgb(151, 243, 255);
            border: 2px solid rgb(255, 255, 255);
            background-color: rgb(146, 180, 184);
        }

        #checkbox:active + .switch svg path {
            box-shadow: 0.2em 0.2em 0.3em rgba(0, 0, 0, 0.3);
            transform: translate(0em, 0.1em);
        }

        .toggle-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px 0;
        }

        .toggle-label {
            margin-top: 10px;
            font-size: 0.9em;
            color: var(--text-color);
            text-align: center;
        }

        .toggle-status {
            margin-bottom: 10px;
            font-weight: bold;
            color: var(--accent-color);
        }

        #loading-overlay {
            display: flex;
            position: fixed;
            left: 0; top: 0;
            width: 100%; height: 100%;
            background-color: rgba(26, 26, 46, 0.95); /* from --bg-color */
            z-index: 9999;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 20px;
        }
        #loading-overlay::before {
            content: '';
            width: 60px;
            height: 60px;
            border: 3px solid var(--secondary-color);
            border-top-color: var(--accent-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        #loading-overlay p {
            font-size: 1.2em;
            color: var(--text-color);
            font-weight: 500;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* From Uiverse.io by Botwe-Felix5820 - Adapted */
        .history-button {
            height: 2.8em;
            width: auto;
            padding: 0 1.2em;
            background: transparent;
            -webkit-animation: jello-horizontal 0.9s both;
            animation: jello-horizontal 0.9s both;
            border: 2px solid #016dd9;
            outline: none;
            color: #016dd9;
            cursor: pointer;
            font-size: 17px;
            font-weight: normal; /* Override general button style */
            border-radius: 0; /* Override general button style */
            align-self: flex-start; /* Align to the start of the panel */
            margin-right: 10px; /* Add margin to separate buttons */
        }

        .history-button:hover {
            background: #016dd9;
            color: #ffffff;
            animation: squeeze3124 0.9s both;
        }
        
        .game-button {
            height: 2.8em;
            width: auto;
            padding: 0 1.2em;
            background: transparent;
            -webkit-animation: jello-horizontal 0.9s both;
            animation: jello-horizontal 0.9s both;
            border: 2px solid #e67e22;
            outline: none;
            color: #e67e22;
            cursor: pointer;
            font-size: 17px;
            font-weight: normal;
            border-radius: 0;
            align-self: flex-start;
        }
        
        .game-button:hover {
            background: #e67e22;
            color: #ffffff;
            animation: squeeze3124 0.9s both;
        }

        .button-container {
            display: flex;
            margin-bottom: 10px;
        }

        @-webkit-keyframes jello-horizontal {
            0% { -webkit-transform: scale3d(1, 1, 1); transform: scale3d(1, 1, 1); }
            30% { -webkit-transform: scale3d(1.25, 0.75, 1); transform: scale3d(1.25, 0.75, 1); }
            40% { -webkit-transform: scale3d(0.75, 1.25, 1); transform: scale3d(0.75, 1.25, 1); }
            50% { -webkit-transform: scale3d(1.15, 0.85, 1); transform: scale3d(1.15, 0.85, 1); }
            65% { -webkit-transform: scale3d(0.95, 1.05, 1); transform: scale3d(0.95, 1.05, 1); }
            75% { -webkit-transform: scale3d(1.05, 0.95, 1); transform: scale3d(1.05, 0.95, 1); }
            100% { -webkit-transform: scale3d(1, 1, 1); transform: scale3d(1, 1, 1); }
        }

        @keyframes jello-horizontal {
            0% { -webkit-transform: scale3d(1, 1, 1); transform: scale3d(1, 1, 1); }
            30% { -webkit-transform: scale3d(1.25, 0.75, 1); transform: scale3d(1.25, 0.75, 1); }
            40% { -webkit-transform: scale3d(0.75, 1.25, 1); transform: scale3d(0.75, 1.25, 1); }
            50% { -webkit-transform: scale3d(1.15, 0.85, 1); transform: scale3d(1.15, 0.85, 1); }
            65% { -webkit-transform: scale3d(0.95, 1.05, 1); transform: scale3d(0.95, 1.05, 1); }
            75% { -webkit-transform: scale3d(1.05, 0.95, 1); transform: scale3d(1.05, 0.95, 1); }
            100% { -webkit-transform: scale3d(1, 1, 1); transform: scale3d(1, 1, 1); }
        }

        @keyframes squeeze3124 {
            0% {
                -webkit-transform: scale3d(1, 1, 1);
                transform: scale3d(1, 1, 1);
            }

            30% {
                -webkit-transform: scale3d(1.25, 0.75, 1);
                transform: scale3d(1.25, 0.75, 1);
            }

            40% {
                -webkit-transform: scale3d(0.75, 1.25, 1);
                transform: scale3d(0.75, 1.25, 1);
            }

            50% {
                -webkit-transform: scale3d(1.15, 0.85, 1);
                transform: scale3d(1.15, 0.85, 1);
            }

            65% {
                -webkit-transform: scale3d(0.95, 1.05, 1);
                transform: scale3d(0.95, 1.05, 1);
            }

            75% {
                -webkit-transform: scale3d(1.05, 0.95, 1);
                transform: scale3d(1.05, 0.95, 1);
            }

            100% {
                -webkit-transform: scale3d(1, 1, 1);
                transform: scale3d(1, 1, 1);
            }
        }

        /* Mode Switch - 直播/影片切換 */
        .mode-switch {
          --_switch-bg-clr: #70a9c5;
          --_switch-padding: 4px; /* padding around button*/
          --_slider-bg-clr: rgba(12, 74, 110, 0.65); /* slider color unchecked */
          --_slider-bg-clr-on: rgba(12, 74, 110, 1); /* slider color checked */
          --_slider-txt-clr: #ffffff;
          --_label-padding: 0.5rem 1rem; /* padding around the labels -  this gives the switch it's global width and height */
          --_switch-easing: cubic-bezier(
            0.47,
            1.64,
            0.41,
            0.8
          ); /* easing on toggle switch */
          color: white;
          width: fit-content;
          display: flex;
          justify-content: center;
          position: relative;
          border-radius: 9999px;
          cursor: pointer;
          display: grid;
          grid-template-columns: repeat(2, minmax(0, 1fr));
          position: relative;
          isolation: isolate;
          margin: 10px auto;
        }

        .mode-switch input[type="checkbox"] {
          position: absolute;
          width: 1px;
          height: 1px;
          padding: 0;
          margin: -1px;
          overflow: hidden;
          clip: rect(0, 0, 0, 0);
          white-space: nowrap;
          border-width: 0;
        }
        .mode-switch > span {
          display: grid;
          place-content: center;
          transition: opacity 300ms ease-in-out 150ms;
          padding: var(--_label-padding);
          font-size: 0.9em;
        }
        .mode-switch::before,
        .mode-switch::after {
          content: "";
          position: absolute;
          border-radius: inherit;
          transition: inset 150ms ease-in-out;
        }
        /* switch slider */
        .mode-switch::before {
          background-color: var(--_slider-bg-clr);
          inset: var(--_switch-padding) 50% var(--_switch-padding)
            var(--_switch-padding);
          transition:
            inset 500ms var(--_switch-easing),
            background-color 500ms ease-in-out;
          z-index: -1;
          box-shadow:
            inset 0 1px 1px rgba(0, 0, 0, 0.3),
            0 1px rgba(255, 255, 255, 0.3);
        }
        /* switch bg color */
        .mode-switch::after {
          background-color: var(--_switch-bg-clr);
          inset: 0;
          z-index: -2;
        }
        /* switch hover & focus */
        .mode-switch:focus-within::after {
          inset: -0.25rem;
        }
        .mode-switch:has(input:checked):hover > span:first-of-type,
        .mode-switch:has(input:not(:checked)):hover > span:last-of-type {
          opacity: 1;
          transition-delay: 0ms;
          transition-duration: 100ms;
        }
        /* switch hover */
        .mode-switch:has(input:checked):hover::before {
          inset: var(--_switch-padding) var(--_switch-padding) var(--_switch-padding)
            45%;
        }
        .mode-switch:has(input:not(:checked)):hover::before {
          inset: var(--_switch-padding) 45% var(--_switch-padding)
            var(--_switch-padding);
        }
        /* checked - move slider to right */
        .mode-switch:has(input:checked)::before {
          background-color: var(--_slider-bg-clr-on);
          inset: var(--_switch-padding) var(--_switch-padding) var(--_switch-padding)
            50%;
        }
        /* checked - set opacity */
        .mode-switch > span:last-of-type,
        .mode-switch > input:checked + span:first-of-type {
          opacity: 0.75;
        }
        .mode-switch > input:checked ~ span:last-of-type {
          opacity: 1;
        }
    </style>
</head>
<body>
    <div id="loading-overlay">
        <p>正在驗證您的身份...</p>
    </div>

    <!-- User Status Indicator -->
    <div id="userStatus" class="user-status" style="display: none;">
        <img id="userStatusAvatar" src="/images/a01girlmove.gif" alt="User">
        <span id="userStatusName" class="username">未登入</span>
    </div>

   

    <div class="container" style="display: none;">
        <div id="settings-panel" class="panel">
            
            <div class="form-group">
                <label for="video-id">YouTube Video ID <span id="monitoring-video-id" style="font-weight: normal; font-size: 0.9em; color: var(--accent-color);"></span></label>
                <input type="text" id="video-id" placeholder="例如：dQw4w9WgXcQ">
            </div>
            <div class="form-group">
                <label for="lottery-keyword">抽獎關鍵字</label>
                <input type="text" id="lottery-keyword" placeholder="例如：我要抽獎">
            </div>
            <div class="form-group">
                <label for="api-rate-limit">API 請求間隔 (秒)</label>
                <select id="api-rate-limit">
                    <option value="5">5秒</option>
                    <option value="10" selected>10秒</option>
                    <option value="20">20秒</option>
                </select>
            </div>
            <div class="toggle-container">
                <div class="toggle-status"> </div>
                <input type="checkbox" id="checkbox">
                <label class="switch" for="checkbox">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">
                        <path d="M288 256C288 273.7 273.7 288 256 288C238.3 288 224 273.7 224 256C224 238.3 238.3 224 256 224C273.7 224 288 238.3 288 256zM0 256C0 114.6 114.6 0 256 0C397.4 0 512 114.6 512 256C512 397.4 397.4 512 256 512C114.6 512 0 397.4 0 256zM256 464C370.9 464 464 370.9 464 256C464 141.1 370.9 48 256 48C141.1 48 48 141.1 48 256C48 370.9 141.1 464 256 464z"></path>
                    </svg>
                </label>
                
                <!-- 直播/影片模式切換 -->
                <div class="mode-switch-container" style="margin-top: 15px;">
                    <div style="text-align: center; margin-bottom: 5px; font-size: 0.9em;">選擇模式:</div>
                    <label class="mode-switch">
                        <input type="checkbox" id="mode-toggle">
                        <span>直播</span>
                        <span>影片</span>
                    </label>
                </div>
            </div>
            <hr style="border-color: var(--secondary-color); margin: 20px 0;">
           
            <div class="form-group">
                <label for="animation-mode">抽獎動畫</label>
                 <select id="animation-mode">
                    <option value="turntable" selected>轉盤式</option>
                    <option value="pointer">指針式</option>
                    <option value="punch-hole">洞洞樂</option>
                </select>
            </div>
            <div class="form-group">
                <label for="animation-duration">動畫時長 (分鐘)</label>
                <input type="number" id="animation-duration" value="0" min="0">
            </div>
             <button id="draw-winner-btn" class="animated-button">
                <svg viewBox="0 0 24 24" class="arr-2" xmlns="http://www.w3.org/2000/svg">
                    <path d="M16.1716 10.9999L10.8076 5.63589L12.2218 4.22168L20 11.9999L12.2218 19.778L10.8076 18.3638L16.1716 12.9999H4V10.9999H16.1716Z"></path>
                </svg>
                <span class="text">立即抽獎</span>
                <span class="circle"></span>
                <svg viewBox="0 0 24 24" class="arr-1" xmlns="http://www.w3.org/2000/svg">
                    <path d="M16.1716 10.9999L10.8076 5.63589L12.2218 4.22168L20 11.9999L12.2218 19.778L10.8076 18.3638L16.1716 12.9999H4V10.9999H16.1716Z"></path>
                </svg>
            </button>
        </div>

        <div id="animation-panel" class="panel">
            <canvas id="confetti-canvas"></canvas>
            <div id="animation-container">
                <canvas id="wheel-canvas" width="500" height="500" style="display: none;"></canvas>
                <div id="pointer-animation" style="display: none;">
                    <div id="pointer-winner-display" style="display: none;"></div>
                    <div id="pointer"></div>
                    <div id="participants-reel"></div>
                </div>
                <div id="punch-hole-animation" style="display: none;">
                    <div id="punch-hole-winner-display"></div>
                    <div class="punch-instruction">請點擊「打亂卡片」開始抽獎</div>
                </div>
                <div id="default-animation" style="text-align: center; padding: 20px;">
                    請先設定直播並開始監控
                </div>
            </div>
            <div id="winner-display">
                <span class="close-winner">&times;</span>
                <img id="winner-avatar" alt="Winner Avatar">
                <h2>🎉 恭喜中獎 🎉</h2>
                <h3 id="winner-name"></h3>
            </div>
        </div>

        <div id="participants-panel" class="panel">
           
            <div class="button-container">
                <button id="view-history-btn" class="history-button">查看抽獎紀錄</button>
                <button id="back-to-game-btn" class="game-button">返回遊戲</button>
            </div>
            <div id="participants-list">
                <!-- Participants will be dynamically added here -->
            </div>
            <div id="participants-count">
                目前參與人數：0 人
            </div>
        </div>

        

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const loadingOverlay = document.getElementById('loading-overlay');
            const loadingText = loadingOverlay.querySelector('p');
            const container = document.querySelector('.container');
            const userStatus = document.getElementById('userStatus');
            const userStatusAvatar = document.getElementById('userStatusAvatar');
            const userStatusName = document.getElementById('userStatusName');

            let authToken = null;

            async function apiFetch(url, options = {}) {
                // no loading indicator changes in here, handled by caller
                const defaultOptions = {
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    }
                };
                const mergedOptions = { ...defaultOptions, ...options };
                if (options.body && typeof options.body !== 'string') {
                    mergedOptions.body = JSON.stringify(options.body);
                }

                try {
                    const response = await fetch(url, mergedOptions);
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ error: '請求失敗' }));
                        throw new Error(errorData.error || `HTTP Error: ${response.status}`);
                    }
                    if (response.status === 204) return null;
                    return await response.json();
                } catch (error) {
                    alert(`API 錯誤: ${error.message}`);
                    throw error;
                }
            }

            async function checkAccess() {
                const userId = localStorage.getItem('boxCurrentUserId');
                authToken = localStorage.getItem(`boxUserToken_${userId}`);

                if (!userId || !authToken) {
                    loadingText.textContent = '您尚未登入，將為您導向登入頁面...';
                    setTimeout(() => {
                        window.location.href = `/member-login.html?redirect=${encodeURIComponent(window.location.href)}`;
                    }, 2000);
                    return;
                }

                try {
                    loadingText.textContent = '正在驗證您的權限...';
                    const userRoles = await apiFetch(`/api/box/users/${userId}/roles`);
                    
                    const hasAccess = userRoles.some(role => role.role_id > 1);

                    if (hasAccess) {
                        loadingOverlay.style.display = 'none';
                        container.style.display = 'grid';
                        userStatus.style.display = 'flex';
                        
                        const savedUserAvatarUrl = localStorage.getItem('boxCurrentUserAvatar');
                        const savedUserName = localStorage.getItem('boxCurrentUsername');
                        const savedDisplayName = localStorage.getItem('boxCurrentDisplayName') || savedUserName;
                        
                        userStatusAvatar.src = savedUserAvatarUrl || '/images/a01girlmove.gif';
                        userStatusName.textContent = savedDisplayName;
                        userStatus.addEventListener('click', () => {
                            window.location.href = `/member-editor.html?userId=${userId}`;
                        });
                        
                        initializeApp();
                    } else {
                        loadingText.textContent = '您的權限不足，將為您導向遊戲頁面...';
                        setTimeout(() => {
                            window.location.href = '/games.html';
                        }, 2000);
                    }
                } catch (error) {
                    console.error("Authorization check failed:", error);
                    loadingText.textContent = `權限驗證失敗。將為您導向遊戲頁面...`;
                    setTimeout(() => {
                        window.location.href = '/games.html';
                    }, 3000);
                }
            }
            
            function initializeApp() {
                const videoIdEl = document.getElementById('video-id');
                const keywordEl = document.getElementById('lottery-keyword');
                const apiRateInput = document.getElementById('api-rate-limit');
                const setVideoBtn = null; // 原按鈕已移除
                const stopMonitoringBtn = null; // 原按鈕已移除
                const monitoringVideoIdEl = document.getElementById('monitoring-video-id');
                const participantsListEl = document.getElementById('participants-list');
                const participantsCountEl = document.getElementById('participants-count');
                const drawWinnerBtn = document.getElementById('draw-winner-btn');
                const animationModeEl = document.getElementById('animation-mode');
                const durationEl = document.getElementById('animation-duration');
                const animationContainer = document.getElementById('animation-container');
                const defaultAnimation = document.getElementById('default-animation');
                const winnerDisplayEl = document.getElementById('winner-display');
                const winnerAvatarEl = document.getElementById('winner-avatar');
                const winnerNameEl = document.getElementById('winner-name');
                const confettiCanvas = document.getElementById('confetti-canvas');
                const viewHistoryBtn = document.getElementById('view-history-btn');
                const wheelCanvas = document.getElementById('wheel-canvas');
                const wheelCtx = wheelCanvas.getContext('2d');
                const pointerAnimationEl = document.getElementById('pointer-animation');
                const participantsReelEl = document.getElementById('participants-reel');
                const punchHoleAnimationEl = document.getElementById('punch-hole-animation');
                const punchHoleWinnerDisplayEl = document.getElementById('punch-hole-winner-display');
                const monitoringToggle = document.getElementById('checkbox');
                const toggleStatusEl = document.querySelector('.toggle-status');
                const modeToggle = document.getElementById('mode-toggle');
                let isLiveMode = true; // 默認為直播模式

                // 設置初始模式
                if(localStorage.getItem('ytLotteryMode') === 'video') {
                    modeToggle.checked = true;
                    isLiveMode = false;
                }

                // 監聽模式切換
                modeToggle.addEventListener('change', function() {
                    isLiveMode = !this.checked; // 未選中=直播模式，選中=影片模式
                    localStorage.setItem('ytLotteryMode', isLiveMode ? 'live' : 'video');
                    
                    // 如果正在監控中，顯示適當的狀態提示
                    if(monitoringToggle.checked) {
                        toggleStatusEl.textContent = isLiveMode ? 
                            '系統狀態: 監控中（直播）' : 
                            '系統狀態: 留言已載入（影片）';
                    } else {
                        toggleStatusEl.textContent = '系統狀態: 停止中';
                    }
                });

                const myConfetti = confetti.create(confettiCanvas, {
                    resize: true,
                    useWorker: true
                });

                let currentRotation = 0;
                let isSpinning = false;
                let angularVelocity = 0;
                const FRICTION = 0.995; // 摩擦力係數，確保輪盤最終會停下
                let selectedWinner = null;
                let updateTimer = null;
                let participants = []; // 在記憶體中保存參與者列表，避免重複讀取
                let winnerText = ''; // 用於在畫布中心顯示中獎者名字

                // Pointer animation state
                let isReelSpinning = false;
                let reelVelocity = 0;
                let reelPosition = 0;
                let reelAnimationId = null;
                const REEL_FRICTION = 0.988; // 摩擦力, 數值越小停越快
                const IDLE_SPEED = 60; // 待機時的滾動速度 (已提高)
                let idleAnimationId = null;
                let pointerWinnerDecided = false;
                let punchHoleReady = false;
                let punchHoleWinnerSelected = false;
                let punchHoleWinner = null;
                let isPunchHoleShuffled = false;

                async function saveWinnerToHistory(winner) {
                    if (!winner) return;

                    const winnerData = {
                        video_id: videoIdEl.value.trim(),
                        lottery_keyword: keywordEl.value.trim(),
                        winner_channel_id: winner.channelId,
                        winner_name: winner.displayName,
                        winner_avatar_url: winner.profileImageUrl,
                        winner_comment: winner.commentText || 'N/A', 
                        total_participants: participants.length,
                        animation_mode: animationModeEl.value
                    };

                    try {
                        const response = await fetch('/api/admin/lottery/history', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${authToken}`
                            },
                            body: JSON.stringify(winnerData)
                        });
                        
                        if (!response.ok) {
                            const errorData = await response.json().catch(() => ({ error: '請求失敗' }));
                            throw new Error(errorData.error || `HTTP Error: ${response.status}`);
                        }
                        
                        const result = await response.json();
                        console.log('抽獎紀錄已儲存:', result);
                    } catch (error) {
                        console.error('儲存抽獎紀錄時發生錯誤:', error);
                        alert(`儲存抽獎紀錄失敗: ${error.message}`);
                    }
                }

                function drawWheel() {
                    if (!wheelCanvas || !defaultAnimation) return;

                    const totalParticipants = participants.length;
                        
                    if (totalParticipants === 0) {
                        wheelCanvas.style.display = 'none';
                        defaultAnimation.style.display = 'block';
                        defaultAnimation.textContent = '監控中...等待參與者加入';
                        return;
                    }

                    wheelCanvas.style.display = 'block';
                    defaultAnimation.style.display = 'none';

                    const centerX = wheelCanvas.width / 2;
                    const centerY = wheelCanvas.height / 2;
                    const radius = Math.min(centerX, centerY) - 20;

                    wheelCtx.clearRect(0, 0, wheelCanvas.width, wheelCanvas.height);

                    wheelCtx.save();
                    wheelCtx.translate(centerX, centerY);
                    
                    // 為了簡化角度計算，我們讓指針指向 3 點鐘方向，並旋轉輪盤
                    wheelCtx.rotate(currentRotation);

                    const sliceAngle = (2 * Math.PI) / totalParticipants;
                    participants.forEach((p, index) => {
                        const startAngle = index * sliceAngle;
                        const endAngle = startAngle + sliceAngle;

                        // Draw slice
                        wheelCtx.beginPath();
                        wheelCtx.moveTo(0, 0);
                        wheelCtx.arc(0, 0, radius, startAngle, endAngle);
                        wheelCtx.closePath();
                        wheelCtx.fillStyle = `hsl(${(360 / totalParticipants) * index}, 70%, 60%)`;
                        wheelCtx.fill();
                        wheelCtx.stroke();

                        // Draw text
                        wheelCtx.save();
                        wheelCtx.rotate(startAngle + sliceAngle / 2);
                        wheelCtx.textAlign = 'right';
                        wheelCtx.fillStyle = 'white';
                        wheelCtx.font = '14px Arial';
                        const displayName = p.displayName.length > 10 ? p.displayName.substring(0, 10) + '...' : p.displayName;
                        wheelCtx.fillText(displayName, radius - 10, 5);
                        wheelCtx.restore();
                    });

                    wheelCtx.restore();

                    // 將指針畫在 12 點鐘方向（頂部），保持靜止
                    wheelCtx.save();
                    wheelCtx.translate(centerX, centerY - radius - 20); // 移到輪盤正上方
                    wheelCtx.fillStyle = '#ff4757';
                    
                    wheelCtx.beginPath();
                    wheelCtx.moveTo(0, 20); // 指針尖端指向輪盤邊緣
                    wheelCtx.lineTo(-10, 0);
                    wheelCtx.lineTo(10, 0);
                    wheelCtx.closePath();
                    wheelCtx.fill();
                    wheelCtx.restore();

                    // 如果輪盤已停止且有中獎者，在中間顯示名字
                    if (!isSpinning && winnerText) {
                        wheelCtx.save();
                        wheelCtx.font = 'bold 40px ' + getComputedStyle(document.body).fontFamily;
                        wheelCtx.fillStyle = 'rgba(255, 255, 255, 1)';
                        wheelCtx.textAlign = 'center';
                        wheelCtx.textBaseline = 'middle';
                        wheelCtx.shadowColor = 'black';
                        wheelCtx.shadowBlur = 10;
                        wheelCtx.shadowOffsetX = 2;
                        wheelCtx.shadowOffsetY = 2;
                        const displayName = winnerText.length > 10 ? winnerText.substring(0, 10) + '...' : winnerText;
                        wheelCtx.fillText(displayName, centerX, centerY);
                        wheelCtx.restore();
                    }
                }
                
                function startSpin() {
                    if (isSpinning) return;
                    if (participants.length < 2) {
                        alert('需要至少兩位參與者才能開始轉盤抽獎！');
                        return;
                    }
                    winnerText = ''; // 清除上一位中獎者名字
                    isSpinning = true;
                    // 給予一個隨機的初始速度 (弧度/幀)
                    angularVelocity = (Math.random() * 0.2) + 0.4;
                    requestAnimationFrame(animate);
                }

                function animate() {
                    if (!isSpinning) return;

                    currentRotation += angularVelocity;
                    angularVelocity *= FRICTION; // 應用摩擦力使其減速

                    drawWheel();

                    // 當速度小於一個閾值時，停止動畫
                    if (angularVelocity < 0.001) {
                        isSpinning = false;
                        angularVelocity = 0;
                        drawWheel(); // 畫最後一幀確保位置精確
                        determineWinnerFromAngle();
                    } else {
                        requestAnimationFrame(animate);
                    }
                }
                
                function determineWinnerFromAngle() {
                    const totalParticipants = participants.length;
                    if (totalParticipants === 0) return;

                    const sliceAngle = (2 * Math.PI) / totalParticipants;
                    
                    // 指針在 12 點鐘方向 (3*PI/2)，我們以此為基準計算
                    const pointerAngle = 3 * Math.PI / 2;
                    const finalAngle = currentRotation % (2 * Math.PI);
                    const targetAngle = (2 * Math.PI - finalAngle + pointerAngle) % (2 * Math.PI);
                    const winnerIndex = Math.floor(targetAngle / sliceAngle);

                    const winner = participants[winnerIndex];
                    if (winner) {
                        selectedWinner = winner;
                        winnerText = winner.displayName; // 設定要顯示的文字
                        highlightWinner(winner);
                        // showWinner(winner); // 不再彈出卡片
                        myConfetti({
                            particleCount: 150,
                            spread: 90,
                            origin: { y: 0.6 }
                        });
                        drawWheel(); // 重新繪製以立即顯示名字
                        saveWinnerToHistory(winner);
                    }
                }

                function highlightWinner(winner) {
                    const participantsList = participantsListEl.querySelectorAll('li');
                    participantsList.forEach(li => {
                        li.classList.remove('winner-highlight');
                        if (li.querySelector('span').textContent.includes(winner.displayName)) {
                            li.classList.add('winner-highlight');
                            li.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    });
                }

                function buildParticipantsReel() {
                    if (!participantsReelEl) return;
                    participantsReelEl.innerHTML = '';
                    participantsReelEl.style.transition = 'none';
                    participantsReelEl.style.transform = 'translateX(0px)';

                    if (participants.length === 0) {
                        stopReelIdleAnimation();
                        return;
                    }

                    // 為了製造無限滾動的感覺，我們複製參與者列表
                    const reelParticipants = [];
                    const repeatCount = Math.max(5, Math.ceil(40 / participants.length));
                    for(let i = 0; i < repeatCount; i++) {
                        reelParticipants.push(...participants);
                    }
                    
                    reelParticipants.forEach(p => {
                        const card = document.createElement('div');
                        card.className = 'reel-participant-card';
                        card.dataset.channelId = p.channelId;
                        card.innerHTML = `
                            <img src="${p.profileImageUrl}" alt="${p.displayName}">
                            <span>${p.displayName.substring(0, 12)}</span>
                        `;
                        participantsReelEl.appendChild(card);
                    });

                    startReelIdleAnimation();
                }

                function startReelIdleAnimation() {
                    stopReelIdleAnimation(); // 確保只有一個動畫在跑

                    let lastTime = null;
                    function idleAnimate(time) {
                        if (!lastTime) {
                            lastTime = time;
                            idleAnimationId = requestAnimationFrame(idleAnimate);
                            return;
                        }
                        const deltaTime = time - lastTime;
                        lastTime = time;

                        reelPosition -= IDLE_SPEED * (deltaTime / 16); // 標準化到 60fps
                        
                        const cardWidth = 120 + 20; // card width + margin
                        const loopWidth = cardWidth * participants.length;
                        if (reelPosition < -loopWidth) {
                            reelPosition += loopWidth;
                        }
                        participantsReelEl.style.transform = `translateX(${reelPosition}px)`;

                        idleAnimationId = requestAnimationFrame(idleAnimate);
                    }
                    idleAnimationId = requestAnimationFrame(idleAnimate);
                }

                function stopReelIdleAnimation() {
                    if (idleAnimationId) {
                        cancelAnimationFrame(idleAnimationId);
                        idleAnimationId = null;
                    }
                }

                function startPointerLottery() {
                    if (isReelSpinning) return;
                    if (participants.length < 2) {
                        alert('需要至少兩位參與者才能開始抽獎！');
                        return;
                    }
                    stopReelIdleAnimation();
                    isReelSpinning = true;
                    // 給予一個隨機的初始速度 (像素/幀)，增加速度以獲得拉霸機的感覺
                    reelVelocity = (Math.random() * 20) + 55;
                    
                    if (reelAnimationId) {
                        cancelAnimationFrame(reelAnimationId);
                    }
                    animateReel();
                }

                function animateReel() {
                    reelPosition -= reelVelocity;
                    reelVelocity *= REEL_FRICTION; // 應用摩擦力

                    const cardWidth = 120 + 20;
                    const totalReelWidth = cardWidth * participants.length * Math.floor(participantsReelEl.children.length / participants.length);
                    const loopWidth = cardWidth * participants.length;

                    // 為了循環效果，重置位置
                    if(reelPosition < -loopWidth * 2) {
                        reelPosition += loopWidth;
                    }

                    participantsReelEl.style.transform = `translateX(${reelPosition}px)`;

                    if (reelVelocity < 0.05) {
                        isReelSpinning = false;
                        cancelAnimationFrame(reelAnimationId);
                        reelAnimationId = null;
                        determinePointerWinner();
                    } else {
                        reelAnimationId = requestAnimationFrame(animateReel);
                    }
                }
                
                function determinePointerWinner() {
                    const pointerLine = pointerAnimationEl.getBoundingClientRect().left + (pointerAnimationEl.offsetWidth / 2);
                    const cards = participantsReelEl.querySelectorAll('.reel-participant-card');
                    
                    let winnerCard = null;
                    let minDistance = Infinity;

                    cards.forEach(card => {
                        const cardRect = card.getBoundingClientRect();
                        const cardCenter = cardRect.left + (cardRect.width / 2);
                        const distance = Math.abs(pointerLine - cardCenter);
                        
                        if (distance < minDistance) {
                            minDistance = distance;
                            winnerCard = card;
                        }
                    });

                    if (winnerCard) {
                        const winnerChannelId = winnerCard.dataset.channelId;
                        const winner = participants.find(p => p.channelId === winnerChannelId);
                        if(winner){
                            pointerWinnerDecided = true;
                            selectedWinner = winner;
                            highlightWinner(winner);
                            myConfetti({ particleCount: 150, spread: 90, origin: { y: 0.6 }});
                            
                            // 平滑地將中獎者卡片對齊到指針
                            const cardRect = winnerCard.getBoundingClientRect();
                            const cardCenter = cardRect.left + (cardRect.width / 2);
                            const offset = pointerLine - cardCenter;
                            
                            const currentTransform = new DOMMatrix(getComputedStyle(participantsReelEl).transform);
                            const currentX = currentTransform.m41;
                            
                            participantsReelEl.style.transition = 'transform 0.6s cubic-bezier(0.25, 1, 0.5, 1)';
                            participantsReelEl.style.transform = `translateX(${currentX + offset}px)`;

                            // 在中間顯示中獎者名字
                            const winnerDisplay = document.getElementById('pointer-winner-display');
                            if (winnerDisplay) {
                                winnerDisplay.textContent = winner.displayName;
                                winnerDisplay.style.display = 'block';
                            }
                            
                            // 儲存抽獎紀錄到資料庫
                            saveWinnerToHistory(winner);
                            
                            // 更改按鈕文字，提示可以重設
                            const buttonText = drawWinnerBtn.querySelector('.text');
                            if (buttonText) buttonText.textContent = '重設/再抽一次';

                        } else {
                            startReelIdleAnimation();
                        }
                    } else {
                        startReelIdleAnimation();
                    }
                }

                function resetPointerAnimation() {
                    pointerWinnerDecided = false;
                    
                    const winnerDisplay = document.getElementById('pointer-winner-display');
                    if (winnerDisplay) {
                        winnerDisplay.style.display = 'none';
                    }

                    const buttonText = drawWinnerBtn.querySelector('.text');
                    if (buttonText) buttonText.textContent = '立即抽獎';

                    const participantsList = participantsListEl.querySelectorAll('li');
                    participantsList.forEach(li => {
                        li.classList.remove('winner-highlight');
                    });
                    
                    // 重設捲軸的 transform transition
                    participantsReelEl.style.transition = 'none';

                    startReelIdleAnimation();
                }

                async function fetchParticipants() {
                    try {
                        const response = await apiFetch('/api/admin/lottery/participants');
                        const data = response;
                        
                        if (data.participants) {
                            updateParticipantsList(data.participants);
                            if (data.participants.length === 0) {
                                if (defaultAnimation) {
                                    defaultAnimation.textContent = '監控中...等待參與者加入';
                                }
                            }
                        } else {
                            throw new Error('參與者資料格式錯誤');
                        }
                    } catch (error) {
                        console.error('Error fetching participants:', error);
                        if (defaultAnimation) {
                            defaultAnimation.textContent = '更新參與者名單失敗';
                        }
                    }
                }

                function startAutoUpdate() {
                    if (updateTimer) {
                        clearInterval(updateTimer);
                    }
                    
                    fetchParticipants();
                    
                    const interval = parseInt(apiRateInput.value, 10) * 1000;
                    updateTimer = setInterval(fetchParticipants, interval);

                    // 更新狀態顯示
                    toggleStatusEl.textContent = '系統狀態: 監控中';
                    toggleStatusEl.style.color = '#50fa7b'; // 綠色
                }

                function stopAutoUpdate() {
                    if (updateTimer) {
                        clearInterval(updateTimer);
                        updateTimer = null;
                    }

                    // 更新狀態顯示
                    toggleStatusEl.textContent = '系統狀態: 停止中';
                    toggleStatusEl.style.color = '#ff5555'; // 紅色
                }

                function updateParticipantsList(participantsData) {
                    if (!participantsListEl || !participantsCountEl) return;

                    participants = participantsData; // 更新全局參與者陣列
                    participantsListEl.innerHTML = '';
                    participantsCountEl.textContent = `目前參與人數：${participants.length} 人`;

                    participants.forEach((participant, index) => {
                        const li = document.createElement('li');
                        li.className = 'participant';
                        // 將 channelId 存儲在 data 屬性中
                        li.dataset.channelId = participant.channelId;
                        li.innerHTML = `
                            <img src="${participant.profileImageUrl}" alt="${participant.displayName}" class="participant-avatar">
                            <span>${participant.displayName}</span>
                            <button class="delete-btn">刪除</button>
                        `;

                        // 點擊參與者列表項目時的處理
                        li.addEventListener('click', (e) => {
                            // 如果點擊的是刪除按鈕，不切換選中狀態
                            if (e.target.classList.contains('delete-btn')) {
                                return;
                            }
                            li.classList.toggle('selected');
                        });

                        // 刪除按鈕的點擊處理
                        const deleteBtn = li.querySelector('.delete-btn');
                        deleteBtn.addEventListener('click', async (e) => {
                            e.stopPropagation();
                            if (confirm(`確定要刪除參與者 "${participant.displayName}" 嗎？`)) {
                                try {
                                    // 使用 data-channel-id 來獲取正確的 channelId
                                    const channelId = li.dataset.channelId;
                                    const result = await apiFetch('/api/admin/lottery/remove-participant', {
                                        method: 'POST',
                                        body: { channelId }
                                    });

                                    // 刪除成功後，重新從伺服器獲取最新的參與者列表
                                    // 這樣可以確保前後端狀態一致，並自動更新UI和轉盤
                                    fetchParticipants();
                                    alert(`參與者 "${participant.displayName}" 已成功刪除。`);
                                } catch (error) {
                                    console.error('Error removing participant:', error);
                                    alert(`刪除失敗: ${error.message}`);
                                }
                            }
                        });

                        participantsListEl.appendChild(li);
                    });
                    
                    // 更新動畫視圖
                    setupAnimationView(animationModeEl.value);
                }
                
                function setupAnimationView(mode) {
                    if (participants.length === 0) {
                        wheelCanvas.style.display = 'none';
                        pointerAnimationEl.style.display = 'none';
                        punchHoleAnimationEl.style.display = 'none';
                        defaultAnimation.style.display = 'block';
                        defaultAnimation.textContent = '監控中...等待參與者加入';
                        stopReelIdleAnimation();
                        return;
                    }
                    
                    defaultAnimation.style.display = 'none';

                    if (mode === 'turntable') {
                        wheelCanvas.style.display = 'block';
                        pointerAnimationEl.style.display = 'none';
                        punchHoleAnimationEl.style.display = 'none';
                        stopReelIdleAnimation();
                        drawWheel();
                    } else if (mode === 'pointer') {
                        wheelCanvas.style.display = 'none';
                        pointerAnimationEl.style.display = 'block';
                        punchHoleAnimationEl.style.display = 'none';
                        buildParticipantsReel();
                    } else if (mode === 'punch-hole') {
                        wheelCanvas.style.display = 'none';
                        pointerAnimationEl.style.display = 'none';
                        punchHoleAnimationEl.style.display = 'block';
                        setupPunchHoleCards();
                    } else {
                        // 未來其他模式的處理
                        wheelCanvas.style.display = 'none';
                        pointerAnimationEl.style.display = 'none';
                        punchHoleAnimationEl.style.display = 'none';
                        stopReelIdleAnimation();
                    }
                }
                
                function setupPunchHoleCards() {
                    if (!punchHoleAnimationEl) return;
                    
                    // 清除所有卡片
                    punchHoleAnimationEl.querySelectorAll('.punch-card').forEach(card => card.remove());
                    punchHoleWinnerDisplayEl.textContent = '';
                    punchHoleWinnerDisplayEl.classList.remove('show');
                    
                    if (participants.length === 0) {
                        return;
                    }
                    
                    // 重置狀態
                    punchHoleReady = true;
                    punchHoleWinnerSelected = false;
                    punchHoleWinner = null;
                    isPunchHoleShuffled = false;
                    
                    // 重置容器樣式
                    punchHoleAnimationEl.style.display = 'grid';
                    punchHoleAnimationEl.style.position = ''; // 清除 position 屬性
                    
                    // 創建卡片 - 初始時正面朝上，排列成磚牆
                    participants.forEach((participant, index) => {
                        const card = document.createElement('div');
                        card.className = 'punch-card';
                        card.dataset.channelId = participant.channelId;
                        card.dataset.index = index;
                        
                        card.innerHTML = `
                            <div class="punch-card-front">
                                <img src="${participant.profileImageUrl}" alt="${participant.displayName}">
                                <span>${participant.displayName}</span>
                            </div>
                            <div class="punch-card-back">
                                <span class="card-number"></span>
                            </div>
                        `;
                        
                        punchHoleAnimationEl.appendChild(card);
                    });
                    
                    // 更新按鈕文字和指示
                    const buttonText = drawWinnerBtn.querySelector('.text');
                    if (buttonText) buttonText.textContent = '打亂卡片';
                    
                    document.querySelector('.punch-instruction').textContent = '請點擊「打亂卡片」開始抽獎';
                }
                
                function shufflePunchHoleCards() {
                    if (!punchHoleReady || punchHoleWinnerSelected || isPunchHoleShuffled) return;
                    
                    // 禁用按鈕防止重複點擊
                    drawWinnerBtn.disabled = true;
                    
                    // 取得所有卡片
                    const cards = punchHoleAnimationEl.querySelectorAll('.punch-card');
                    const containerWidth = punchHoleAnimationEl.clientWidth;
                    const containerHeight = punchHoleAnimationEl.clientHeight;
                    
                    // 重要：保持網格布局，但將卡片設為絕對定位
                    // punchHoleAnimationEl.style.display = 'block'; // 移除這行，保持網格布局
                    
                    // 隨機打亂卡片順序
                    const cardsArray = Array.from(cards);
                    const parentNode = punchHoleAnimationEl;
                    
                    // 先記錄所有卡片的初始位置
                    const initialPositions = [];
                    cardsArray.forEach(card => {
                        const rect = card.getBoundingClientRect();
                        const parentRect = parentNode.getBoundingClientRect();
                        initialPositions.push({
                            top: rect.top - parentRect.top,
                            left: rect.left - parentRect.left
                        });
                    });
                    
                    // 設置容器樣式，允許絕對定位的卡片
                    punchHoleAnimationEl.style.position = 'relative';
                    
                    // 先將所有卡片變為絕對定位，準備動畫，但保持在原來的位置
                    cardsArray.forEach((card, index) => {
                        const pos = initialPositions[index];
                        card.style.position = 'absolute';
                        card.style.top = `${pos.top}px`;
                        card.style.left = `${pos.left}px`;
                        card.style.margin = '0'; // 移除margin，因為現在使用絕對定位
                        card.classList.add('shuffling');
                    });
                    
                    // 第一階段：先翻面（背面朝上）- 但不移動位置
                    setTimeout(() => {
                        cardsArray.forEach(card => {
                            // 只添加翻面效果，不改變位置
                            card.classList.add('face-down');
                        });
                        
                        // 確保卡片完全翻到背面後再開始打亂
                        setTimeout(() => {
                            // 第二階段：直接打亂卡片（不集中到中心）
                            
                            // 首先，創建一個網格位置的陣列
                            const positions = [];
                            const cardWidth = 120; // 卡片寬度，不包含margin
                            const cardHeight = 150; // 卡片高度，不包含margin
                            const cardMargin = 10; // 卡片之間的間距
                            const effectiveCardWidth = cardWidth + cardMargin * 2;
                            const effectiveCardHeight = cardHeight + cardMargin * 2;
                            const cardsPerRow = Math.floor(containerWidth / effectiveCardWidth);
                            
                            // 計算每個卡片可能的位置
                            for (let i = 0; i < cardsArray.length; i++) {
                                const row = Math.floor(i / cardsPerRow);
                                const col = i % cardsPerRow;
                                
                                const left = (col * effectiveCardWidth) + (containerWidth - cardsPerRow * effectiveCardWidth) / 2 + cardMargin;
                                const top = (row * effectiveCardHeight) + 20 + cardMargin;
                                
                                positions.push({ left, top });
                            }
                            
                            // 打亂位置陣列
                            for (let i = positions.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [positions[i], positions[j]] = [positions[j], positions[i]];
                            }
                            
                            // 第一次隨機移動 - 讓卡片在原位置附近隨機偏移
                            cardsArray.forEach((card, index) => {
                                // 使用初始位置作為基準
                                const initialPos = initialPositions[index];
                                
                                // 隨機偏移量，但偏移範圍較小
                                const offsetX = (Math.random() - 0.5) * 60;
                                const offsetY = (Math.random() - 0.5) * 60;
                                
                                // 確保不超出容器
                                const newLeft = Math.max(0, Math.min(containerWidth - cardWidth, initialPos.left + offsetX));
                                const newTop = Math.max(0, Math.min(containerHeight - cardHeight, initialPos.top + offsetY));
                                
                                // 直接設置新位置，不使用transform來移動
                                card.style.left = `${newLeft}px`;
                                card.style.top = `${newTop}px`;
                                // 只使用transform來處理旋轉和翻面
                                card.style.transform = `rotate(${Math.random() * 20 - 10}deg) rotateY(180deg)`;
                            });
                            
                            // 第二次隨機移動 - 更大幅度的移動
                            setTimeout(() => {
                                cardsArray.forEach((card, index) => {
                                    // 獲取當前位置
                                    const currentLeft = parseFloat(card.style.left);
                                    const currentTop = parseFloat(card.style.top);
                                    
                                    // 更大的隨機偏移
                                    const offsetX = (Math.random() - 0.5) * 120;
                                    const offsetY = (Math.random() - 0.5) * 120;
                                    
                                    // 確保不超出容器
                                    const newLeft = Math.max(0, Math.min(containerWidth - cardWidth, currentLeft + offsetX));
                                    const newTop = Math.max(0, Math.min(containerHeight - cardHeight, currentTop + offsetY));
                                    
                                    // 直接設置新位置
                                    card.style.left = `${newLeft}px`;
                                    card.style.top = `${newTop}px`;
                                    // 只使用transform來處理旋轉和翻面
                                    card.style.transform = `rotate(${Math.random() * 40 - 20}deg) rotateY(180deg)`;
                                });
                                
                                // 第三階段：最終排列成網格
                                setTimeout(() => {
                                    // 將卡片移動到最終位置
                                    cardsArray.forEach((card, index) => {
                                        const position = positions[index];
                                        
                                        // 直接設置最終位置
                                        card.style.left = `${position.left}px`;
                                        card.style.top = `${position.top}px`;
                                        // 保持卡片背面朝上，但旋轉角度恢復正常
                                        card.style.transform = `rotate(0deg) rotateY(180deg)`;
                                    });
                                    
                                    // 為所有卡片添加點擊事件並分配數字
                                    setTimeout(() => {
                                        // 根據視覺位置排序卡片，以便分配正確的編號
                                        const sortedCards = cardsArray.sort((a, b) => {
                                            const topA = parseFloat(a.style.top);
                                            const topB = parseFloat(b.style.top);
                                            if (Math.abs(topA - topB) > 10) { // 如果垂直位置差異大於一個閾值
                                                return topA - topB;
                                            }
                                            return parseFloat(a.style.left) - parseFloat(b.style.left);
                                        });

                                        sortedCards.forEach((card, index) => {
                                            const numberEl = card.querySelector('.card-number');
                                            if (numberEl) {
                                                numberEl.textContent = index + 1;
                                            }
                                            
                                            // 確保卡片仍然是背面朝上
                                            if (!card.classList.contains('face-down')) {
                                                card.classList.add('face-down');
                                            }
                                            card.addEventListener('click', handlePunchCardClick);
                                        });
                                        
                                        // 更新狀態和提示
                                        isPunchHoleShuffled = true;
                                        document.querySelector('.punch-instruction').textContent = '請選擇一張卡片揭曉中獎者';
                                        
                                        // 更新按鈕文字
                                        const buttonText = drawWinnerBtn.querySelector('.text');
                                        if (buttonText) buttonText.textContent = '重新發牌';
                                        
                                        // 重新啟用按鈕
                                        drawWinnerBtn.disabled = false;
                                    }, 800);
                                }, 800);
                            }, 400);
                        }, 200); // 添加小延遲確保翻面完成
                    }, 50);
                }
                
                function handlePunchCardClick(e) {
                    if (!punchHoleReady || punchHoleWinnerSelected || !isPunchHoleShuffled) return;
                    
                    const card = e.currentTarget;
                    if (card.classList.contains('selected')) return;
                    
                    // 選擇了這張卡片作為中獎者
                    card.classList.add('selected');
                    card.classList.remove('face-down');
                    
                    punchHoleWinnerSelected = true;
                    
                    // 獲取中獎者資訊
                    const channelId = card.dataset.channelId;
                    const winner = participants.find(p => p.channelId === channelId);
                    
                    if (winner) {
                        punchHoleWinner = winner;
                        selectedWinner = winner;
                        highlightWinner(winner);
                        
                        // 標記卡片為中獎，並放大顯示
                        setTimeout(() => {
                            card.classList.add('winner');
                        }, 500);
                        
                        // 顯示中獎提示
                        punchHoleWinnerDisplayEl.textContent = `🎉 恭喜 ${winner.displayName} 中獎！`;
                        punchHoleWinnerDisplayEl.classList.add('show');
                        
                        // 更新指示文字
                        document.querySelector('.punch-instruction').textContent = '已選出中獎者，點擊「重新發牌」開始新一輪抽獎';
                        
                        // 播放慶祝特效
                        myConfetti({
                            particleCount: 150,
                            spread: 90,
                            origin: { y: 0.6 }
                        });

                        saveWinnerToHistory(winner);
                    }
                    
                    // 防止繼續點擊其他卡片
                    punchHoleAnimationEl.querySelectorAll('.punch-card:not(.selected)').forEach(otherCard => {
                        otherCard.removeEventListener('click', handlePunchCardClick);
                        otherCard.style.opacity = '0.5';
                        otherCard.style.cursor = 'default';
                    });
                }
                
                function resetPunchHoleAnimation() {
                    punchHoleReady = false;
                    punchHoleWinnerSelected = false;
                    punchHoleWinner = null;
                    isPunchHoleShuffled = false;
                    
                    // 清除高亮
                    const participantsList = participantsListEl.querySelectorAll('li');
                    participantsList.forEach(li => {
                        li.classList.remove('winner-highlight');
                    });
                    
                    // 重新設置
                    setupPunchHoleCards();
                }

                function showTemporaryAnimation(participants, callback) {
                    animationContainer.style.display = 'block';
                    winnerDisplayEl.style.display = 'none';
                    
                    if (participants.length === 0) {
                        animationContainer.textContent = '沒有參與者!';
                        return;
                    }
                    
                    let animationInterval = setInterval(() => {
                        const randomParticipant = participants[Math.floor(Math.random() * participants.length)];
                        animationContainer.innerHTML = `
                            <img src="${randomParticipant.profileImageUrl}" style="width: 80px; height: 80px; border-radius: 50%; margin-right: 20px;">
                            <span>${randomParticipant.displayName}</span>
                        `;
                    }, 100);

                    setTimeout(() => {
                        clearInterval(animationInterval);
                        callback();
                    }, 5000);
                }

                function showWinner(winner) {
                    const winnerDisplay = document.getElementById('winner-display');
                    const winnerAvatar = document.getElementById('winner-avatar');
                    const winnerName = document.getElementById('winner-name');
                    
                    winnerAvatar.src = winner.profileImageUrl;
                    winnerName.textContent = winner.displayName;
                    winnerDisplay.classList.add('show');

                    const closeBtn = winnerDisplay.querySelector('.close-winner');
                    if (closeBtn) {
                        closeBtn.onclick = () => {
                            winnerDisplay.classList.remove('show');
                        };
                    }

                    setTimeout(() => {
                        winnerDisplay.classList.remove('show');
                    }, 10000); // 延長顯示時間
                }

                drawWinnerBtn.addEventListener('click', async () => {
                    const animationMode = animationModeEl.value;
                    
                    if (animationMode === 'turntable') {
                        startSpin();
                    } else if (animationMode === 'pointer') {
                        if (pointerWinnerDecided) {
                            resetPointerAnimation();
                        } else {
                            startPointerLottery();
                        }
                    } else if (animationMode === 'punch-hole') {
                        // 洞洞樂模式
                        if (isPunchHoleShuffled) {
                            // 如果已經打亂，就重新發牌
                            resetPunchHoleAnimation();
                        } else {
                            // 如果還沒打亂，就打亂卡片
                            shufflePunchHoleCards();
                        }
                    } else {
                        // 對於其他模式，維持原樣，先從後端獲取結果
                        try {
                            const result = await apiFetch('/api/admin/lottery/draw', {
                                method: 'POST',
                                body: { 
                                    animationMode,
                                    duration: 0 
                                }
                            });

                            if (!result.winner) throw new Error('未能獲取中獎者資訊');

                            const winner = result.winner;
                            selectedWinner = winner;
                            highlightWinner(winner);
                            showWinner(winner);
                            myConfetti({ particleCount: 150, spread: 90, origin: { y: 0.6 }});
                        } catch (error) {
                            console.error('抽獎出錯:', error);
                            alert(`抽獎失敗: ${error.message}`);
                        }
                    }
                });
                
                viewHistoryBtn.addEventListener('click', () => {
                    window.location.href = 'lottery-history.html';
                });
                
                // 新增返回遊戲按鈕事件監聽
                const backToGameBtn = document.getElementById('back-to-game-btn');
                backToGameBtn.addEventListener('click', () => {
                    window.location.href = '/games.html';
                });
                
                animationModeEl.addEventListener('change', () => {
                    if(isReelSpinning || isSpinning) {
                        alert('請等待目前抽獎動畫結束！');
                        animationModeEl.value = isSpinning ? 'turntable' : 'pointer';
                        return;
                    }
                    if (pointerWinnerDecided) {
                        alert('請先重設指針抽獎，才能切換模式！');
                        animationModeEl.value = 'pointer';
                        return;
                    }
                    if (punchHoleWinnerSelected) {
                        alert('請先重新發牌，才能切換模式！');
                        animationModeEl.value = 'punch-hole';
                        return;
                    }
                    setupAnimationView(animationModeEl.value);
                });

                // 當API請求間隔改變時，如果正在監控中，則重設計時器
                apiRateInput.addEventListener('change', () => {
                    if (updateTimer) {
                        startAutoUpdate();
                    }
                });

                // 監控開關的事件處理
                monitoringToggle.addEventListener('change', async function() {
                    if (this.checked) {
                        // 開始監控
                        const videoId = videoIdEl.value.trim();
                        const keyword = keywordEl.value.trim();
                        const apiRateLimit = parseInt(apiRateInput.value, 10);

                        if (!videoId || !keyword) {
                            alert('請填寫 Video ID 和關鍵字！');
                            this.checked = false;
                            return;
                        }

                        try {
                            const result = await apiFetch('/api/admin/lottery/set-video', {
                                method: 'POST',
                                body: {
                                    videoId,
                                    keyword,
                                    apiRateLimit,
                                    forceLiveMode: isLiveMode // 傳遞用戶選擇的模式
                                }
                            });
                            
                            monitoringVideoIdEl.textContent = ` (${result.videoTitle})`;
                            
                            // 根據返回的實際模式設置UI
                            const actualIsLive = result.isLive;
                            apiRateInput.disabled = !actualIsLive;

                            if (actualIsLive) {
                                // 直播模式
                                toggleStatusEl.textContent = '系統狀態: 監控中（直播）';
                                startAutoUpdate();
                            } else {
                                // 影片留言模式
                                toggleStatusEl.textContent = `系統狀態: 留言已載入（影片）`;
                                stopAutoUpdate(); // 確保沒有舊的計時器在跑
                                // 後端已返回參與者數量，可以直接更新，並手動抓取一次列表
                                participantsCountEl.textContent = `目前參與人數：${result.participantCount} 人`;
                                fetchParticipants(); 
                            }

                        } catch (error) {
                            console.error('Error setting video:', error);
                            alert(`設置失敗: ${error.message}`);
                            this.checked = false;
                        }
                    } else {
                        // 停止監控
                        try {
                            const result = await apiFetch('/api/admin/lottery/stop-monitoring', {
                                method: 'POST'
                            });
                            
                            if (result.success) {
                                stopAutoUpdate();
                                monitoringVideoIdEl.textContent = '';
                                defaultAnimation.textContent = '已停止監控';
                                apiRateInput.disabled = false; // 重新啟用 API 頻率選項
                                toggleStatusEl.textContent = '系統狀態: 停止中';
                            } else {
                                throw new Error(result.error || '停止監控失敗');
                            }
                        } catch (error) {
                            console.error('Error stopping monitoring:', error);
                            alert(`停止監控失敗: ${error.message}`);
                            this.checked = true;
                        }
                    }
                });

                // Initial setup
                setupAnimationView(animationModeEl.value);
            }

            checkAccess();
        });
    </script>
</body>
</html> 